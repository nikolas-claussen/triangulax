# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_triangular_meshes.ipynb.

# %% auto #0
__all__ = ['TriMesh', 'generate_ginibre_points', 'generate_poisson_points', 'generate_triangular_lattice',
           'get_adjacent_vertex_indices']

# %% ../nbs/01_triangular_meshes.ipynb #d159edd4-4456-41f8-b520-8b1b69219c67
import numpy as np
import matplotlib.pyplot as plt

import igl

from scipy import spatial

# %% ../nbs/01_triangular_meshes.ipynb #9f1cb15c-86cd-4e64-8f21-d4726216cd2f
import jax
import jax.numpy as jnp

# %% ../nbs/01_triangular_meshes.ipynb #723a50d1-f5c2-435c-9026-39b6067f426d
from jaxtyping import Float, Int 
from pathlib import Path

import dataclasses

# %% ../nbs/01_triangular_meshes.ipynb #cef3ff0a
from . import trigonometry as trig

# %% ../nbs/01_triangular_meshes.ipynb #468fc48c-bf9f-46b9-bc24-74638da2c662
@dataclasses.dataclass(init=True, repr=False, eq=False, frozen=False, slots=False)
class TriMesh:
    """
    Simple class for reading, holding, transforming, and saving triangular meshes.
    
    A TriMesh comprises vertices and faces, describing a surface in 2d or 3d. 
    In addition, there can be a 2d/3d position for every face (think Voronoi dual of the triangulation).
    
    Vertices and faces are jnp.arrays. Each face is a triple of vertex indices.
    Vertices and faces are ordered - this is essential so that we know which attribute
    vector entry goes to which vector/edge/face. Faces in a face are assumed to be in counter-clockwise order.

    Meshes are read and written in the .obj format (https://en.wikipedia.org/wiki/Wavefront_.obj_file).
    To store _face_positions_, we abuse the `vn` (vertex normal) entry of an .obj file. Face
    positions will be written in order corresponding to faces.
    When reading from an .obj file, edges are recomputed from faces and initialized in alpha-numerical ordering.
    An .obj file expects 3d positions; the z-position is ignored when reading and set to 0 when writing for 2d meshes.

    **Attributes**

    dim : int = 2
    
    vertices : Float[jax.Array, "n_vertices dim"]

    faces : Int[jax.Array, "n_faces 3"]

    face_positions : Float[jax.Array, "n_faces dim"]

    **Property methods (use like attributes)**

    n_vertices : int

    has_inf_vertex : bool

    **Static methods**
    
    read_obj : str -> TriMesh

    **Methods**

    write_obj : str -> None
        
    """
    vertices : Float[jax.Array, "n_vertices dim"]
    faces : Int[jax.Array, "n_faces 3"]
    face_positions : Float[jax.Array, "n_faces dim"] | None = None

    def set_voronoi(self):
        """Set face positions to the Voronoi dual of the faces is computed."""
        self.face_positions = jax.vmap(trig.get_circumcenter)(*[self.vertices[fcs] for fcs in self.faces.T])
        
    @staticmethod  
    def read_obj(filename: str | Path, read_face_positions: bool = False, dim: int = 2) -> "TriMesh":
        """
        Read vertices, texture vertices, normals, and faces from an obj file.

        Indices of returned faces start at 0. See https://en.wikipedia.org/wiki/Wavefront_.obj_file.
        Intended for .obj files containing a single object only.

        Parameters
        ----------
        filename : str
            filename
        read_face_positions : bool
            If True, use the vertex normal entries `vn` in the .obj file
            as face positions. This is an abuse of the .obj file format
            so only use this for files written by this code.
        dim : int
            Dimension - can be 2 or 3. If 2, the z-coordinate is ignored.
        
        Returns
        -------
        mesh: TriMesh
        """
        vertices, _, normals, faces, _, _ = igl.readOBJ(filename)
        if read_face_positions:
            return TriMesh(jnp.array(vertices[:,:dim]), jnp.array(faces), face_positions=jnp.array(normals[:,:dim]))
        mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)
        mesh.set_voronoi()
        return mesh
        
    def write_obj(self, filename: str | Path, save_face_positions: bool=True) -> None:
        """
        Write mesh to .obj format.

        Parameters
        ----------
        filename : str
            filename to save to
        save_face_positions : bool
            If true, face positions are written to the `vn` line of .obj files.
            
        Returns
        -------
        None
        """
        if self.dim == 2:
            vlines = ["v {} {} 0\n".format(*v) for v in self.vertices]
            vnlines = ["vn {} {} 0\n".format(*vn) for vn in self.face_positions]
        elif self.dim == 3:
            vlines = ["v {} {} {}\n".format(*v) for v in self.vertices]
            vnlines = ["vn {} {}\n".format(*vn) for vn in self.face_positions]
        flines = ["f {} {} {}\n".format(*[int(v+1) for v in fc]) for fc in self.faces]

        with open(filename, 'w') as f:
            if save_face_positions:
                f.writelines(["#Attention: vn-lines encode face centers, not normals",])
            f.writelines(vlines)
            if save_face_positions:
                f.writelines(vnlines)               
            f.writelines(flines)
        return None

    @property
    def has_inf_vertex(self) -> bool:
        return jnp.isinf(self.vertices).any()

    @property
    def n_vertices(self) -> int:
        return self.vertices.shape[0]

    @property
    def dim(self) -> int:
        return self.vertices.shape[-1]



# %% ../nbs/01_triangular_meshes.ipynb #71736c3c-c197-48f0-8cd3-c5ba9fba9713
def generate_ginibre_points(n_vertices: int) -> Float[jax.Array, "n_vertices 2"]:
    """Sample n_vertices points from the Ginibre ensemble. Points are scaled to unit disk."""
    M = np.random.normal(size=(n_vertices, n_vertices)) + 1j*np.random.normal(size=(n_vertices, n_vertices))
    vals = np.linalg.eigvals(M)
    pos = np.stack([vals.real, vals.imag], axis=-1)
    # rescale to unit disk
    pos /= np.linalg.norm(pos, axis=1).mean()
    return jnp.array(pos)

def generate_poisson_points(n_vertices: int, limit_x: float = 1, limit_y: float = 1
                           ) -> Float[jax.Array, "n_vertices 2"]:
    """Sample n_vertices points from the Poisson ensemble in rectangle
    [-limit_x/2, limit_x/2] * [-limit_y/2, limit_y/2]."""
    pos = np.stack([np.random.uniform(size=n_vertices, low=-limit_x/2, high=limit_x/2),
                    np.random.uniform(size=n_vertices, low=-limit_y/2, high=limit_y/2)])
    return jnp.array(pos)

def generate_triangular_lattice(nx: int, ny: int) -> Float[jax.Array, "nx*ny 2"]:
    """Get points for rectangular patch of triangular lattice with nx, ny points."""
    y = np.arange(0, ny)*np.sqrt(3)/2
    x = np.arange(nx).astype(float)
    X, Y = np.meshgrid(x, y)
    X -= X.mean()+1/2
    Y -=Y.mean()
    X = (X.T+(np.arange(ny)%2)/2).T
    pts = np.stack([X, Y]).reshape((2,nx*ny))    
    return jnp.array(pts.T)

# %% ../nbs/01_triangular_meshes.ipynb #2c4a0e23-ac42-4264-9a38-f8745e02a131
# find the vertices and faces which are adjacent to a given vertex, in the correct counter-clockwise order.

def get_adjacent_vertex_indices(faces: Int[jax.Array, "n_faces 3"],
                                n_vertices: int) -> list[Int[jax.Array, " n_neighbors"]]:
    """For each vertex, get the indices of the adjacent vertices in correct order.
    For boundary vertices, this list contains the vertex itself."""
    faces = np.array(faces)
    vf, ni = igl.vertex_triangle_adjacency(faces, n=n_vertices)
    adjacent_faces = [vf[a:b] for a, b in zip(ni[:-1], jnp.roll(ni, -1)[:-1])]
    adjacent_vertices = [jnp.array(igl.boundary_loop(faces[fcs])) for fcs in adjacent_faces]
    return adjacent_vertices
