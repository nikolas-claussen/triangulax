# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_topological_modifications.ipynb.

# %% auto #0
__all__ = ['flip_edge', 'flip_by_id', 'flip_all', 'remap_inds_removal_forward', 'remap_inds_removal_reverse', 'MeshReindexMap',
           'collapse_edge', 'split_vertex']

# %% ../nbs/04_topological_modifications.ipynb #d159edd4-4456-41f8-b520-8b1b69219c67
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt

import igl

# %% ../nbs/04_topological_modifications.ipynb #9f1cb15c-86cd-4e64-8f21-d4726216cd2f
import jax
import jax.numpy as jnp

# %% ../nbs/04_topological_modifications.ipynb #723a50d1-f5c2-435c-9026-39b6067f426d
from jaxtyping import Float, Int, Bool, PyTree 
from typing import Any, Iterable, NamedTuple
from pathlib import Path
from enum import IntEnum

import dataclasses

import functools

# %% ../nbs/04_topological_modifications.ipynb #cef3ff0a
from . import trigonometry as trig
from .triangular import TriMesh
from .mesh import HeMesh, GeomMesh
import triangulax.mesh as msh

# %% ../nbs/04_topological_modifications.ipynb #2a1c1f7c-4c6e-4312-9820-cf497590c452
@functools.partial(jax.jit, static_argnames=['check_boundary'])
def flip_edge(hemesh: HeMesh, e: Int[jax.Array, ""], check_boundary: bool = False) -> HeMesh:
    """
    Flip half-edge e in a half-edge mesh.
    
    See https://jerryyin.info/geometry-processing-algorithms/half-edge/. The algorithm
    is slightly modified since we keep track of the origin and destination of a half-edge,
    and use arrays instead of pointers. Returns a new HeMesh, does not modify in-place.
    """
    if check_boundary:
        assert (hemesh.heface[e] !=-1 and hemesh.heface[hemesh.twin[e]] != -1), "Cannot flip boundary edge"

    # identify relevant elements
    e5 = hemesh.prv[e]
    e4 = hemesh.nxt[e]
    twin = hemesh.twin[e]
    e1 = hemesh.prv[twin] 
    e0 = hemesh.nxt[twin] 

    # make sure there’s no vertex or face references to e or twin
    incident = hemesh.incident.at[jnp.array([hemesh.orig[e], hemesh.orig[twin]])].set(
        jnp.array([hemesh.twin[e5], hemesh.twin[e1]]))
    face_incident = hemesh.face_incident.at[jnp.array([hemesh.heface[e], hemesh.heface[twin]])].set(
        jnp.array([e5, e1])) # e1, e5 don't change face

    # update the data structure to do the T1
    nxt = hemesh.nxt.at[jnp.array([e, twin])].set(jnp.array([e5, e1]))
    prv = hemesh.prv.at[jnp.array([e, twin])].set(jnp.array([e0, e4]))
    orig = hemesh.orig.at[jnp.array([e, twin])].set(jnp.array([hemesh.orig[e1], hemesh.orig[e5]]) )
    dest = hemesh.dest.at[jnp.array([e, twin])].set(jnp.array([hemesh.dest[e4], hemesh.dest[e0]]))

    nxt = nxt.at[jnp.array([e0, e1, e4, e5])].set(jnp.array([e, e4, twin, e0]) )
    prv = prv.at[jnp.array([e0, e1, e4, e5])].set(jnp.array([e5, twin, e1, e]) )
    heface = hemesh.heface.at[jnp.array([e0, e4])].set(jnp.array([hemesh.heface[e5], hemesh.heface[e1]]))

    return HeMesh(incident, orig, dest, jnp.copy(hemesh.twin), nxt, prv, heface, face_incident, hemesh.inf_vertices)

# %% ../nbs/04_topological_modifications.ipynb #242d6ee1-d553-45fc-852f-a80fbb4a589a
@jax.jit
def flip_by_id(hemesh: HeMesh, ids: Int[jax.Array, " flips"], to_flip: Bool[jax.Array, " flips"]) -> HeMesh:
    """Flip half-edges from ids array if the to_flip is True. Wraps flip_edge."""
    def scan_fun(h, x): # flips edge e if its length < 0 and edge is unique. Otherwise, you undo your flips!
        return jax.lax.cond(x[1], lambda hh: flip_edge(hh, x[0]), lambda hh: hh, h), None
    xs = jnp.stack([ids, to_flip], axis=1)  
    flipped_hemesh, _ = jax.lax.scan(scan_fun, init=hemesh, xs=xs)
    return flipped_hemesh

@jax.jit
def flip_all(hemesh: HeMesh, to_flip: Bool[jax.Array, " n_hes"]) -> HeMesh:
    """Flip all (unique) half-edges where to_flip is True in a half-edge mesh. Wraps flip_edge."""
    def scan_fun(h, e): # flips edge e if its length < 0 and edge is unique. Otherwise, you undo your flips!
        return jax.lax.cond(to_flip[e] & hemesh.is_unique[e],
                            lambda hh: flip_edge(hh, e), lambda hh: hh, h), None
    flipped_hemesh, _ = jax.lax.scan(scan_fun, init=hemesh, xs=jnp.arange(hemesh.n_hes) )
    return flipped_hemesh

# %% ../nbs/04_topological_modifications.ipynb #d2df40a4
def remap_inds_removal_forward(N: int, removed: Int[jax.Array, " n_removed"]) -> Int[jax.Array, " N"]:
    """Remap indices after removal. Returns array arr[i] = i - (removed < i).sum()."""
    remap = jnp.arange(N)
    return remap - jnp.searchsorted(jnp.sort(removed), remap, side='left')  # left


def remap_inds_removal_reverse(N: int, removed: Int[jax.Array, " n_removed"]) -> Int[jax.Array, " N-n_removed"]:
    """Remap indices after removal. Reverse of remap_inds_removal_forward."""
    remap = jnp.arange(N)
    return jnp.delete(remap, removed, assume_unique_indices=True)


# %% ../nbs/04_topological_modifications.ipynb #05455739
@jax.tree_util.register_dataclass
@dataclasses.dataclass(frozen=True)
class MeshReindexMap:
    """Old↔new index maps produced by topology-changing operations."""
    v_forward: Int[jax.Array, " n_vertices_old"]
    v_reverse: Int[jax.Array, " n_vertices_new"]
    f_forward: Int[jax.Array, " n_faces_old"]
    f_reverse: Int[jax.Array, " n_faces_new"]
    he_forward: Int[jax.Array, " n_hes_old"]
    he_reverse: Int[jax.Array, " n_hes_new"]
    info: dict[str, Any] = dataclasses.field(default_factory=dict, metadata=dict(static=True))


# %% ../nbs/04_topological_modifications.ipynb #67afc0b1
@functools.partial(jax.jit, static_argnames=['check_boundary']) 
def collapse_edge(hemesh: HeMesh, e: int, check_boundary=False
                  ) -> tuple[HeMesh, MeshReindexMap]:
    """
    Collapse half-edge e in a half-edge mesh. Keeps the origin vertex of e.
        
    Returns a new HeMesh (does not modify in-place), and three arrays for remapping
    vertex, half-edge, and face indices from the original mesh to the new mesh.

    JIT-compatible, but calling with different numbers of vertices/edges/faces will cause recompilation.
    """

    if check_boundary:
        assert not hemesh.is_bdry_edge[e] and not hemesh.is_inf_he[e], "Interior edges only"

    # identify relevant elements
    t = hemesh.twin[e]

    # make sure there’s no vertex references to e or twin
    incident = hemesh.incident.at[jnp.array([hemesh.orig[e], # v1 
                                             hemesh.orig[hemesh.prv[e]], # v2
                                             hemesh.orig[hemesh.prv[t]]])].set( # v4
                                  jnp.array([hemesh.twin[hemesh.prv[e]],
                                             hemesh.twin[hemesh.nxt[e]],
                                             hemesh.twin[hemesh.nxt[t]]]))
    # re-twin the half-edges
    twin = hemesh.twin
    twin = hemesh.twin.at[jnp.array([hemesh.twin[hemesh.prv[e]],
                                     hemesh.twin[hemesh.nxt[e]], 
                                     hemesh.twin[hemesh.prv[t]],
                                     hemesh.twin[hemesh.nxt[t]]])].set( 
                          jnp.array([hemesh.twin[hemesh.nxt[e]],
                                     hemesh.twin[hemesh.prv[e]],
                                     hemesh.twin[hemesh.nxt[t]],
                                     hemesh.twin[hemesh.prv[t]]]))
    # edit orign and dest for all hes in/out of v3
    orig = jnp.where(hemesh.orig==hemesh.dest[e], hemesh.orig[e], hemesh.orig)
    dest = jnp.where(hemesh.dest==hemesh.dest[e], hemesh.orig[e], hemesh.dest)

    # delete the elements
    v_delete = jnp.array([hemesh.dest[e]])
    hes_delete = jnp.array([e, hemesh.nxt[e], hemesh.prv[e],
                            t, hemesh.nxt[t], hemesh.prv[t]])
    fs_delete =  jnp.array([hemesh.heface[e], hemesh.heface[t]])
    incident = jnp.delete(incident, v_delete, assume_unique_indices=True)
    face_incident = jnp.delete(hemesh.face_incident, fs_delete, assume_unique_indices=True)
    
    def delete_he(arr): return jnp.delete(arr, hes_delete, assume_unique_indices=True)
    orig, dest = (delete_he(orig), delete_he(dest))
    twin = delete_he(twin)
    nxt, prv = (delete_he(hemesh.nxt), delete_he(hemesh.prv))
    heface = delete_he(hemesh.heface)

    # index remapping: identity for v < hemesh.dest[e], v-> v-1 for
    remap_v = remap_inds_removal_forward(hemesh.n_vertices, v_delete)
    remap_he = remap_inds_removal_forward(hemesh.n_hes, hes_delete)  
    remap_f = remap_inds_removal_forward(hemesh.n_faces, fs_delete)

    index_map = MeshReindexMap(v_forward=remap_v,
                               v_reverse=remap_inds_removal_reverse(hemesh.n_vertices, v_delete),
                               f_forward=remap_f,
                               f_reverse=remap_inds_removal_reverse(hemesh.n_faces, fs_delete),
                               he_forward=remap_he,
                               he_reverse=remap_inds_removal_reverse(hemesh.n_hes, hes_delete),
                               info={"operation": "collapse_edge", "collapsed_edge": e})
    
    inf_vertices = tuple(int(remap_v[v]) for v in hemesh.inf_vertices)

    # special case: boundary hes need "-1" face
    heface = remap_f[heface]
    is_bdry_he = jnp.delete(hemesh.heface == -1, hes_delete, assume_unique_indices=True)
    heface = jnp.where(is_bdry_he, -1, heface)

    new_hemesh = HeMesh(incident=remap_he[incident], orig=remap_v[orig], dest=remap_v[dest],
                        twin=remap_he[twin], nxt=remap_he[nxt], prv=remap_he[prv],
                        heface=heface, face_incident=remap_he[face_incident], inf_vertices=inf_vertices)

    return new_hemesh, index_map

# %% ../nbs/04_topological_modifications.ipynb #8a3a4335
def split_vertex(hemesh: HeMesh, e1: int, e2: int, check_args: bool=False) -> tuple[HeMesh, MeshReindexMap]:
    """
    Split a vertex into two along a "splitting axis" given by two half-edges whose originating at that vertex.
    
    New vertex inserted at origin of e2. The new vertex will be the final one in the array.

    This function is not JIT-compatible, since it depends on iterating around the vertex to update origins/destinations.
    """
    if check_args:
        assert hemesh.orig[e1]==hemesh.orig[e2] and not hemesh.heface[e1]==-1 and not hemesh.heface[e2]==-1, "invalid half edges"

    # create 1 new vertex, 6 new half-edges, and 2 new faces. By convention, at the end of the arrays
    incident = jnp.pad(hemesh.incident, (0, 1))
    face_incident = jnp.pad(hemesh.face_incident, (0, 2))
    orig, dest, twin, nxt, prv, heface = [jnp.pad(arr, (0, 6))
                                         for arr in [hemesh.orig, hemesh.dest, hemesh.twin, hemesh.nxt, hemesh.prv, hemesh.heface]]
    face_incident = jnp.pad(hemesh.face_incident, (0, 2))

    # the new elements are appended at the end
    vnew = hemesh.n_vertices
    fnew_1, fnew_2 = hemesh.n_faces, hemesh.n_faces+1 # faces of triangle of twin[e1] and triangle of twin[e2]
    enew_1, enew_2, enew_3 = hemesh.n_hes, hemesh.n_hes+1, hemesh.n_hes+2 # fnew_1, enew_1 is twin[e1]
    enew_4, enew_5, enew_6 = hemesh.n_hes+3, hemesh.n_hes+4, hemesh.n_hes+5 # fnew_2, enew_4 is twin[e2]

    # set incidents for new mesh elements
    incident = incident.at[vnew].set(e2)
    heface = heface.at[jnp.array([enew_1, enew_2, enew_3])].set(fnew_1)
    heface = heface.at[jnp.array([enew_4, enew_5, enew_6])].set(fnew_2)
    face_incident = face_incident.at[jnp.array([fnew_1, fnew_2])].set(jnp.array([enew_1, enew_4]))

    # origin and destination of new half-edges
    orig = orig.at[jnp.array([enew_1, enew_2, enew_3])].set(jnp.array([hemesh.dest[e1], hemesh.orig[e1], vnew]))
    orig = orig.at[jnp.array([enew_4, enew_5, enew_6])].set(jnp.array([hemesh.dest[e2], vnew, hemesh.orig[e1]]))
    dest = dest.at[jnp.array([enew_1, enew_2, enew_3])].set(jnp.array([hemesh.orig[e1], vnew, hemesh.dest[e1]]))
    dest = dest.at[jnp.array([enew_4, enew_5, enew_6])].set(jnp.array([vnew, hemesh.orig[e1], hemesh.dest[e2]]))
    
    # nxt, prv, twin of new half-edges
    nxt = nxt.at[jnp.array([enew_1, enew_2, enew_3])].set(jnp.array([enew_2, enew_3, enew_1]))
    nxt = nxt.at[jnp.array([enew_4, enew_5, enew_6])].set(jnp.array([enew_5, enew_6, enew_4]))
    prv = prv.at[jnp.array([enew_1, enew_2, enew_3])].set(jnp.array([enew_3, enew_1, enew_2]))
    prv = prv.at[jnp.array([enew_4, enew_5, enew_6])].set(jnp.array([enew_6, enew_4, enew_5]))
    
    twin = twin.at[jnp.array([enew_1, enew_2, enew_3])].set(jnp.array([e1, enew_5, hemesh.twin[e1]]))
    twin = twin.at[jnp.array([enew_4, enew_5, enew_6])].set(jnp.array([e2, enew_2, hemesh.twin[e2]]))
    twin = twin.at[jnp.array([e1, e2])].set(jnp.array([enew_1, enew_4]))
    twin = twin.at[jnp.array([hemesh.twin[e1], hemesh.twin[e2]])].set(jnp.array([enew_3, enew_6]))

    # finally, need to update the origin and destination of half-edges into the "split" vertex.
    # iterate around the vertex from e2 to e1 to get the ones we need to update
    outgoing = [e2]
    while True:
        next_edge = hemesh.twin[hemesh.prv[outgoing[-1]]]
        if next_edge == e1:
            break
        outgoing.append(next_edge)
    outgoing = jnp.array(outgoing)
    orig = orig.at[outgoing].set(vnew)
    dest = dest.at[hemesh.prv[outgoing]].set(vnew)

    # no need to update the indices, since we appended the mesh elements at the very end
    new_hemesh = HeMesh(incident=incident, orig=orig, dest=dest, twin=twin, nxt=nxt, prv=prv,
                        heface=heface, face_incident=face_incident, inf_vertices=hemesh.inf_vertices)
    
    # need to find the "parents" of the new mesh elements
    v_reverse = jnp.arange(hemesh.n_vertices+1).at[vnew].set(hemesh.orig[e1])
    f_reverse = jnp.arange(hemesh.n_faces+2).at[jnp.array([fnew_1, fnew_2])].set(
                                                jnp.array([hemesh.heface[e1], hemesh.heface[e2]]))
    he_reverse = jnp.arange(hemesh.n_vertices+1).at[jnp.array([enew_1, enew_2, enew_3])].set(
                                                    jnp.array([e1, e1, hemesh.twin[e1]]))
    he_reverse = jnp.arange(hemesh.n_vertices+1).at[jnp.array([enew_4, enew_5, enew_6])].set(
                                                    jnp.array([e2, e2, hemesh.twin[e2]]))
    index_map = MeshReindexMap(v_forward=jnp.arange(hemesh.n_vertices),
                               v_reverse=v_reverse,
                               f_forward=jnp.arange(hemesh.n_faces),
                               f_reverse=f_reverse,
                               he_forward=jnp.arange(hemesh.n_hes),
                               he_reverse=he_reverse,
                               info={"operation": "split_vertex", "split_edges": (e1, e2), "new_vertex": vnew})

    return new_hemesh, index_map
