# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_linear_operators_on_meshes.ipynb.

# %% auto #0
__all__ = ['average_vertices_to_faces', 'average_faces_to_vertices', 'sum_he_to_vertex_incoming', 'sum_he_to_vertex_opposite',
           'get_cell_areas', 'get_coordination_number', 'get_triangle_areas', 'get_cell_area', 'get_cell_perimeter',
           'compute_cotan_laplace', 'cotan_laplace_sparse', 'compute_gradient_2d', 'compute_gradient_3d',
           'scipy_to_bcoo', 'diag_jsparse', 'linear_op_to_sparse']

# %% ../nbs/04_linear_operators_on_meshes.ipynb #d159edd4-4456-41f8-b520-8b1b69219c67
import numpy as np
import igl

# %% ../nbs/04_linear_operators_on_meshes.ipynb #9f1cb15c-86cd-4e64-8f21-d4726216cd2f
import jax
import jax.numpy as jnp
import jax.experimental.sparse as jsparse

import lineax

import functools

# %% ../nbs/04_linear_operators_on_meshes.ipynb #723a50d1-f5c2-435c-9026-39b6067f426d
from jaxtyping import Float 

# %% ../nbs/04_linear_operators_on_meshes.ipynb #cef3ff0a
from . import trigonometry as trig
from .triangular import TriMesh
from . import mesh as msh

# %% ../nbs/04_linear_operators_on_meshes.ipynb #34c17710
## averaging from faces to vertices, and vice versa. Compare igl.average_onto_faces and igl.average_onto_vertices

def average_vertices_to_faces(hemesh: msh.HeMesh,
                              vertex_field: Float[jax.Array, "n_vertices ..."],
                              ) -> Float[jax.Array, "n_faces ..."]:
    """Average per-vertex field onto faces (uniform weights)."""
    faces = hemesh.faces
    return jnp.mean(vertex_field[faces], axis=1)


def average_faces_to_vertices(hemesh: msh.HeMesh,
                              vertices: Float[jax.Array, "n_vertices dim"],
                              face_field: Float[jax.Array, "n_faces ..."],
                              ) -> Float[jax.Array, "n_vertices ..."]:
    """Average per-face field onto vertices, weighted by triangle area."""
    faces = hemesh.faces
    v0, v1, v2 = (vertices[faces[:, 0]], vertices[faces[:, 1]], vertices[faces[:, 2]])
    areas = jax.vmap(trig.get_triangle_area)(v0, v1, v2)

    weighted = face_field * areas.reshape((hemesh.n_faces,) + (1,) * (face_field.ndim - 1))
    weighted_faces = jnp.broadcast_to(weighted[:, None, ...], faces.shape + face_field.shape[1:])
    area_faces = jnp.broadcast_to(areas[:, None], faces.shape)

    out_shape = (hemesh.n_vertices,) + face_field.shape[1:]
    v_field = jnp.zeros(out_shape, dtype=face_field.dtype)
    v_area = jnp.zeros((hemesh.n_vertices,), dtype=areas.dtype)

    v_field = v_field.at[faces].add(weighted_faces)
    v_area = v_area.at[faces].add(area_faces)

    denom_shape = (hemesh.n_vertices,) + (1,) * (face_field.ndim - 1)
    return v_field / jnp.clip(jnp.reshape(v_area, denom_shape), 1e-12)

# %% ../nbs/04_linear_operators_on_meshes.ipynb #a6feb2c8-b107-47c7-ac47-6629a29299a0
def sum_he_to_vertex_incoming(hemesh: msh.HeMesh, he_field: Float[jax.Array, "n_hes ..."]
                              ) -> Float[jax.Array, "n_vertices ..."]:
    """
    Sum a half-edge field onto destination vertices.

    hemesh: connectivity information
    he_field: (n_hes,) or (n_hes, d) array
    """
    out_shape = (hemesh.n_vertices,) + he_field.shape[1:]  # supports scalar or vector fields
    v_field = jnp.zeros(out_shape, dtype=he_field.dtype)
    # Scatter-add: for each half-edge h, add he_field[h] to v_field[dest[h]]
    return v_field.at[hemesh.dest].add(he_field)

def sum_he_to_vertex_opposite(hemesh: msh.HeMesh, he_field: Float[jax.Array, "n_hes ..."]
                              ) -> Float[jax.Array, "n_vertices ..."]:
    """
    Sum a half-edge field onto opposite vertices.

    Attention: can include boundary half-edges!

    hemesh: connectivity information
    he_field: (n_hes,) or (n_hes, d) array
    """
    out_shape = (hemesh.n_vertices,) + he_field.shape[1:]  # supports scalar or vector fields
    v_field = jnp.zeros(out_shape, dtype=he_field.dtype)
    return v_field.at[hemesh.dest[hemesh.nxt]].add(he_field)


# %% ../nbs/04_linear_operators_on_meshes.ipynb #fbebd977-9ea6-4ab9-8188-d833f1bbba60
def get_cell_areas(geommesh: msh.GeomMesh, hemesh: msh.HeMesh) -> Float[jax.Array, " n_vertices"]:
    """
    Compute areas of cells by mesh traversal (don't use for simulation, inefficient).

    Boundary vertices get area 0.
    """
    areas = np.zeros(hemesh.n_vertices)
    bdry = hemesh.is_bdry
    for v in range(hemesh.n_vertices):
        if bdry[v]:
            areas[v] = 0
        else:
            adjacent_faces = hemesh.heface[hemesh.iterate_around_vertex(v)]
            polygon = geommesh.face_positions[adjacent_faces]
            areas[v] = trig.get_polygon_area(polygon)
    return jnp.array(areas)

# %% ../nbs/04_linear_operators_on_meshes.ipynb #11d2d113
def get_coordination_number(hemesh: msh.HeMesh) -> Float[jax.Array, " n_vertices"]:
    return sum_he_to_vertex_incoming(hemesh, jnp.ones(hemesh.n_hes))

# %% ../nbs/04_linear_operators_on_meshes.ipynb #f63fe4a4
def get_triangle_areas(vertices: Float[jax.Array, "n_vertices dim"], hemesh: msh.HeMesh) ->Float[jax.Array, " n_faces"]:
    """Compute (unsigned) triangle areas in a mesh."""
    return jax.vmap(trig.get_triangle_area)(*vertices[hemesh.faces.T])

def get_cell_area(vertices: Float[jax.Array, "n_vertices dim"], hemesh: msh.HeMesh) ->Float[jax.Array, " n_vertices"]:
    """Compute Voronoi area for each vertex."""
    a = hemesh.dest[hemesh.nxt]
    b = hemesh.dest[hemesh.prv]
    c = hemesh.dest
    corner_areas = jax.vmap(trig.get_voronoi_corner_area)(
        vertices[a], vertices[b], vertices[c])
    corner_areas = jnp.where(hemesh.is_bdry_he, 0, corner_areas)
    cell_areas = msh.sum_he_to_vertex_opposite(hemesh, corner_areas)
    return cell_areas

def get_cell_perimeter(vertices: Float[jax.Array, "n_vertices dim"], hemesh: msh.HeMesh) -> Float[jax.Array, " n_vertices"]:
    """Compute Voronoi perimeters for each vertex."""
    a = hemesh.dest[hemesh.nxt]
    b = hemesh.dest[hemesh.prv]
    c = hemesh.dest
    corner_perims = jax.vmap(trig.get_voronoi_corner_perimeter)(
        vertices[a], vertices[b], vertices[c])
    corner_perims = jnp.where(hemesh.is_bdry_he, 0, corner_perims)
    cell_perims = msh.sum_he_to_vertex_opposite(hemesh, corner_perims)
    return cell_perims

# %% ../nbs/04_linear_operators_on_meshes.ipynb #66b2e04f
def compute_cotan_laplace(hemesh: msh.HeMesh, vertices: Float[jax.Array, "n_vertices dim"],
                          vertex_field: Float[jax.Array, "n_vertices ..."]
                          ) -> Float[jax.Array, "n_vertices ..."]:
    """
    Compute cotangent laplacian of a per-vertex field (natural boundary conditions).
    """
    v_orig = vertices[hemesh.orig]
    v_dest = vertices[hemesh.dest]
    v_opp = vertices[hemesh.dest[hemesh.nxt]]

    cot = jax.vmap(trig.get_cot_between_vectors)(v_orig - v_opp, v_dest - v_opp)
    cot = jnp.where(hemesh.is_bdry_he, 0.0, cot)
    w_edge = 0.5 * (cot + cot[hemesh.twin])

    diff = vertex_field[hemesh.dest] - vertex_field[hemesh.orig]
    w_shape = (hemesh.n_hes,) + (1,) * (vertex_field.ndim - 1)
    weighted_diff = jnp.reshape(w_edge, w_shape) * diff

    out_shape = (hemesh.n_vertices,) + vertex_field.shape[1:]
    lap = jnp.zeros(out_shape, dtype=vertex_field.dtype)
    return lap.at[hemesh.orig].add(weighted_diff)

# %% ../nbs/04_linear_operators_on_meshes.ipynb #b9c6f5cc
def cotan_laplace_sparse(hemesh: msh.HeMesh,
                         vertices: Float[jax.Array, "n_vertices dim"],
                         ) -> jsparse.BCOO:
    """Assemble cotangent Laplacian as a sparse matrix (BCOO)."""
    v_orig = vertices[hemesh.orig]
    v_dest = vertices[hemesh.dest]
    v_opp = vertices[hemesh.dest[hemesh.nxt]]

    cot = jax.vmap(trig.get_cot_between_vectors)(v_orig - v_opp, v_dest - v_opp)
    cot = jnp.where(hemesh.is_bdry_he, 0.0, cot)

    w_edge = 0.5 * (cot + cot[hemesh.twin])
    unique = hemesh.is_unique

    i = hemesh.orig[unique]
    j = hemesh.dest[unique]
    w = w_edge[unique]

    rows = jnp.concatenate([i, j, i, j])
    cols = jnp.concatenate([j, i, i, j])
    data = jnp.concatenate([w, w, -w, -w])

    mat = jsparse.BCOO((data, jnp.stack([rows, cols], axis=1)),
                       shape=(hemesh.n_vertices, hemesh.n_vertices))
    return mat.sum_duplicates()

# %% ../nbs/04_linear_operators_on_meshes.ipynb #e2587568
def compute_gradient_2d(hemesh: msh.HeMesh, vertices: Float[jax.Array, "n_vertices 2"],
                        vertex_field: Float[jax.Array, "n_vertices ..."]
                        ) -> Float[jax.Array, "n_faces 2 ..."]:
    """Compute the linear finite-element gradient (constant per face)."""
    faces = hemesh.faces
    v0, v1, v2 = (vertices[faces[:, 0]], vertices[faces[:, 1]], vertices[faces[:, 2]])

    area2 = jnp.cross(v1 - v0, v2 - v0)
    area2_safe = jnp.where(jnp.abs(area2) > 1e-12, area2, 1.0)

    grad_phi0 = trig.get_perp_2d(v1 - v2) / area2_safe[:, None]
    grad_phi1 = trig.get_perp_2d(v2 - v0) / area2_safe[:, None]
    grad_phi2 = trig.get_perp_2d(v0 - v1) / area2_safe[:, None]

    mask = (jnp.abs(area2) > 1e-12)[:, None]
    grad_phi0 = grad_phi0 * mask
    grad_phi1 = grad_phi1 * mask
    grad_phi2 = grad_phi2 * mask

    grads = jnp.stack([grad_phi0, grad_phi1, grad_phi2], axis=1)
    vals = vertex_field[faces]
    return jnp.einsum("fvd,fv...->fd...", grads, vals)


def compute_gradient_3d(hemesh: msh.HeMesh, vertices: Float[jax.Array, "n_vertices 3"],
                        vertex_field: Float[jax.Array, "n_vertices ..."]
                        ) -> Float[jax.Array, "n_faces 3 ..."]:
    """Compute the linear finite-element gradient (constant per face)."""
    faces = hemesh.faces
    v0, v1, v2 = (vertices[faces[:, 0]], vertices[faces[:, 1]], vertices[faces[:, 2]])

    n = jnp.cross(v1 - v0, v2 - v0)
    area2 = jnp.linalg.norm(n, axis=-1)
    area2_sq_safe = jnp.where(area2 > 1e-12, area2**2, 1.0)
    grad_phi0 = jnp.cross(v1 - v2, n) / area2_sq_safe[:, None]
    grad_phi1 = jnp.cross(v2 - v0, n) / area2_sq_safe[:, None]
    grad_phi2 = jnp.cross(v0 - v1, n) / area2_sq_safe[:, None]

    mask = (area2 > 1e-12)[:, None]
    grad_phi0 = grad_phi0 * mask
    grad_phi1 = grad_phi1 * mask
    grad_phi2 = grad_phi2 * mask

    grads = jnp.stack([grad_phi0, grad_phi1, grad_phi2], axis=1)
    vals = vertex_field[faces]
    return jnp.einsum("fvd,fv...->fd...", grads, vals)

# %% ../nbs/04_linear_operators_on_meshes.ipynb #16986532
def scipy_to_bcoo(A) -> jsparse.BCOO:
    """
    Convert a SciPy sparse matrix (CSC or CSR) to a JAX BCOO sparse matrix
    without converting to dense.

    Parameters
    ----------
    A : scipy.sparse.spmatrix
        Input sparse matrix (CSR or CSC recommended)

    Returns
    -------
    B : jax.experimental.sparse.BCOO
        Equivalent JAX sparse matrix
    """
    # Convert to COO
    Acoo = A.tocoo()

    # COO format gives us row, col, data arrays directly
    rows = jnp.array(Acoo.row, dtype=jnp.int32)
    cols = jnp.array(Acoo.col, dtype=jnp.int32)
    data = jnp.array(Acoo.data)
    return jsparse.BCOO((data, jnp.stack([rows, cols], axis=1)), shape=Acoo.shape)


def diag_jsparse(v : Float[jax.Array, " N"], k: int =0) -> jsparse.BCOO:
    """Construct a diagonal jax.sparse array. Plugin replacement for np.diag"""
    N  = v.shape[0] + jnp.abs(k)
    if k >=0:
        row_inds = jnp.arange(k, N, dtype=jnp.int32)
    else:
        row_inds = jnp.arange(0, N+k, dtype=jnp.int32)
    return jsparse.BCOO((v, jnp.stack([row_inds-k, row_inds,], axis=1)), shape=(N, N))



# %% ../nbs/04_linear_operators_on_meshes.ipynb #3d9366df
def linear_op_to_sparse(op: callable,
                        in_shape: tuple[int, ...],
                        out_shape: tuple[int, ...],
                        dtype: jnp.dtype | None = None,
                        chunk_size: int = 256,
                        tol: float = 0.0,
                        ) -> jsparse.BCOO:
    """Build a sparse matrix for a linear map using batched one-hot probes.

    Note: this function is general, but not necessarily very efficient for large matrix sizes.
    """
    if len(in_shape) != 1 or len(out_shape) != 1:
        raise ValueError("Only 1D input/output supported for now.")
    n_in = in_shape[0]
    n_out = out_shape[0]
    if dtype is None:
        dtype = jnp.result_type(op(jnp.zeros((n_in,))))

    data_list: list[np.ndarray] = []
    row_list: list[np.ndarray] = []
    col_list: list[np.ndarray] = []

    for start in range(0, n_in, chunk_size):
        end = min(start + chunk_size, n_in)
        idx = jnp.arange(start, end, dtype=jnp.int64)
        basis = jax.nn.one_hot(jnp.array(idx), n_in, dtype=dtype)
        cols = jax.vmap(op)(basis)  # (chunk, n_out)
        #cols = apply_op(basis)
        mask = jnp.abs(cols) > tol
        col_in_batch, row_out = jnp.nonzero(mask)
        if col_in_batch.size == 0:
            continue

        data_list.append(cols[col_in_batch, row_out])
        row_list.append(row_out)
        col_list.append(idx[col_in_batch])

    if len(data_list) == 0:
        return jsparse.empty((n_out, n_in)) 
    data = jnp.concatenate(data_list)
    rows = jnp.concatenate(row_list)
    cols = jnp.concatenate(col_list)
    indices = jnp.stack([jnp.array(rows, dtype=jnp.int32),
                            jnp.array(cols, dtype=jnp.int32)], axis=1)
    return jsparse.BCOO((data, indices), shape=(n_out, n_in))
