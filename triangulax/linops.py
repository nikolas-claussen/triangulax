# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_linear_operators_on_meshes.ipynb.

# %% auto #0
__all__ = ['average_vertices_to_faces', 'average_faces_to_vertices', 'sum_he_to_vertex_incoming', 'sum_he_to_vertex_opposite',
           'get_cell_areas', 'get_coordination_number', 'compute_cotan_laplace', 'compute_gradient_2d',
           'compute_gradient_3d', 'linear_op_to_sparse']

# %% ../nbs/04_linear_operators_on_meshes.ipynb #d159edd4-4456-41f8-b520-8b1b69219c67
import numpy as np
import igl

# %% ../nbs/04_linear_operators_on_meshes.ipynb #9f1cb15c-86cd-4e64-8f21-d4726216cd2f
import jax
import jax.numpy as jnp
import jax.experimental.sparse as jsparse

import lineax

import functools

# %% ../nbs/04_linear_operators_on_meshes.ipynb #723a50d1-f5c2-435c-9026-39b6067f426d
from jaxtyping import Float 

# %% ../nbs/04_linear_operators_on_meshes.ipynb #cef3ff0a
from . import trigonometry as trig
from .triangular import TriMesh
from . import mesh as msh

# %% ../nbs/04_linear_operators_on_meshes.ipynb #34c17710
## averaging from faces to vertices, and vice versa. Compare igl.average_onto_faces and igl.average_onto_vertices

def average_vertices_to_faces(hemesh: msh.HeMesh,
                              vertex_field: Float[jax.Array, "n_vertices ..."],
                              ) -> Float[jax.Array, "n_faces ..."]:
    """Average per-vertex field onto faces (uniform weights)."""
    faces = hemesh.faces
    return jnp.mean(vertex_field[faces], axis=1)


def average_faces_to_vertices(hemesh: msh.HeMesh,
                              vertices: Float[jax.Array, "n_vertices dim"],
                              face_field: Float[jax.Array, "n_faces ..."],
                              ) -> Float[jax.Array, "n_vertices ..."]:
    """Average per-face field onto vertices, weighted by triangle area."""
    faces = hemesh.faces
    v0, v1, v2 = (vertices[faces[:, 0]], vertices[faces[:, 1]], vertices[faces[:, 2]])
    areas = jax.vmap(trig.get_triangle_area)(v0, v1, v2)

    weighted = face_field * areas.reshape((hemesh.n_faces,) + (1,) * (face_field.ndim - 1))
    weighted_faces = jnp.broadcast_to(weighted[:, None, ...], faces.shape + face_field.shape[1:])
    area_faces = jnp.broadcast_to(areas[:, None], faces.shape)

    out_shape = (hemesh.n_vertices,) + face_field.shape[1:]
    v_field = jnp.zeros(out_shape, dtype=face_field.dtype)
    v_area = jnp.zeros((hemesh.n_vertices,), dtype=areas.dtype)

    v_field = v_field.at[faces].add(weighted_faces)
    v_area = v_area.at[faces].add(area_faces)

    denom_shape = (hemesh.n_vertices,) + (1,) * (face_field.ndim - 1)
    return v_field / jnp.clip(jnp.reshape(v_area, denom_shape), 1e-12)

# %% ../nbs/04_linear_operators_on_meshes.ipynb #a6feb2c8-b107-47c7-ac47-6629a29299a0
def sum_he_to_vertex_incoming(hemesh: msh.HeMesh, he_field: Float[jax.Array, "n_hes ..."]
                              ) -> Float[jax.Array, "n_vertices ..."]:
    """
    Sum a half-edge field onto destination vertices.

    hemesh: connectivity information
    he_field: (n_hes,) or (n_hes, d) array
    """
    out_shape = (hemesh.n_vertices,) + he_field.shape[1:]  # supports scalar or vector fields
    v_field = jnp.zeros(out_shape, dtype=he_field.dtype)
    # Scatter-add: for each half-edge h, add he_field[h] to v_field[dest[h]]
    return v_field.at[hemesh.dest].add(he_field)

def sum_he_to_vertex_opposite(hemesh: msh.HeMesh, he_field: Float[jax.Array, "n_hes ..."]
                              ) -> Float[jax.Array, "n_vertices ..."]:
    """
    Sum a half-edge field onto opposite vertices.

    Attention: can include boundary half-edges!

    hemesh: connectivity information
    he_field: (n_hes,) or (n_hes, d) array
    """
    out_shape = (hemesh.n_vertices,) + he_field.shape[1:]  # supports scalar or vector fields
    v_field = jnp.zeros(out_shape, dtype=he_field.dtype)
    return v_field.at[hemesh.dest[hemesh.nxt]].add(he_field)


# %% ../nbs/04_linear_operators_on_meshes.ipynb #fbebd977-9ea6-4ab9-8188-d833f1bbba60
def get_cell_areas(geommesh: msh.GeomMesh, hemesh: msh.HeMesh) -> Float[jax.Array, " n_vertices"]:
    """
    Compute areas of cells by mesh traversal (don't use for simulation, inefficient).

    Boundary vertices get area 0.
    """
    areas = np.zeros(hemesh.n_vertices)
    bdry = hemesh.is_bdry
    for v in range(hemesh.n_vertices):
        if bdry[v]:
            areas[v] = 0
        else:
            adjacent_faces = hemesh.heface[hemesh.iterate_around_vertex(v)]
            polygon = geommesh.face_positions[adjacent_faces]
            areas[v] = trig.get_polygon_area(polygon)
    return jnp.array(areas)

# %% ../nbs/04_linear_operators_on_meshes.ipynb #11d2d113
def get_coordination_number(hemesh: msh.HeMesh) -> Float[jax.Array, " n_vertices"]:
    return sum_he_to_vertex_incoming(hemesh, jnp.ones(hemesh.n_hes))

# %% ../nbs/04_linear_operators_on_meshes.ipynb #66b2e04f
def compute_cotan_laplace(hemesh: msh.HeMesh, vertices: Float[jax.Array, "n_vertices dim"],
                          vertex_field: Float[jax.Array, "n_vertices ..."]
                          ) -> Float[jax.Array, "n_vertices ..."]:
    """
    Compute cotangent laplacian of a per-vertex field (natural boundary conditions).
    """
    v_orig = vertices[hemesh.orig]
    v_dest = vertices[hemesh.dest]
    v_opp = vertices[hemesh.dest[hemesh.nxt]]

    vec1 = v_orig - v_opp
    vec2 = v_dest - v_opp
    cot = jax.vmap(trig.get_cot_between_vectors)(vec1, vec2)
    cot = jnp.where(hemesh.heface == -1, 0.0, cot)

    cot_sum = cot + cot[hemesh.twin]
    w_edge = 0.5 * cot_sum

    diff = vertex_field[hemesh.dest] - vertex_field[hemesh.orig]
    w_shape = (hemesh.n_hes,) + (1,) * (vertex_field.ndim - 1)
    weighted_diff = jnp.reshape(w_edge, w_shape) * diff

    out_shape = (hemesh.n_vertices,) + vertex_field.shape[1:]
    lap = jnp.zeros(out_shape, dtype=vertex_field.dtype)
    return lap.at[hemesh.orig].add(weighted_diff)

# %% ../nbs/04_linear_operators_on_meshes.ipynb #e2587568
def compute_gradient_2d(hemesh: msh.HeMesh, vertices: Float[jax.Array, "n_vertices 2"],
                        vertex_field: Float[jax.Array, "n_vertices ..."]
                        ) -> Float[jax.Array, "n_faces 2 ..."]:
    """Compute the linear finite-element gradient (constant per face)."""
    faces = hemesh.faces
    v0, v1, v2 = (vertices[faces[:, 0]], vertices[faces[:, 1]], vertices[faces[:, 2]])

    area2 = jnp.cross(v1 - v0, v2 - v0)
    area2_safe = jnp.where(jnp.abs(area2) > 1e-12, area2, 1.0)

    grad_phi0 = trig.get_perp_2d(v1 - v2) / area2_safe[:, None]
    grad_phi1 = trig.get_perp_2d(v2 - v0) / area2_safe[:, None]
    grad_phi2 = trig.get_perp_2d(v0 - v1) / area2_safe[:, None]

    mask = (jnp.abs(area2) > 1e-12)[:, None]
    grad_phi0 = grad_phi0 * mask
    grad_phi1 = grad_phi1 * mask
    grad_phi2 = grad_phi2 * mask

    grads = jnp.stack([grad_phi0, grad_phi1, grad_phi2], axis=1)
    vals = vertex_field[faces]
    return jnp.einsum("fvd,fv...->fd...", grads, vals)


def compute_gradient_3d(hemesh: msh.HeMesh, vertices: Float[jax.Array, "n_vertices 3"],
                        vertex_field: Float[jax.Array, "n_vertices ..."]
                        ) -> Float[jax.Array, "n_faces 3 ..."]:
    """Compute the linear finite-element gradient (constant per face)."""
    faces = hemesh.faces
    v0, v1, v2 = (vertices[faces[:, 0]], vertices[faces[:, 1]], vertices[faces[:, 2]])

    n = jnp.cross(v1 - v0, v2 - v0)
    area2 = jnp.linalg.norm(n, axis=-1)
    area2_sq_safe = jnp.where(area2 > 1e-12, area2**2, 1.0)
    grad_phi0 = jnp.cross(v1 - v2, n) / area2_sq_safe[:, None]
    grad_phi1 = jnp.cross(v2 - v0, n) / area2_sq_safe[:, None]
    grad_phi2 = jnp.cross(v0 - v1, n) / area2_sq_safe[:, None]

    mask = (area2 > 1e-12)[:, None]
    grad_phi0 = grad_phi0 * mask
    grad_phi1 = grad_phi1 * mask
    grad_phi2 = grad_phi2 * mask

    grads = jnp.stack([grad_phi0, grad_phi1, grad_phi2], axis=1)
    vals = vertex_field[faces]
    return jnp.einsum("fvd,fv...->fd...", grads, vals)

# %% ../nbs/04_linear_operators_on_meshes.ipynb #3d9366df
def linear_op_to_sparse(op: callable,
                        in_shape: tuple[int, ...],
                        out_shape: tuple[int, ...],
                        dtype: jnp.dtype | None = None,
                        chunk_size: int = 64,
                        ) -> jsparse.BCOO:
    """Build a sparse matrix for a linear map using batched one-hot probes."""
    if len(in_shape) != 1 or len(out_shape) != 1:
        raise ValueError("Only 1D input/output supported for now.")
    n_in = in_shape[0]
    n_out = out_shape[0]
    if dtype is None:
        dtype = jnp.result_type(op(jnp.zeros((n_in,))))

    n_chunks = (n_in + chunk_size - 1) // chunk_size

    def scan_fun(carry, chunk_idx):
        start = chunk_idx * chunk_size
        idx = start + jnp.arange(chunk_size)
        valid = idx < n_in
        idx_safe = jnp.where(valid, idx, 0)

        basis = jax.nn.one_hot(idx_safe, n_in, dtype=dtype)
        cols = jax.vmap(op)(basis)

        cols_flat = cols.reshape(-1)
        row_idx = jnp.tile(jnp.arange(n_out), chunk_size)
        col_idx = jnp.repeat(idx_safe, n_out)
        valid_rows = jnp.repeat(valid, n_out)

        data = cols_flat * valid_rows
        indices = jnp.stack([row_idx, col_idx], axis=1)
        return carry, (data, indices)

    _, packed = jax.lax.scan(scan_fun, None, jnp.arange(n_chunks))
    data_all, indices_all = packed

    data_flat = data_all.reshape(-1)
    indices_flat = indices_all.reshape(-1, 2)
    mask = data_flat != 0

    data = data_flat[mask]
    indices = indices_flat[mask]
    return jsparse.BCOO((data, indices), shape=(n_out, n_in))
