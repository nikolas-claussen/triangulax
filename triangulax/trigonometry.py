# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_trigonometry.ipynb.

# %% auto #0
__all__ = ['get_circumcenter', 'get_oriented_triangle_area', 'get_triangle_area', 'get_polygon_area',
           'get_signed_angle_between_vectors', 'get_angle_between_vectors', 'get_cot_between_vectors',
           'get_voronoi_corner_area', 'get_rot_mat', 'get_perp_2d', 'get_triangle_normal', 'quaternion_to_rot_max',
           'get_barycentric_coordinates']

# %% ../nbs/00_trigonometry.ipynb #9f1cb15c-86cd-4e64-8f21-d4726216cd2f
import jax
import jax.numpy as jnp

import functools

import numpy as np

# %% ../nbs/00_trigonometry.ipynb #723a50d1-f5c2-435c-9026-39b6067f426d
from jaxtyping import Float

# %% ../nbs/00_trigonometry.ipynb #7f22d2ad-1ddb-4cf3-b782-ef29639cb724
## trig functions - we can use vmap to vectorize them

@functools.partial(jax.jit, static_argnames=['zero_clip'])
def get_circumcenter(a: Float[jax.Array, " dim"],
                     b: Float[jax.Array, " dim"],
                     c: Float[jax.Array, " dim"], zero_clip: float = 1e-10) -> Float[jax.Array, " dim"]:
    """Return circumcenter coordinates of triangle with vertices a, b, c"""    
    # compute using barycentric coordinates. Start by computing the edge lengths:
    la, lb, lc = (jnp.linalg.norm(b-c), jnp.linalg.norm(c-a), jnp.linalg.norm(a-b,))
    ba, bb, bc = (la**2*(lb**2+lc**2-la**2), lb**2*(lc**2+la**2-lb**2), lc**2*(la**2+lb**2-lc**2))
    u = (ba*a+bb*b+bc*c)/jnp.clip(ba+bb+bc, zero_clip)  # avoid div by zero for degenerate triangles
    return u

def get_oriented_triangle_area(a: Float[jax.Array, " dim"],
                               b: Float[jax.Array, " dim"],
                               c: Float[jax.Array, " dim"]) -> Float[jax.Array, "*"]:
    """Signed area of triangle with vertices a, b, c. If d=2, returns a scalar, if d=3, a vector."""
    return 0.5 * jnp.cross(b - a, c - a)

def get_triangle_area(a: Float[jax.Array, " dim"],
                      b: Float[jax.Array, " dim"],
                      c: Float[jax.Array, " dim"]) -> Float[jax.Array, ""]:
    """Unoriented area of triangle with vertices a, b, c. Works in dim 2 or 3."""
    return 0.5 * jnp.linalg.norm(jnp.cross(b - a, c - a))

def get_polygon_area(pts: Float[jax.Array, "n_vertices 2"]) -> Float[jax.Array, ""]:
    """Area of 2D polygon assuming no self-intersection."""
    return jnp.sum(pts[:,0]*jnp.roll(pts[:,1], 1) - jnp.roll(pts[:,0], 1)*pts[:,1])/2

# %% ../nbs/00_trigonometry.ipynb #48180c1b
def get_signed_angle_between_vectors(a: Float[jax.Array, "2"],
                                     b: Float[jax.Array, "2"]) -> Float[jax.Array, ""]:
    """Signed angle between two 2d vectors"""
    return jnp.atan2(jnp.cross(a, b), jnp.dot(a, b))


def get_angle_between_vectors(a: Float[jax.Array, " dim"],
                              b: Float[jax.Array, " dim"]) -> Float[jax.Array, ""]:
    """Angle between two vectors"""
    return jnp.atan2(jnp.linalg.norm(jnp.cross(a, b)), jnp.dot(a, b))

def get_cot_between_vectors(a: Float[jax.Array, " dim"],
                              b: Float[jax.Array, " dim"]) -> Float[jax.Array, ""]:
    """Cotangent of angle between two vectors"""
    return jnp.dot(a, b) / jnp.linalg.norm(jnp.cross(a, b))

# %% ../nbs/00_trigonometry.ipynb #27a11ad7
@functools.partial(jax.jit, static_argnames=['zero_clip'])
def get_voronoi_corner_area(a: Float[jax.Array, " dim"],
                            b: Float[jax.Array, " dim"],
                            c: Float[jax.Array, " dim"], zero_clip: float=1e-10) -> Float[jax.Array, "*"]:
    """
    Compute oriented Voronoi area at corner a of triangle abc. Returns vector in 3d.
    Returns zero for a degenerate triangle.
    """
    u = get_circumcenter(a, b, c)
    # Voronoi edges are midpoints of triangle edges. the corner area splits into two triangles:
    #a_corner = get_polygon_area(jnp.stack([a, (a-b)/2, u, (a-c)/2], axis=0))
    a_corner = get_oriented_triangle_area(a, (a-c)/2, u)+get_oriented_triangle_area(u, (a-b)/2, a)
    a_triangle = get_triangle_area(a, b, c)
    return jnp.where(a_triangle > zero_clip, a_corner, 0.0)

# %% ../nbs/00_trigonometry.ipynb #f5fabd40
def get_rot_mat(theta: float) -> Float[jax.Array, "2 2"]:
    """Get 2D rotation matrix from angle in radians."""
    return jnp.array([[jnp.cos(theta), jnp.sin(theta)],[-jnp.sin(theta), jnp.cos(theta)]])

def get_perp_2d(x: Float[jax.Array, "... 2"]) -> Float[jax.Array, "... 2"]:
    """Get perpendicular vector."""
    return jnp.stack([x[..., 1], -x[..., 0]], axis=-1)

def get_triangle_normal(a: Float[jax.Array, "3"],
                        b: Float[jax.Array, "3"],
                        c: Float[jax.Array, "3"]) -> Float[jax.Array, "3"]:
    """Compute unit normal vector of triangle abc."""
    n = jnp.cross(b - a, c - a)
    return n / jnp.linalg.norm(n)

def quaternion_to_rot_max(q: Float[jax.Array, "4"]) -> Float[jax.Array, "3 3"]:
    """
    Convert unit quaternion into a 3d rotation matrix.
    
    See https://fr.wikipedia.org/wiki/Quaternions_et_rotation_dans_l%27espace
    """
    a, b, c, d = q / jnp.linalg.norm(q)
    return jnp.array([[a**2+b**2-c**2-d**2, 2*b*c-2*a*d, 2*a*c+2*b*d],
                      [2*a*d+2*b*c, a**2-b**2+c**2-d**2, 2*c*d-2*a*b],
                      [2*b*d-2*a*c, 2*a*b+2*c*d, a**2-b**2-c**2+d**2]])

# %% ../nbs/00_trigonometry.ipynb #8f94dd08
@functools.partial(jax.jit, static_argnames=['zero_clip', 'normalize'])
def get_barycentric_coordinates(point: Float[jax.Array, " dim"],
                                a: Float[jax.Array, " dim"],
                                b: Float[jax.Array, " dim"],
                                c: Float[jax.Array, " dim"],
                                zero_clip: float = 1e-10, normalize: bool = True) -> Float[jax.Array, "3"]:
    """Compute barycentric coordinates of point with respect to triangle abc."""
    bary, _, _, _ = jnp.linalg.lstsq(jnp.stack([a,b,c], axis=1), point)
    if normalize:
        bary = bary / jnp.clip(bary.sum(), zero_clip)
    return bary
