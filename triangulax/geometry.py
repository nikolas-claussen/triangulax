# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_geometric_quantities.ipynb.

# %% auto #0
__all__ = ['get_he_length', 'get_triangle_areas', 'get_oriented_triangle_areas', 'get_triangle_normals', 'get_vertex_normals',
           'get_dihedral_angles', 'get_voronoi_face_positions', 'set_voronoi_face_positions', 'get_dual_he_length',
           'get_oriented_dual_he_length', 'get_corner_angles', 'get_angle_sum', 'get_cotan_weights_per_he',
           'get_cotan_weights_per_egde', 'get_voronoi_edge_lengths', 'get_cell_areas_traversal', 'get_voronoi_areas']

# %% ../nbs/06_geometric_quantities.ipynb #d159edd4-4456-41f8-b520-8b1b69219c67
import numpy as np
import igl

# %% ../nbs/06_geometric_quantities.ipynb #9f1cb15c-86cd-4e64-8f21-d4726216cd2f
import jax
import jax.numpy as jnp
import jax.experimental.sparse as jsparse

import dataclasses

import lineax

import functools

# %% ../nbs/06_geometric_quantities.ipynb #723a50d1-f5c2-435c-9026-39b6067f426d
from jaxtyping import Float 

# %% ../nbs/06_geometric_quantities.ipynb #cef3ff0a
from . import trigonometry as trig
from . import mesh as msh
from . import adjacency as adj

# %% ../nbs/06_geometric_quantities.ipynb #cf6fcd73
def get_he_length(vertices: Float[jax.Array, "n_vertices dim"], hemesh: msh.HeMesh
                  ) -> Float[jax.Array, " n_hes"]:
    """Get lengths of half-edges (triangulation/primal edges)."""
    return jnp.linalg.norm(vertices[hemesh.orig]-vertices[hemesh.dest], axis=-1)


# %% ../nbs/06_geometric_quantities.ipynb #5c5b1e2a
## triangle areas and normals

def get_triangle_areas(vertices: Float[jax.Array, "n_vertices dim"], hemesh: msh.HeMesh
                       ) ->Float[jax.Array, "n_faces ..."]:
    """Compute triangle areas in a mesh."""
    return jax.vmap(trig.get_triangle_area)(*vertices[hemesh.faces.T])

def get_oriented_triangle_areas(vertices: Float[jax.Array, "n_vertices dim"], hemesh: msh.HeMesh
                                ) ->Float[jax.Array, "n_faces ..."]:
    """Compute oriented triangle areas in a mesh. In 3d, this is a vector."""
    return jax.vmap(trig.get_oriented_triangle_area)(*vertices[hemesh.faces.T])

def get_triangle_normals(vertices: Float[jax.Array, "n_vertices dim"], hemesh: msh.HeMesh
                         ) ->Float[jax.Array, "n_faces ..."]:
    """Compute normals. In 2d, this just returns +/-1."""
    oriented_areas = get_oriented_triangle_areas(vertices, hemesh)
    norm = jnp.clip(jnp.linalg.norm(oriented_areas, axis=-1), 1e-12)
    return (oriented_areas.T / norm).T

def get_vertex_normals(vertices: Float[jax.Array, "n_vertices dim"], hemesh: msh.HeMesh
                       ) ->Float[jax.Array, "n_faces ..."]:
    """Compute per-vertex normals by averaging over faces"""
    oriented_areas = get_oriented_triangle_areas(vertices, hemesh)
    oriented_areas_vertex = adj.sum_face_to_vertex(oriented_areas)
    norm = jnp.clip(jnp.linalg.norm(oriented_areas_vertex, axis=-1), 1e-12)
    return (oriented_areas_vertex.T / norm).T

def get_dihedral_angles(vertices: Float[jax.Array, "n_vertices dim"], hemesh: msh.HeMesh
                       ) ->Float[jax.Array, "n_hes ..."]:
    """Get dihedral angles (angle between adjacent face normals)."""
    oriented_areas = get_oriented_triangle_areas(vertices, hemesh)
    dihedral = jax.vmap(trig.get_angle_between_vectors)(oriented_areas[hemesh.heface],
                                                        oriented_areas[hemesh.twin[hemesh.heface]])
    return dihedral

# %% ../nbs/06_geometric_quantities.ipynb #b30791e6
def get_voronoi_face_positions(vertices: Float[jax.Array, "n_vertices 2"], hemesh: msh.HeMesh
                               ) -> Float[jax.Array, "n_faces 2"]:
    """Get face positions of geommesh to the circumcenters of the faces defined by hemesh."""
    face_positions = jax.vmap(trig.get_circumcenter)(*vertices[hemesh.faces].transpose((1,0,2)))
    return face_positions

def set_voronoi_face_positions(geommesh: msh.GeomMesh, hemesh: msh.HeMesh
                               ) -> msh.GeomMesh:
    """Set face positions of geommesh to the circumcenters of the faces defined by hemesh."""
    face_positions = get_voronoi_face_positions(geommesh.vertices, hemesh)
    return dataclasses.replace(geommesh, face_positions=face_positions)

# %% ../nbs/06_geometric_quantities.ipynb #d0391799
## Note: these quantities are currently accurate in 2D only (i.e. for planar dual cells)

def get_dual_he_length(face_positions: Float[jax.Array, "n_faces dim"], hemesh: msh.HeMesh
                       ) -> Float[jax.Array, " n_hes"]:
    """Get lengths of dual/cell half-edges."""
    dual_edges = face_positions[hemesh.heface]-face_positions[hemesh.heface[hemesh.twin]]
    return jnp.linalg.norm(dual_edges, axis=-1)

def get_oriented_dual_he_length(vertices: Float[jax.Array, "n_vertices 2"],
                                face_positions: Float[jax.Array, "n_faces 2"],
                                hemesh: msh.HeMesh) -> Float[jax.Array, " n_hes"]:
    """Compute lengths of dual edges. Boundary dual edges get length 1. Negative sign = flipped edge."""
    dual_edges = face_positions[hemesh.heface]-face_positions[hemesh.heface[hemesh.twin]]

    edges = vertices[hemesh.orig]-vertices[hemesh.dest]
    edges_normalized = (edges.T / jnp.linalg.norm(edges, axis=-1)).T
    signed_dual_length = jnp.einsum('vi,vi->v', edges_normalized, dual_edges @ trig.get_rot_mat(np.pi/2))
    signed_dual_length = jnp.where(hemesh.is_bdry_edge, 1, signed_dual_length)
    return signed_dual_length

# %% ../nbs/06_geometric_quantities.ipynb #96c8a576
def get_corner_angles(vertices: Float[jax.Array, "n_vertices dim"],hemesh: msh.HeMesh
                      ) -> Float[jax.Array, " n_hes"]:
    """Get angles in mesh corners (opposite to half-edges)."""
    b, c = vertices[hemesh.orig], vertices[hemesh.dest]
    a = vertices[hemesh.dest[hemesh.nxt]]
    return jax.vmap(trig.get_angle_between_vectors)(b-a, c-a)

def get_angle_sum(vertices: Float[jax.Array, "n_vertices dim"],hemesh: msh.HeMesh
                  ) -> Float[jax.Array, " n_vertices"]:
    """Angle sum around vertices. 2*pi-angle sum measures Gaussian curvature"""
    angles = get_corner_angles(vertices, hemesh)
    return adj.sum_he_to_vertex_opposite(hemesh, angles)

def get_cotan_weights_per_he(vertices: Float[jax.Array, "n_vertices dim"],
                             hemesh: msh.HeMesh) -> Float[jax.Array, " n_hes"]:
    """Cotangent of angle opposite to half-edge """
    b, c = vertices[hemesh.orig], vertices[hemesh.dest]
    a = vertices[hemesh.dest[hemesh.nxt]]
    return jax.vmap(trig.get_cot_between_vectors)(b-a, c-a)

def get_cotan_weights_per_egde(vertices: Float[jax.Array, "n_vertices dim"],
                               hemesh: msh.HeMesh) -> Float[jax.Array, " n_hes"]:
    """Average of cotangent of angles opposite to edge"""
    per_he = get_cotan_weights_per_he(vertices, hemesh)
    return (per_he + per_he[hemesh.twin])/2

def get_voronoi_edge_lengths(vertices: Float[jax.Array, "n_vertices dim"],
                             hemesh: msh.HeMesh) -> Float[jax.Array, " n_hes"]:
    """Computed directly from angles. Accurate in any dimension"""
    return get_cotan_weights_per_egde(vertices, hemesh) * get_he_length(vertices, hemesh)


# %% ../nbs/06_geometric_quantities.ipynb #fbebd977-9ea6-4ab9-8188-d833f1bbba60
def get_cell_areas_traversal(geommesh: msh.GeomMesh, hemesh: msh.HeMesh) -> Float[jax.Array, " n_vertices"]:
    """
    Compute areas of cells by mesh traversal (don't use for simulation, inefficient).

    Boundary vertices get area 0.
    """
    areas = np.zeros(hemesh.n_vertices)
    bdry = hemesh.is_bdry
    for v in range(hemesh.n_vertices):
        if bdry[v]:
            areas[v] = 0
        else:
            adjacent_faces = hemesh.heface[hemesh.iterate_around_vertex(v)]
            polygon = geommesh.face_positions[adjacent_faces]
            areas[v] = trig.get_polygon_area(polygon)
    return -jnp.array(areas)

def get_voronoi_areas(vertices: Float[jax.Array, "n_vertices dim"], hemesh: msh.HeMesh) ->Float[jax.Array, " n_vertices"]:
    """Compute Voronoi area for each vertex."""
    a = hemesh.dest[hemesh.nxt]
    b = hemesh.dest[hemesh.prv]
    c = hemesh.dest
    corner_areas = jax.vmap(trig.get_voronoi_corner_area)(
        vertices[a], vertices[b], vertices[c])
    corner_areas = jnp.where(hemesh.is_bdry_he, 0, corner_areas)
    cell_areas = adj.sum_he_to_vertex_opposite(hemesh, corner_areas)
    return cell_areas
