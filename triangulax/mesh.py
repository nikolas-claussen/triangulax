# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_triangulation_datastructure.ipynb.

# %% auto #0
__all__ = ['TriMesh', 'generate_ginibre_points', 'generate_poisson_points', 'generate_triangular_lattice',
           'get_adjacent_vertex_indices', 'label_plot', 'get_half_edge_arrays', 'HeMesh',
           'connect_boundary_to_infinity', 'VertexAttribs', 'HeAttribs', 'FaceAttribs', 'GeomMesh',
           'set_voronoi_face_positions', 'Mesh', 'cellplot', 'tree_stack', 'tree_unstack', 'flip_edge',
           'get_signed_dual_he_length', 'flip_all', 'sum_he_to_vertex_incoming', 'sum_he_to_vertex_opposite',
           'get_cell_areas']

# %% ../nbs/01_triangulation_datastructure.ipynb #d159edd4-4456-41f8-b520-8b1b69219c67
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt

import igl

from scipy import spatial

import copy

# %% ../nbs/01_triangulation_datastructure.ipynb #9f1cb15c-86cd-4e64-8f21-d4726216cd2f
import jax
import jax.numpy as jnp

# %% ../nbs/01_triangulation_datastructure.ipynb #723a50d1-f5c2-435c-9026-39b6067f426d
from jaxtyping import Float, Int, Bool, PyTree 
from typing import Any, Iterable, NamedTuple
from pathlib import Path
from enum import IntEnum

import dataclasses

import functools

# %% ../nbs/01_triangulation_datastructure.ipynb #cef3ff0a
from . import trigonometry as trig

# %% ../nbs/01_triangulation_datastructure.ipynb #468fc48c-bf9f-46b9-bc24-74638da2c662
@dataclasses.dataclass(init=True, repr=False, eq=False, frozen=False, slots=False)
class TriMesh:
    """
    Simple class for reading, holding, transforming, and saving triangular meshes.
    
    A TriMesh comprises vertices and faces, describing a surface in 2d or 3d. 
    In addition, there can be a 2d/3d position for every face (think Voronoi dual of the triangulation).
    
    Vertices and faces are jnp.arrays. Each face is a triple of vertex indices.
    Vertices and faces are ordered - this is essential so that we know which attribute
    vector entry goes to which vector/edge/face. Faces in a face are assumed to be in counter-clockwise order.

    Meshes are read and written in the .obj format (https://en.wikipedia.org/wiki/Wavefront_.obj_file).
    To store _face_positions_, we abuse the `vn` (vertex normal) entry of an .obj file. Face
    positions will be written in order corresponding to faces.
    When reading from an .obj file, edges are recomputed from faces and initialized in alpha-numerical ordering.
    An .obj file expects 3d positions; the z-position is ignored when reading and set to 0 when writing for 2d meshes.

    **Attributes**

    dim : int = 2
    
    vertices : Float[jax.Array, "n_vertices dim"]

    faces : Int[jax.Array, "n_faces 3"]

    face_positions : Float[jax.Array, "n_faces dim"]

    **Property methods (use like attributes)**

    n_vertices : int

    has_inf_vertex : bool

    **Static methods**
    
    read_obj : str -> TriMesh

    **Methods**

    write_obj : str -> None
        
    """
    vertices : Float[jax.Array, "n_vertices dim"]
    faces : Int[jax.Array, "n_faces 3"]
    face_positions : Float[jax.Array, "n_faces dim"] | None = None

    def set_voronoi(self):
        """Set face positions to the Voronoi dual of the faces is computed."""
        self.face_positions = jax.vmap(trig.get_circumcenter)(*[self.vertices[fcs] for fcs in self.faces.T])
        
    @staticmethod  
    def read_obj(filename: str | Path, read_face_positions: bool = False, dim: int = 2) -> "TriMesh":
        """
        Read vertices, texture vertices, normals, and faces from an obj file.

        Indices of returned faces start at 0. See https://en.wikipedia.org/wiki/Wavefront_.obj_file.
        Intended for .obj files containing a single object only.

        Parameters
        ----------
        filename : str
            filename
        read_face_positions : bool
            If True, use the vertex normal entries `vn` in the .obj file
            as face positions. This is an abuse of the .obj file format
            so only use this for files written by this code.
        dim : int
            Dimension - can be 2 or 3. If 2, the z-coordinate is ignored.
        
        Returns
        -------
        mesh: TriMesh
        """
        vertices, _, normals, faces, _, _ = igl.readOBJ(filename)
        if read_face_positions:
            return TriMesh(jnp.array(vertices[:,:dim]), jnp.array(faces), face_positions=jnp.array(normals[:,:dim]))
        mesh = TriMesh(jnp.array(vertices[:,:dim]), jnp.array(faces), face_positions=None)
        mesh.set_voronoi()
        return mesh
        
    def write_obj(self, filename: str | Path, save_face_positions: bool=True) -> None:
        """
        Write mesh to .obj format.

        Parameters
        ----------
        filename : str
            filename to save to
        save_face_positions : bool
            If true, face positions are written to the `vn` line of .obj files.
            
        Returns
        -------
        None
        """
        if self.dim == 2:
            vlines = ["v {} {} 0\n".format(*v) for v in self.vertices]
            vnlines = ["vn {} {} 0\n".format(*vn) for vn in self.face_positions]
        elif self.dim == 3:
            vlines = ["v {} {} {}\n".format(*v) for v in self.vertices]
            vnlines = ["vn {} {}\n".format(*vn) for vn in self.face_positions]
        flines = ["f {} {} {}\n".format(*[int(v+1) for v in fc]) for fc in self.faces]

        with open(filename, 'w') as f:
            f.writelines(vlines)
            if save_face_positions:
                f.writelines(vnlines)               
            f.writelines(flines)
        return None

    @property
    def has_inf_vertex(self) -> bool:
        return jnp.isinf(self.vertices).any()

    @property
    def n_vertices(self) -> int:
        return self.vertices.shape[0]

    @property
    def dim(self) -> int:
        return self.vertices.shape[-1]



# %% ../nbs/01_triangulation_datastructure.ipynb #71736c3c-c197-48f0-8cd3-c5ba9fba9713
def generate_ginibre_points(n_vertices: int) -> Float[jax.Array, "n_vertices 2"]:
    """Sample n_vertices points from the Ginibre ensemble. Points are scaled to unit disk."""
    M = np.random.normal(size=(n_vertices, n_vertices)) + 1j*np.random.normal(size=(n_vertices, n_vertices))
    vals = np.linalg.eigvals(M)
    pos = np.stack([vals.real, vals.imag], axis=-1)
    # rescale to unit disk
    pos /= np.linalg.norm(pos, axis=1).mean()
    return jnp.array(pos)

def generate_poisson_points(n_vertices: int, limit_x: float = 1, limit_y: float = 1
                           ) -> Float[jax.Array, "n_vertices 2"]:
    """Sample n_vertices points from the Poisson ensemble in rectangle
    [-limit_x/2, limit_x/2] * [-limit_y/2, limit_y/2]."""
    pos = np.stack([np.random.uniform(size=n_vertices, low=-limit_x/2, high=limit_x/2),
                    np.random.uniform(size=n_vertices, low=-limit_y/2, high=limit_y/2)])
    return jnp.array(pos)

def generate_triangular_lattice(nx: int, ny: int) -> Float[jax.Array, "nx*ny 2"]:
    """Get points for rectangular patch of triangular lattice with nx, ny points."""
    y = np.arange(0, ny)*np.sqrt(3)/2
    x = np.arange(nx).astype(float)
    X, Y = np.meshgrid(x, y)
    X -= X.mean()+1/2
    Y -=Y.mean()
    X = (X.T+(np.arange(ny)%2)/2).T
    pts = np.stack([X, Y]).reshape((2,nx*ny))    
    return jnp.array(pts.T)

# %% ../nbs/01_triangulation_datastructure.ipynb #2c4a0e23-ac42-4264-9a38-f8745e02a131
# find the vertices and faces which are adjacent to a given vertex, in the correct counter-clockwise order.

def get_adjacent_vertex_indices(faces: Int[jax.Array, "n_faces 3"],
                                n_vertices: int) -> list[Int[jax.Array, " n_neighbors"]]:
    """For each vertex, get the indices of the adjacent vertices in correct order.
    For boundary vertices, this list contains the vertex itself."""
    vf, ni = igl.vertex_triangle_adjacency(mesh.faces, n=n_vertices)
    adjacent_faces = [vf[a:b] for a, b in zip(ni[:-1], jnp.roll(ni, -1)[:-1])]
    adjacent_vertices = [jnp.array(igl.boundary_loop(faces[fcs])) for fcs in adjacent_faces]
    return adjacent_vertices

# %% ../nbs/01_triangulation_datastructure.ipynb #45616576-ecbd-46f3-998b-ff82c6aa7bef
def label_plot(vertices: Float[jax.Array, "n_vertices 2"],
               faces: Int[jax.Array, "n_faces 3"],
               hemesh: None | PyTree=None,
               vertex_labels: bool = True, face_labels: bool=True,
               ax: None | mpl.axes.Axes=None,
               fontsize: int|None = None) -> None:
    """For debugging purposes. Plot triangular mesh with face/vertex labels in black/blue.
    If hemesh is not None, the connectivity info from it is used to plot the half-edge labels."""
    ax = plt.gca() if ax is None else ax
    if vertex_labels:
        for iv, v in enumerate(vertices):
            ax.text(*(v+np.array([0,.025])), str(iv),
                    color="tab:blue", ha="center", fontsize=fontsize)
    if face_labels:
        for ifc, fc in enumerate(faces):
            centroid = np.mean([vertices[iv] for iv in fc], axis=0)
            ax.text(*centroid, str(ifc), color="k", fontsize=fontsize, ha="center",)
    if hemesh is not None:
        edge_center = (vertices[hemesh.dest] + vertices[hemesh.orig])/2
        for ie in np.where(hemesh.is_unique)[0]:
            ax.text(*edge_center[ie], f"{ie}/{hemesh.twin[ie]}",
            color="tab:orange", ha="center", fontsize=fontsize)
            
    return None

# %% ../nbs/01_triangulation_datastructure.ipynb #33c2f096-58c2-4cc1-9698-7c6a837cd730
def get_half_edge_arrays(n_vertices: int, faces: Int[jax.Array, "n_faces 3"]) -> list[Int[jax.Array, " n"]]:
    """
    Get half-edge data structure arrays from faces.

    Returns: incident, orig, dest, twin, nxt, prv, heface, face_incident
    """
    # form all unique edges, ordered lexicographically
    edges = np.array(sorted([sorted(x) for x in igl.edges(faces)]))
    half_edges = np.vstack([edges, edges[:,::-1]])

    # initialize the connectivity arrays
    orig, dest = (half_edges[:,0], half_edges[:, 1])
    twin = np.hstack([np.arange(edges.shape[0])+edges.shape[0], np.arange(edges.shape[0])])

    # iterate over faces to get face, prv, and nxt for each half-edge
    nxt, prv, heface = (np.ones_like(orig), np.ones_like(orig), -1*np.ones_like(orig),)
    for ifc, fc in enumerate(faces):
        for v_prv, v, v_nxt in zip(np.roll(fc, 1), fc, np.roll(fc, -1)):
            heface[(orig==v) & (dest==v_nxt)] = ifc
            nxt[(orig==v_prv) & (dest==v)] = np.where((orig==v) & (dest==v_nxt))[0][0]
            prv[(orig==v) & (dest==v_nxt)] = np.where((orig==v_prv) & (dest==v))[0][0]
    
    # finally, prv and nxt for the boundary hes
    for loop in igl.boundary_loop_all(faces):
        for v_nxt, v, v_prv in zip(np.roll(loop, 1), loop, np.roll(loop, -1)):
            nxt[(orig==v_prv) & (dest==v)] = np.where((orig==v) & (dest==v_nxt))[0][0]
            prv[(orig==v) & (dest==v_nxt)] = np.where((orig==v_prv) & (dest==v))[0][0]

    # get an incident half-edge for each vertex and face 
    incident = np.array([np.argmax(orig==v) for v in range(n_vertices)])
    face_incident = np.array([np.argmax(heface==ifc) for ifc, _ in enumerate(faces)])            

    return [jnp.array(arr) for arr in [incident, orig, dest, twin, nxt, prv, heface, face_incident]]

# %% ../nbs/01_triangulation_datastructure.ipynb #965577eb-7900-4c5d-8f0a-8cc2fd40caba
@jax.tree_util.register_dataclass
@dataclasses.dataclass(repr=False, eq=False, frozen=True)
class HeMesh:
    """
    Half-edge mesh data structure for triangular meshes.

    A half-edge mesh is described by a set of half-edges and several
    arrays that specify their connectivity (see markup explanation above).
    This class serves as a container for multiple arrays.
    For future compatibility with JAX, after initialization, do not
    modify these arrays in-place; always return a new HeMesh object.
    The mesh vertices may live in whatever dimension - this
    does not affect the connectivity bookkeeping.

    Half-edge meshes are initialized from a list of triangles and a 
    number of vertices, and can return the original triangles (e.g., to save as a .obj).

    All information and methods are purely "combinatorial". The
    HeMesh class does _not_ contain the vertex or face positions.
    These are saved in the GeomHeMesh class that combines
    a HeMesh (combinatorics) with a couple of other arrays (geometry).

    ---Conventions---
    
    For vertices, the `incident` half-edge points _away_ from the vertex.

    To describe the mesh boundary, there are two options:
        1. Initialize from a triangulation with a boundary. Half-edges without
        a face (boundary) are assigned heface=-1.
        2. Initialize from a triangulation without boundary, where certain vertices
         are "at infinity". They should have coordinates [np.inf, np.inf].
         Each infinity vertex corresponds to one boundary. For a single
         boundary, the vertex at infinity is, by convention, the final one.

    Starting from a set of triangles, the half-edges are initialized as follows:
    The 1st N_edges half-edges are (origin_vertex, destination_vertex), in lexicographic order, with 
    origin_vertex < destination_vertex. The 2nd N_edges are their twins, in the same order.

    **Attributes**
    
    incident : Int[jax.Array, "n_vertices"]

    orig : Int[jax.Array, "n_hes"]

    dest : Int[jax.Array, "n_hes"]

    nxt : Int[jax.Array, "n_hes"]

    prv : Int[jax.Array, "n_hes"]

    twin : Int[jax.Array, "n_hes"]

    heface : Int[jax.Array, "n_hes"]

    face_incident : Int[jax.Array, "n_faces"]

    inf_vertices : tuple[Int]

    **Property methods (use like attributes)**

    n_vertices : int

    n_hes : int

    n_faces : int

    n_items : tuple[int, int, int]

    faces : Int[jax.Array, "n_faces 3"]

    has_inf_vertex : bool

    is_inf_face : Bool[jax.Array, "n_faces"]

    is_unique : Bool[jax.Array, "n_hes"]

    is_inf_he : Bool[jax.Array, "n_hes"]

    is_bdry_he : Bool[jax.Array, "n_hes"]

    is_bdry_edge : Bool[jax.Array, "n_hes"]

    is_bdry : Bool[jax.Array, "n_vertices"]

    **Static methods**

    from_triangles : tuple[int, Int[jax.Array, "n_faces 3"], Int[jax.Array, "n_boundaries"] -> HeMesh

    **Class methods**

    iterate_around_vertex : int -> Int[jax.Array, "n_neighbors"]

    save : str -> None:

    **Static methods**
    
    load : str -> HeMesh

    """
    
    incident : Int[jax.Array, "*batch n_vertices"]
    orig : Int[jax.Array, "*batch n_hes"]
    dest : Int[jax.Array, "*batch n_hes"] 
    twin : Int[jax.Array, "*batch n_hes"] 
    nxt : Int[jax.Array, "*batch n_hes"] 
    prv : Int[jax.Array, "*batch n_hes"]
    heface : Int[jax.Array, "*batch n_hes"]
    face_incident : Int[jax.Array, "*batch n_faces"]
    inf_vertices : tuple[()] | tuple[int] = dataclasses.field(default=(), metadata=dict(static=True))

    # convert from and to a list of triangles

    @staticmethod
    def from_triangles(n_vertices: int, faces: Int[jax.Array, "n_faces 3"],
                       inf_vertices: tuple[()] | tuple[int] =()):
        # get HE data arrays
        incident, orig, dest, twin, nxt, prv, heface, face_incident = get_half_edge_arrays(n_vertices, faces)
        return HeMesh(incident, orig, dest, twin, nxt, prv, heface, face_incident, inf_vertices)

    @property
    def faces(self) -> Int[jax.Array, "n_faces 3"]:
        """Get faces (list of vertices per face)."""
        return jnp.stack([self.orig[self.face_incident],
                          self.dest[self.face_incident],
                          self.dest[self.nxt[self.face_incident]]], axis=1)
    
    # mesh size info

    @property
    def n_vertices(self) -> int:
        return self.incident.shape[0]
    
    @property
    def n_hes(self) -> int:
        return self.orig.shape[0]

    @property
    def n_faces(self) -> int:
        return self.face_incident.shape[0]

    @property
    def n_items(self) -> tuple[int, int, int]:
        return (self.n_vertices, self.n_hes, self.n_faces)
    
    @property
    def is_unique(self) -> Bool[jax.Array, "n_hes"]:
        """Get an (arbitrary) set of unique half-edges (every edge is represented once)."""
        return self.orig < self.dest

    def __repr__(self) -> str:
        return "HeMesh(N_V={}, N_HE={}, N_F={})".format(*self.n_items)
    
    # boundary info - implemented as class methods to hide "implementation detail" of infinity vertices
    
    @property
    def has_inf_vertex(self) -> bool:
        return len(self.inf_vertices)>0

    @property
    def is_inf_face(self) -> Bool[jax.Array, "n_faces"]:
        """True if face is fictitious/connected to an infinity vertex."""
        return jnp.isin(self.faces, jnp.array(self.inf_vertices)).any(axis=1)

    @property
    def is_inf_he(self) -> Bool[jax.Array, "n_hes"]:
        """True if half-edge is fictitious/connected to an infinity vertex."""
        return jnp.isin(self.orig, jnp.array(self.inf_vertices)) | jnp.isin(self.dest, jnp.array(self.inf_vertices))
    
    @property
    def is_bdry_he(self) -> Bool[jax.Array, "n_hes"]:
        return jax.lax.select(self.has_inf_vertex, jnp.isin(self.dest[self.nxt], jnp.array(self.inf_vertices)), self.heface == -1)

    @property
    def is_bdry_edge(self) -> Bool[jax.Array, "n_hes"]:
        return self.is_bdry_he | self.is_bdry_he[self.twin]
    
    @property
    def is_bdry(self) -> Bool[jax.Array, "n_vertices"]:
        v_field = jnp.zeros(self.n_vertices)
        return v_field.at[self.dest].add(1*self.is_bdry_he) > 0

    # mesh traversal
    
    def iterate_around_vertex(self, v: int) -> Int[jax.Array, " n_neighbors"]:
        """Get list of half-edges going out of a vertex."""
        polygon_edges = [self.incident[v]]
        while True: # this while loop is challenging to rewrite using jax.lax since the output shape is not known!
            next_edge = self.twin[self.prv[polygon_edges[-1]]]
            if next_edge == polygon_edges[0]:
                break
            polygon_edges.append(next_edge)
        return jnp.array(polygon_edges)

    @property
    def bdry_loops(self) -> list[Int[jax.Array, " loop_length"]]:
        return [self.dest[self.iterate_around_vertex(v)] for v in jnp.array(self.inf_vertices)]
        
    # copying, saving, and loading

    def __copy__(self):
        return HeMesh(**dataclasses.asdict(self)) # no need to copy since all entries are immutable
    
    def save(self, file: str | Path) -> None:
        """Save HeMesh to .npz archive of np.arrays"""
        dict_to_save = dataclasses.asdict(self)
        dict_to_save["inf_vertices"] = jnp.array(self.inf_vertices)
        np.savez(file, **dict_to_save, allow_pickle=False)
        return None

    @staticmethod
    def load(file: str | Path) -> "HeMesh":
        dict_to_load = dict(np.load(file))
        dict_to_load["inf_vertices"] = tuple([int(x) for x in dict_to_load["inf_vertices"]])
        return HeMesh(**dict_to_load)

    # equality comparisons. Two meshes are equal if all the arrays they contain are.
    # isomorphic meshes _can_ compare to false if, e.g., the orderings are different.
    
    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, HeMesh):
            return False          
        if not self.inf_vertices == other.inf_vertices:
            return False
        return jax.tree_util.tree_all(jax.tree.map(jnp.allclose, dataclasses.asdict(self), dataclasses.asdict(other))) # compares all array values

# %% ../nbs/01_triangulation_datastructure.ipynb #4378ad6f
def connect_boundary_to_infinity(vertices: Float[jax.Array, "n_vertices 2"],
                                 faces: Int[jax.Array, "n_faces 3"]
                                ) -> tuple[Float[jax.Array, "n_vertices_new 2"],
                                           Int[jax.Array, "n_faces_new 3"],
                                           tuple[int]]:
    """
    Connect boundary loop(s) to infinity.
    
    New vertices are appeneded to the end of vertex array and have coordinates [np.inf, np.inf].

    Parameters 
    ----------
    vertices : Float[jax.Array, "n_vertices 2"]
        Vertex positions.
    faces : Int[jax.Array, "n_faces 2"]
        Faces (triangles) as list of vertex indices.

    Returns
    -------
    new_vertices : Float[jax.Array, "n_vertices_new 2"]
        Vertex positions with infinity vertices appended.
        One infinity vertex per boundary loop.
    new_faces : Int[jax.Array, "n_faces_new 2"]
        Faces (triangles) as list of vertex indices, with new faces added to connect
        boundary loops to infinity vertices.
    inf_vertices : tuple[Int]
        Indices of infinity vertices in new_vertices.
        Will be (n_vertices, n_vertices+1, ..., n_vertices+n_boundaries-1).
    """
    boundary_loops = igl.boundary_loop_all(mesh.faces)
    new_vertices = jnp.copy(vertices)
    new_faces = jnp.copy(faces)

    for loop in boundary_loops:
        inf_index = vertices.shape[0]
        inf_faces = np.stack([[inf_index, v2, v1] for v1, v2 in zip(loop, np.roll(loop, -1))])
        new_vertices = jnp.vstack([new_vertices, jnp.inf*jnp.ones_like(new_vertices[:1])])
        new_faces = jnp.vstack([faces, inf_faces])
    
    return new_vertices, new_faces, tuple(range(vertices.shape[0], new_vertices.shape[0]))

# %% ../nbs/01_triangulation_datastructure.ipynb #6287c71c
# this is how you set up an enum. It is important to use IntEnum, so we can _order_ the enums.
# The precise Enum you will use depends on your application.

class VertexAttribs(IntEnum):
    TARGET_AREA = 1
    TARGET_PERIMETER = 2

class HeAttribs(IntEnum):
    EDGE_TENSION = 1

class FaceAttribs(IntEnum):
    FACE_AREA = 1

# you can iterate over enums, and they are hashable. The latter is essential for JAX!

[a for a in VertexAttribs], hash(VertexAttribs.TARGET_PERIMETER)

# %% ../nbs/01_triangulation_datastructure.ipynb #c7c0e33c-a06d-4a93-9d88-6aa0716bdf5b
@jax.tree_util.register_dataclass
@dataclasses.dataclass(repr=False, eq=False, frozen=True,)
class GeomMesh:
    """
    Data class for holding mesh geometry and mesh-associated variables.
    To be combined with a HeMesh to specify the connectivity.

    One array (for vertex positions) must always be present. A second,
    but optional, standard entry is a set of positions for each face. 
    The mesh coordinates can live in 2d or 3d.
    
    Optionally, vertices, half-edges, and faces can have attributes (stored as dictionaries).
    The keys of the dictionary should be taken from a suitable 'enum'. The values are 
    ndarrays, whose 0th axis is (vertices/edges/faces). These attribute dicts are
    initialized empty and can be set afterwards.

    See documentation on HeMesh
    
    **Attributes**

    vertices : Float[jax.Array, "n_vertices 2"]

    face_positions : Float[jax.Array, "n_faces 2"]

    vertex_attribs : dict[IntEnum, Float[jax.Array, "n_vertices *"]]

    he_attribs : dict[IntEnum, Float[jax.Array, "n_hes *"]]

    face_attribs : dict[IntEnum, Float[jax.Array, "n_faces *"]]
    
    **Property methods (use like attributes)**

    n_items : tuple[int, int, int]

    dim : int

    **Class methods**

    validate_dimensions : bool

    **Static methods**
    
    load : str -> GeomHeMesh

    """

    n_vertices : int = dataclasses.field(metadata=dict(static=True))
    n_hes : int = dataclasses.field(metadata=dict(static=True))
    n_faces : int = dataclasses.field(metadata=dict(static=True))
    vertices : Float[jax.Array, "*batch n_vertices dim"]
    face_positions : Float[jax.Array, "*batch n_faces 2"] = dataclasses.field(default_factory=lambda : jnp.array([]))
    vertex_attribs : dict[IntEnum, Float[jax.Array, "... n_vertices"]] = dataclasses.field(default_factory=dict)
    he_attribs : dict[IntEnum, Float[jax.Array, "... n_hes"]] = dataclasses.field(default_factory=dict)
    face_attribs : dict[IntEnum, Float[jax.Array, "... n_faces"]] = dataclasses.field(default_factory=dict)
    
    @property
    def n_items(self) -> tuple[int, int, int]:
        return (self.n_vertices, self.n_hes, self.n_faces)

    @property
    def dim(self) -> int:
        return self.vertices.shape[-1]
    
    def __repr__(self) -> str:
        return "GeomMesh(D={},N_V={}, N_HE={}, N_F={})".format(*((self.dim,)+self.n_items))

    def validate_dimensions(self) -> None:
        """Validate input dimensions"""
        if (self.n_vertices != self.vertices.shape[0]):
            raise ValueError("Number of vertices inconsistent")
        if (self.face_positions.shape[0] not in [0, self.n_faces]):
            raise ValueError("Number of faces inconsistent")
        if any([val.shape[0] != self.n_vertices for _, val in self.vertex_attribs.items()]):
            raise ValueError("Vertex property dimension inconsistent")
        if any([val.shape[0] != self.n_hes for _, val in self.he_attribs.items()]):
            raise ValueError("Half-edge property dimension inconsistent")
        if any([val.shape[0] != self.n_faces for _, val in self.face_attribs.items()]):
            raise ValueError("Face property dimension inconsistent")
        return None

    def check_compatibility(self, hemesh: HeMesh) -> bool:
        return self.n_items==hemesh.n_items
    
    ## copying, loading, and saving
    
    def __copy__(self):
        return GeomMesh(*self.n_items, vertices=self.vertices, face_positions=self.face_positions,
                   vertex_attribs={key: jnp.copy(val) for key, val in self.vertex_attribs.items()},
                   he_attribs={key: jnp.copy(val) for key, val in self.he_attribs.items()},
                   face_attribs={key: jnp.copy(val) for key, val in self.face_attribs.items()})

    def save(self, file: str | Path) -> None:
        """Save HeMesh and all geometric attributes to two .npz archives of jnp.arrays"""
        np.savez(file,
             n_vertices=self.n_vertices, n_hes=self.n_hes, n_faces=self.n_faces,
             vertices=self.vertices, face_positions = self.face_positions,
             **{f"VertexAttribs.{key.name}": val for key, val in self.vertex_attribs.items()},
             **{f"HeAttribs.{key.name}": val for key, val in self.he_attribs.items()},
             **{f"FaceAttribs.{key.name}": val for key, val in self.face_attribs.items()},
             allow_pickle=False)
        return None

    @staticmethod
    def load(file: str | Path) -> "GeomMesh":
        """Note: must have the correct Enum's for the vertex/he/face properties imported."""
        npzfile = jnp.load(file)
        vertex_attribs = {VertexAttribs[key.split(".")[1]]: val
                          for key, val  in npzfile.items() if key.split(".")[0] == "VertexAttribs"}
        he_attribs = {HeAttribs[key.split(".")[1]]: val
                      for key, val  in npzfile.items() if key.split(".")[0] == "HeAttribs"}
        face_attribs = {FaceAttribs[key.split(".")[1]]: val
                        for key, val  in npzfile.items() if key.split(".")[0] == "FaceAttribs"}
        return GeomMesh(n_vertices=npzfile['n_vertices'].item(),
                        n_hes=npzfile['n_hes'].item(),
                        n_faces=npzfile['n_faces'].item(),
                        vertices=npzfile['vertices'],
                        face_positions=npzfile['face_positions'],
                        vertex_attribs=vertex_attribs,
                        he_attribs=he_attribs,
                        face_attribs=face_attribs)

    # equality comparisons. Two meshes are equal if all of the arrays they contain are equal.
    
    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GeomMesh):
            return False          
        if not self.n_items==other.n_items:
            return False
        return jax.tree_util.tree_all(jax.tree.map(jnp.allclose, jax.tree_util.tree_flatten(self)[0],
                                                                 jax.tree_util.tree_flatten(other)[0]))

# %% ../nbs/01_triangulation_datastructure.ipynb #a3a0cf80
def set_voronoi_face_positions(geommesh: GeomMesh, hemesh: HeMesh) -> GeomMesh:
    """Set face positions of geommesh to the circumcenters of the faces defined by hemesh."""
    face_positions = jax.vmap(trig.get_circumcenter)(*geommesh.vertices[hemesh.faces].transpose((1,0,2)))
    return dataclasses.replace(geommesh, face_positions=face_positions)

# %% ../nbs/01_triangulation_datastructure.ipynb #504fefa9-e469-4056-a6b9-a5496b3f6ff3
class Mesh(NamedTuple):
    """Combine geometric and connectivity info into a single object."""
    geommesh: GeomMesh
    hemesh: HeMesh

# %% ../nbs/01_triangulation_datastructure.ipynb #b4ccf185-8b5b-46f9-8d3f-9c7f7d77f516
def cellplot(hemesh: HeMesh, face_positions: Float[jax.Array, "n_faces 2"],
             cell_colors: None | str | Float[np.ndarray, "4"] | Float[np.ndarray, "n_vertices 4"] =None,
             mpl_polygon_kwargs: None | dict[str, Any] = None) -> mpl.collections.PatchCollection:
    """
    Plot a cell tesselation.
    
    cell_colors can be either a single color (for all cells) or a vector of rgba values.
    Only interior cells are plotted.
    """
    if mpl_polygon_kwargs is None:
        mpl_polygon_kwargs = {"lw": 1, "ec": "k"}
    # formatting for the cell colors - make into a list
    if cell_colors is None:
        cell_colors = np.zeros((hemesh.n_vertices, 4))
    if isinstance(cell_colors, str):
        cell_colors = [cell_colors for v in range(hemesh.n_vertices)]
    if isinstance(cell_colors, Iterable):
        assert len(cell_colors) in [4, hemesh.n_vertices], "Cell color must be 1 or n_vertices rgba values"
        if len(cell_colors) == 4:
            cell_colors = [cell_colors for v in range(hemesh.n_vertices)]
    # iterate over non-boundary vertices.
    polygons = []
    bdry = hemesh.is_bdry
    for v in range(hemesh.n_vertices):
        if not bdry[v]:
            polygon_edges = hemesh.iterate_around_vertex(v)
            polygon_vertices = face_positions[hemesh.heface[np.array(polygon_edges)]]
            polygons.append(mpl.patches.Polygon(polygon_vertices, color=cell_colors[v], **mpl_polygon_kwargs))
    return mpl.collections.PatchCollection(polygons, match_original=True)

# %% ../nbs/01_triangulation_datastructure.ipynb #d8e2ff2f
def tree_stack(xs : list[PyTree], axis=0) -> PyTree:
    """Stack a sequence of identical-structure pytrees along a new axis."""
    return jax.tree.map(lambda *leaves: jnp.stack(leaves, axis=axis), *xs)

def tree_unstack(xb: PyTree, axis=0) -> list[PyTree]:
    """Unstack a batched pytree along axis into a list of pytrees."""
    leaves, treedef = jax.tree.flatten(xb)
    B = leaves[0].shape[axis]
    # split every leaf along batch dimension
    per = [jax.tree.unflatten(treedef, [leaf.take(indices=i, axis=axis)  for leaf in leaves])
           for i in range(B)]
    return per

# %% ../nbs/01_triangulation_datastructure.ipynb #2a1c1f7c-4c6e-4312-9820-cf497590c452
@functools.partial(jax.jit, static_argnames=['check_boundary'])
def flip_edge(hemesh: HeMesh, e: Int[jax.Array, ""], check_boundary: bool = False) -> HeMesh:
    """
    Flip half-edge e in a half-edge mesh.
    
    See https://jerryyin.info/geometry-processing-algorithms/half-edge/. The algorithm
    is slightly modified since we keep track of the origin and destination of a half-edge,
    and use arrays instead of pointers. Returns a new HeMesh, does not modify in-place.
    """
    if check_boundary:
        assert (hemesh.heface[e] !=-1 and hemesh.heface[hemesh.twin[e]] != -1), "Cannot flip boundary edge"

    # identify relevant elements
    e5 = hemesh.prv[e]
    e4 = hemesh.nxt[e]
    twin = hemesh.twin[e]
    e1 = hemesh.prv[twin] 
    e0 = hemesh.nxt[twin] 

    # make sure thereâ€™s no vertex or face references to e or twin
    incident = hemesh.incident.at[jnp.array([hemesh.orig[e], hemesh.orig[twin]])].set(
        jnp.array([hemesh.twin[e5], hemesh.twin[e1]]))
    face_incident = hemesh.face_incident.at[jnp.array([hemesh.heface[e], hemesh.heface[twin]])].set(
        jnp.array([e5, e1])) # e1, e5 don't change face

    # update the data structure to do the T1
    nxt = hemesh.nxt.at[jnp.array([e, twin])].set(jnp.array([e5, e1]))
    prv = hemesh.prv.at[jnp.array([e, twin])].set(jnp.array([e0, e4]))
    orig = hemesh.orig.at[jnp.array([e, twin])].set(jnp.array([hemesh.orig[e1], hemesh.orig[e5]]) )
    dest = hemesh.dest.at[jnp.array([e, twin])].set(jnp.array([hemesh.dest[e4], hemesh.dest[e0]]))

    nxt = nxt.at[jnp.array([e0, e1, e4, e5])].set(jnp.array([e, e4, twin, e0]) )
    prv = prv.at[jnp.array([e0, e1, e4, e5])].set(jnp.array([e5, twin, e1, e]) )
    heface = hemesh.heface.at[jnp.array([e0, e4])].set(jnp.array([hemesh.heface[e5], hemesh.heface[e1]]))

    return HeMesh(incident, orig, dest, jnp.copy(hemesh.twin), nxt, prv, heface, face_incident, hemesh.inf_vertices)

# %% ../nbs/01_triangulation_datastructure.ipynb #a5bb78ce-454d-492c-b95e-797d1ed1f2aa
def get_signed_dual_he_length(geommesh: GeomMesh, hemesh: HeMesh) -> Float[jax.Array, " n_hes"]:
    """Compute lengths of dual edges. Boundary dual edges get length np.nan. Negative sign = flipped edge."""
    edges = geommesh.vertices[hemesh.orig]-geommesh.vertices[hemesh.dest]
    dual_edges = (geommesh.face_positions[hemesh.heface]
                 -geommesh.face_positions[hemesh.heface[hemesh.twin]])
    signed_squared_length = jnp.einsum('vi,vi->v', edges, dual_edges @ trig.get_rot_mat(np.pi/2))
    signed_length = jnp.sign(signed_squared_length) * jnp.sqrt(np.abs(signed_squared_length))
    signed_length = signed_length.at[hemesh.is_bdry_edge].set(jnp.nan)
    return signed_length

# %% ../nbs/01_triangulation_datastructure.ipynb #242d6ee1-d553-45fc-852f-a80fbb4a589a
@jax.jit
def flip_all(hemesh: HeMesh, to_flip: Bool[jax.Array, " n_hes"]) -> HeMesh:
    """Flip all (unique) half-edges where to_flip is True in a half-edge mesh. Wraps flip_edge."""
    def scan_fun(h, e): # flips edge e if its length < 0 and edge is unique. Otherwise, you undo your flips!
        return jax.lax.cond(to_flip[e] & hemesh.is_unique[e],
                            lambda hh: flip_edge(hh, e), lambda hh: hh, h), None
    flipped_hemesh, _ = jax.lax.scan(scan_fun, init=hemesh, xs=jnp.arange(hemesh.n_hes) )
    return flipped_hemesh

# %% ../nbs/01_triangulation_datastructure.ipynb #a6feb2c8-b107-47c7-ac47-6629a29299a0
# gather-scatter operations - sum from half-edges to vertices etc. Many other operations can be done similarly

def sum_he_to_vertex_incoming(hemesh: HeMesh, he_field: Float[jax.Array, "n_hes ..."]):
    """
    Sum a half-edge field onto destination vertices.

    hemesh: connectivity information
    he_field: (n_hes,) or (n_hes, d) array
    """
    out_shape = (hemesh.n_vertices,) + he_field.shape[1:]  # supports scalar or vector fields
    v_field = jnp.zeros(out_shape, dtype=he_field.dtype)
    # Scatter-add: for each half-edge h, add he_field[h] to v_field[dest[h]]
    return v_field.at[hemesh.dest].add(he_field)

def sum_he_to_vertex_opposite(hemesh: HeMesh, he_field: Float[jax.Array, "n_hes ..."]):
    """
    Sum a half-edge field onto opposite vertices.

    hemesh: connectivity information
    he_field: (n_hes,) or (n_hes, d) array
    """
    out_shape = (hemesh.n_vertices,) + he_field.shape[1:]  # supports scalar or vector fields
    v_field = jnp.zeros(out_shape, dtype=he_field.dtype)
    return v_field.at[hemesh.dest[hemesh.nxt]].add(he_field)


# %% ../nbs/01_triangulation_datastructure.ipynb #fbebd977-9ea6-4ab9-8188-d833f1bbba60
def get_cell_areas(geommesh: GeomMesh, hemesh: HeMesh) -> Float[jax.Array, " n_vertices"]:
    """
    Compute areas of cells by mesh traversal (don't use for simulation, inefficient).

    Boundary vertices get area 0.
    """
    areas = np.zeros(hemesh.n_vertices)
    bdry = hemesh.is_bdry
    for v in range(hemesh.n_vertices):
        if bdry[v]:
            areas[v] = 0
        else:
            adjacent_faces = hemesh.heface[hemesh.iterate_around_vertex(v)]
            polygon = geommesh.face_positions[adjacent_faces]
            areas[v] = trig.get_polygon_area(polygon)
    return jnp.array(areas)
