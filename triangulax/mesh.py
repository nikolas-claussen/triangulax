# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_halfedge_datastructure.ipynb.

# %% auto #0
__all__ = ['label_plot', 'get_half_edge_arrays_vectorized', 'HeMesh', 'connect_boundary_to_infinity', 'GeomMesh',
           'get_voronoi_face_positions', 'set_voronoi_face_positions', 'Mesh', 'cellplot', 'tree_stack', 'tree_unstack',
           'flip_edge', 'get_he_length', 'get_signed_dual_he_length', 'flip_by_id', 'flip_all']

# %% ../nbs/03_halfedge_datastructure.ipynb #d159edd4-4456-41f8-b520-8b1b69219c67
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt

import igl
import copy

# %% ../nbs/03_halfedge_datastructure.ipynb #9f1cb15c-86cd-4e64-8f21-d4726216cd2f
import jax
import jax.numpy as jnp

# %% ../nbs/03_halfedge_datastructure.ipynb #723a50d1-f5c2-435c-9026-39b6067f426d
from jaxtyping import Float, Int, Bool, PyTree 
from typing import Any, Iterable, NamedTuple
from pathlib import Path
from enum import IntEnum

import dataclasses

import functools

# %% ../nbs/03_halfedge_datastructure.ipynb #cef3ff0a
from . import trigonometry as trig
from .triangular import TriMesh

# %% ../nbs/03_halfedge_datastructure.ipynb #45616576-ecbd-46f3-998b-ff82c6aa7bef
def label_plot(vertices: Float[jax.Array, "n_vertices 2"],
               faces: Int[jax.Array, "n_faces 3"],
               hemesh: None | PyTree=None,
               vertex_labels: bool = True, face_labels: bool=True,
               ax: None | mpl.axes.Axes=None,
               fontsize: int|None = None) -> None:
    """For debugging purposes. Plot triangular mesh with face/vertex labels in black/blue.
    If hemesh is not None, the connectivity info from it is used to plot the half-edge labels."""
    ax = plt.gca() if ax is None else ax
    if vertex_labels:
        for iv, v in enumerate(vertices):
            ax.text(*(v+np.array([0,.025])), str(iv),
                    color="tab:blue", ha="center", fontsize=fontsize)
    if face_labels:
        for ifc, fc in enumerate(faces):
            centroid = np.mean([vertices[iv] for iv in fc], axis=0)
            ax.text(*centroid, str(ifc), color="k", fontsize=fontsize, ha="center",)
    if hemesh is not None:
        edge_center = (vertices[hemesh.dest] + vertices[hemesh.orig])/2
        for ie in np.where(hemesh.is_unique)[0]:
            ax.text(*edge_center[ie], f"{ie}/{hemesh.twin[ie]}",
            color="tab:orange", ha="center", fontsize=fontsize)
            
    return None

# %% ../nbs/03_halfedge_datastructure.ipynb #0e885259
def get_half_edge_arrays_vectorized(n_vertices: int, faces: Int[jax.Array, "n_faces 3"]) -> list[Int[jax.Array, " n"]]:
    """
    Get half-edge data structure arrays from faces (vectorized).

    Returns: incident, orig, dest, twin, nxt, prv, heface, face_incident
    """
    # form all unique edges, ordered lexicographically
    faces_np = np.asarray(faces)
    edges = np.array(sorted([sorted(x) for x in igl.edges(faces_np)]))
    half_edges = np.vstack([edges, edges[:, ::-1]])

    # initialize the connectivity arrays. origin, destination, and twin are easy
    orig = half_edges[:, 0]
    dest = half_edges[:, 1]
    n_edges = edges.shape[0]
    twin = np.hstack([np.arange(n_edges) + n_edges, np.arange(n_edges)])

    n_hes = half_edges.shape[0]
    nxt = np.ones(n_hes, dtype=orig.dtype)
    prv = np.ones(n_hes, dtype=orig.dtype)
    heface = -1 * np.ones(n_hes, dtype=orig.dtype)

    # build mapping from (orig, dest) -> half-edge index via sorting
    order = np.lexsort((dest, orig))
    half_edges_sorted = half_edges[order]
    dtype = np.dtype([("o", half_edges_sorted.dtype), ("d", half_edges_sorted.dtype)])
    he_view = half_edges_sorted.view(dtype).ravel()

    def lookup(pairs: np.ndarray) -> np.ndarray:
        pairs_view = pairs.view(dtype).ravel()
        pos = np.searchsorted(he_view, pairs_view)
        return order[pos]

    # per-face half-edges (v0->v1, v1->v2, v2->v0)
    v0, v1, v2 = faces_np[:, 0], faces_np[:, 1], faces_np[:, 2]
    pairs0 = np.stack([v0, v1], axis=1)
    pairs1 = np.stack([v1, v2], axis=1)
    pairs2 = np.stack([v2, v0], axis=1)
    h0 = lookup(pairs0)
    h1 = lookup(pairs1)
    h2 = lookup(pairs2)

    ifc = np.arange(faces_np.shape[0])
    heface[h0] = ifc
    heface[h1] = ifc
    heface[h2] = ifc

    nxt[h0] = h1
    nxt[h1] = h2
    nxt[h2] = h0

    prv[h0] = h2
    prv[h1] = h0
    prv[h2] = h1

    # boundary loops (match reference orientation)
    for loop in igl.boundary_loop_all(faces_np):
        loop = np.asarray(loop)
        v_nxt = np.roll(loop, 1)
        v = loop
        v_prv = np.roll(loop, -1)
        hb0 = lookup(np.stack([v_prv, v], axis=1))
        hb1 = lookup(np.stack([v, v_nxt], axis=1))
        nxt[hb0] = hb1
        prv[hb1] = hb0

    # incident half-edge per vertex (minimum index in original ordering)
    order_orig = np.argsort(orig)
    orig_sorted = orig[order_orig]
    first = np.concatenate([[0], np.where(orig_sorted[1:] != orig_sorted[:-1])[0] + 1])
    incident = np.full(n_vertices, -1, dtype=orig.dtype)
    min_idx = np.minimum.reduceat(order_orig, first)
    incident[orig_sorted[first]] = min_idx

    # first half-edge per face (minimum index among the three)
    face_incident = np.minimum(np.minimum(h0, h1), h2)

    return [jnp.array(arr) for arr in [incident, orig, dest, twin, nxt, prv, heface, face_incident]]

# %% ../nbs/03_halfedge_datastructure.ipynb #965577eb-7900-4c5d-8f0a-8cc2fd40caba
@jax.tree_util.register_dataclass
@dataclasses.dataclass(repr=False, eq=False, frozen=True)
class HeMesh:
    """
    Half-edge mesh data structure for triangular meshes.

    A half-edge mesh is described by a set of half-edges and several
    arrays that specify their connectivity (see markup explanation above).
    This class serves as a container for multiple arrays.
    For future compatibility with JAX, after initialization, do not
    modify these arrays in-place; always return a new HeMesh object.
    The mesh vertices may live in whatever dimension - this
    does not affect the connectivity bookkeeping.

    Half-edge meshes are initialized from a list of triangles and a 
    number of vertices, and can return the original triangles (e.g., to save as a .obj).

    All information and methods are purely "combinatorial". The
    HeMesh class does _not_ contain the vertex or face positions.
    These are saved in the GeomHeMesh class that combines
    a HeMesh (combinatorics) with a couple of other arrays (geometry).

    ---Conventions---
    
    For vertices, the `incident` half-edge points _away_ from the vertex.

    To describe the mesh boundary, there are two options:
        1. Initialize from a triangulation with a boundary. Half-edges without
        a face (boundary) are assigned heface=-1.
        2. Initialize from a triangulation without boundary, where certain vertices
         are "at infinity". They should have coordinates [np.inf, np.inf].
         Each infinity vertex corresponds to one boundary. For a single
         boundary, the vertex at infinity is, by convention, the final one.

    Starting from a set of triangles, the half-edges are initialized as follows:
    The 1st N_edges half-edges are (origin_vertex, destination_vertex), in lexicographic order, with 
    origin_vertex < destination_vertex. The 2nd N_edges are their twins, in the same order.

    **Attributes**
    
    incident : Int[jax.Array, "n_vertices"]

    orig : Int[jax.Array, "n_hes"]

    dest : Int[jax.Array, "n_hes"]

    nxt : Int[jax.Array, "n_hes"]

    prv : Int[jax.Array, "n_hes"]

    twin : Int[jax.Array, "n_hes"]

    heface : Int[jax.Array, "n_hes"]

    face_incident : Int[jax.Array, "n_faces"]

    inf_vertices : tuple[Int]

    **Property methods (use like attributes)**

    n_vertices : int

    n_hes : int

    n_faces : int

    n_items : tuple[int, int, int]

    faces : Int[jax.Array, "n_faces 3"]

    has_inf_vertex : bool

    is_inf_face : Bool[jax.Array, "n_faces"]

    is_unique : Bool[jax.Array, "n_hes"]

    is_inf_he : Bool[jax.Array, "n_hes"]

    is_bdry_he : Bool[jax.Array, "n_hes"]

    is_bdry_edge : Bool[jax.Array, "n_hes"]

    is_bdry : Bool[jax.Array, "n_vertices"]

    **Static methods**

    from_triangles : tuple[int, Int[jax.Array, "n_faces 3"], Int[jax.Array, "n_boundaries"] -> HeMesh

    **Class methods**

    iterate_around_vertex : int -> Int[jax.Array, "n_neighbors"]

    save : str -> None:

    **Static methods**
    
    load : str -> HeMesh

    """
    
    incident : Int[jax.Array, "*batch n_vertices"]
    orig : Int[jax.Array, "*batch n_hes"]
    dest : Int[jax.Array, "*batch n_hes"] 
    twin : Int[jax.Array, "*batch n_hes"] 
    nxt : Int[jax.Array, "*batch n_hes"] 
    prv : Int[jax.Array, "*batch n_hes"]
    heface : Int[jax.Array, "*batch n_hes"]
    face_incident : Int[jax.Array, "*batch n_faces"]
    inf_vertices : tuple[()] | tuple[int] = dataclasses.field(default=(), metadata=dict(static=True))

    # convert from and to a list of triangles

    @staticmethod
    def from_triangles(n_vertices: int, faces: Int[jax.Array, "n_faces 3"],
                       inf_vertices: tuple[()] | tuple[int] =()):
        # get HE data arrays
        incident, orig, dest, twin, nxt, prv, heface, face_incident = get_half_edge_arrays_vectorized(n_vertices, faces)
        return HeMesh(incident, orig, dest, twin, nxt, prv, heface, face_incident, inf_vertices)

    @property
    def faces(self) -> Int[jax.Array, "n_faces 3"]:
        """Get faces (list of vertices per face)."""
        return jnp.stack([self.orig[self.face_incident],
                          self.dest[self.face_incident],
                          self.dest[self.nxt[self.face_incident]]], axis=1)
    
    # mesh size info

    @property
    def n_vertices(self) -> int:
        return self.incident.shape[-1]
    
    @property
    def n_hes(self) -> int:
        return self.orig.shape[-1]

    @property
    def n_faces(self) -> int:
        return self.face_incident.shape[-1]
    @property
    def n_items(self) -> tuple[int, int, int]:
        return (self.n_vertices, self.n_hes, self.n_faces)
    
    @property
    def is_unique(self) -> Bool[jax.Array, "n_hes"]:
        """Get an (arbitrary) set of unique half-edges (every edge is represented once)."""
        return self.orig < self.dest

    def __repr__(self) -> str:
        return "HeMesh(N_V={}, N_HE={}, N_F={})".format(*self.n_items)
    
    # boundary info - implemented as class methods to hide "implementation detail" of infinity vertices
    
    @property
    def has_inf_vertex(self) -> bool:
        return len(self.inf_vertices)>0

    @property
    def is_inf_face(self) -> Bool[jax.Array, "n_faces"]:
        """True if face is fictitious/connected to an infinity vertex."""
        return jnp.isin(self.faces, jnp.array(self.inf_vertices)).any(axis=1)

    @property
    def is_inf_he(self) -> Bool[jax.Array, "n_hes"]:
        """True if half-edge is fictitious/connected to an infinity vertex."""
        return jnp.isin(self.orig, jnp.array(self.inf_vertices)) | jnp.isin(self.dest, jnp.array(self.inf_vertices))
    
    @property
    def is_bdry_he(self) -> Bool[jax.Array, "n_hes"]:
        return jax.lax.select(self.has_inf_vertex, jnp.isin(self.dest[self.nxt], jnp.array(self.inf_vertices)), self.heface == -1)

    @property
    def is_bdry_edge(self) -> Bool[jax.Array, "n_hes"]:
        return self.is_bdry_he | self.is_bdry_he[self.twin]
    
    @property
    def is_bdry(self) -> Bool[jax.Array, "n_vertices"]:
        v_field = jnp.zeros(self.n_vertices)
        return v_field.at[self.dest].add(1*self.is_bdry_he) > 0

    # mesh traversal
    
    def iterate_around_vertex(self, v: int) -> Int[jax.Array, " n_neighbors"]:
        """Get list of half-edges going out of a vertex."""
        polygon_edges = [self.incident[v]]
        while True: # this while loop is challenging to rewrite using jax.lax since the output shape is not known!
            next_edge = self.twin[self.prv[polygon_edges[-1]]]
            if next_edge == polygon_edges[0]:
                break
            polygon_edges.append(next_edge)
        return jnp.array(polygon_edges)

    @property
    def bdry_loops(self) -> list[Int[jax.Array, " loop_length"]]:
        return [self.dest[self.iterate_around_vertex(v)] for v in jnp.array(self.inf_vertices)]
        
    # copying, saving, and loading

    def __copy__(self):
        return HeMesh(**dataclasses.asdict(self)) # no need to copy since all entries are immutable
    
    def save(self, file: str | Path) -> None:
        """Save HeMesh to .npz archive of np.arrays"""
        dict_to_save = dataclasses.asdict(self)
        dict_to_save["inf_vertices"] = jnp.array(self.inf_vertices)
        np.savez(file, **dict_to_save, allow_pickle=False)
        return None

    @staticmethod
    def load(file: str | Path) -> "HeMesh":
        dict_to_load = dict(np.load(file))
        dict_to_load["inf_vertices"] = tuple([int(x) for x in dict_to_load["inf_vertices"]])
        return HeMesh(**dict_to_load)

    # equality comparisons. Two meshes are equal if all the arrays they contain are.
    # isomorphic meshes _can_ compare to false if, e.g., the orderings are different.
    
    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, HeMesh):
            return False          
        if not self.inf_vertices == other.inf_vertices:
            return False
        return jax.tree_util.tree_all(jax.tree.map(jnp.allclose, dataclasses.asdict(self), dataclasses.asdict(other))) # compares all array values

# %% ../nbs/03_halfedge_datastructure.ipynb #4378ad6f
def connect_boundary_to_infinity(vertices: Float[jax.Array, "n_vertices 2"],
                                 faces: Int[jax.Array, "n_faces 3"]
                                ) -> tuple[Float[jax.Array, "n_vertices_new 2"],
                                           Int[jax.Array, "n_faces_new 3"],
                                           tuple[int]]:
    """
    Connect boundary loop(s) to infinity.
    
    New vertices are appeneded to the end of vertex array and have coordinates [np.inf, np.inf].

    Parameters 
    ----------
    vertices : Float[jax.Array, "n_vertices 2"]
        Vertex positions.
    faces : Int[jax.Array, "n_faces 2"]
        Faces (triangles) as list of vertex indices.

    Returns
    -------
    new_vertices : Float[jax.Array, "n_vertices_new 2"]
        Vertex positions with infinity vertices appended.
        One infinity vertex per boundary loop.
    new_faces : Int[jax.Array, "n_faces_new 2"]
        Faces (triangles) as list of vertex indices, with new faces added to connect
        boundary loops to infinity vertices.
    inf_vertices : tuple[Int]
        Indices of infinity vertices in new_vertices.
        Will be (n_vertices, n_vertices+1, ..., n_vertices+n_boundaries-1).
    """
    boundary_loops = igl.boundary_loop_all(mesh.faces)
    new_vertices = jnp.copy(vertices)
    new_faces = jnp.copy(faces)

    for loop in boundary_loops:
        inf_index = vertices.shape[0]
        inf_faces = np.stack([[inf_index, v2, v1] for v1, v2 in zip(loop, np.roll(loop, -1))])
        new_vertices = jnp.vstack([new_vertices, jnp.inf*jnp.ones_like(new_vertices[:1])])
        new_faces = jnp.vstack([faces, inf_faces])
    
    return new_vertices, new_faces, tuple(range(vertices.shape[0], new_vertices.shape[0]))

# %% ../nbs/03_halfedge_datastructure.ipynb #c7c0e33c-a06d-4a93-9d88-6aa0716bdf5b
@jax.tree_util.register_dataclass
@dataclasses.dataclass(repr=False, eq=False, frozen=True,)
class GeomMesh:
    """
    Data class for holding mesh geometry and mesh-associated variables.
    To be combined with a HeMesh to specify the connectivity.

    One array (for vertex positions) must always be present. A second,
    but optional, standard entry is a set of positions for each face. 
    The mesh coordinates can live in 2d or 3d.
    
    Optionally, vertices, half-edges, and faces can have attributes (stored as dictionaries).
    The keys of the dictionary should be taken from a suitable 'enum'. The values are 
    ndarrays, whose 0th axis is (vertices/edges/faces). These attribute dicts are
    initialized empty and can be set afterwards.

    See documentation on HeMesh
    
    **Attributes**

    vertices : Float[jax.Array, "n_vertices 2"]

    face_positions : Float[jax.Array, "n_faces 2"]

    vertex_attribs : dict[IntEnum, Float[jax.Array, "n_vertices *"]]

    he_attribs : dict[IntEnum, Float[jax.Array, "n_hes *"]]

    face_attribs : dict[IntEnum, Float[jax.Array, "n_faces *"]]
    
    **Property methods (use like attributes)**

    n_items : tuple[int, int, int]

    dim : int

    **Class methods**

    validate_dimensions : bool

    **Static methods**
    
    load : str -> GeomHeMesh

    """

    n_vertices : int = dataclasses.field(metadata=dict(static=True))
    n_hes : int = dataclasses.field(metadata=dict(static=True))
    n_faces : int = dataclasses.field(metadata=dict(static=True))
    vertices : Float[jax.Array, "*batch n_vertices dim"]
    face_positions : Float[jax.Array, "*batch n_faces 2"] = dataclasses.field(default_factory=lambda : jnp.array([]))
    vertex_attribs : dict[IntEnum, Float[jax.Array, "... n_vertices"]] = dataclasses.field(default_factory=dict)
    he_attribs : dict[IntEnum, Float[jax.Array, "... n_hes"]] = dataclasses.field(default_factory=dict)
    face_attribs : dict[IntEnum, Float[jax.Array, "... n_faces"]] = dataclasses.field(default_factory=dict)
    
    @property
    def n_items(self) -> tuple[int, int, int]:
        return (self.n_vertices, self.n_hes, self.n_faces)

    @property
    def dim(self) -> int:
        return self.vertices.shape[-1]
    
    def __repr__(self) -> str:
        return "GeomMesh(D={},N_V={}, N_HE={}, N_F={})".format(*((self.dim,)+self.n_items))

    def validate_dimensions(self) -> None:
        """Validate input dimensions"""
        if (self.n_vertices != self.vertices.shape[0]):
            raise ValueError("Number of vertices inconsistent")
        if (self.face_positions.shape[0] not in [0, self.n_faces]):
            raise ValueError("Number of faces inconsistent")
        if any([val.shape[0] != self.n_vertices for _, val in self.vertex_attribs.items()]):
            raise ValueError("Vertex property dimension inconsistent")
        if any([val.shape[0] != self.n_hes for _, val in self.he_attribs.items()]):
            raise ValueError("Half-edge property dimension inconsistent")
        if any([val.shape[0] != self.n_faces for _, val in self.face_attribs.items()]):
            raise ValueError("Face property dimension inconsistent")
        return None

    def check_compatibility(self, hemesh: HeMesh) -> bool:
        return self.n_items==hemesh.n_items
    
    ## copying, loading, and saving
    
    def __copy__(self):
        return GeomMesh(*self.n_items, vertices=self.vertices, face_positions=self.face_positions,
                   vertex_attribs={key: jnp.copy(val) for key, val in self.vertex_attribs.items()},
                   he_attribs={key: jnp.copy(val) for key, val in self.he_attribs.items()},
                   face_attribs={key: jnp.copy(val) for key, val in self.face_attribs.items()})

    def save(self, file: str | Path) -> None:
        """Save HeMesh and all geometric attributes to two .npz archives of jnp.arrays"""
        np.savez(file,
             n_vertices=self.n_vertices, n_hes=self.n_hes, n_faces=self.n_faces,
             vertices=self.vertices, face_positions = self.face_positions,
             **{f"VertexAttribs.{key.name}": val for key, val in self.vertex_attribs.items()},
             **{f"HeAttribs.{key.name}": val for key, val in self.he_attribs.items()},
             **{f"FaceAttribs.{key.name}": val for key, val in self.face_attribs.items()},
             allow_pickle=False)
        return None

    @staticmethod
    def load(file: str | Path) -> "GeomMesh":
        """
        Note: vertex/he/face attribute dict's will have _strings_ as keys.
        
        To convert them back to Enums, do something like this:
        dataclasses.replace(geommesh, vertex_attribs={MyEnum[key]: val
                            for key, val in geom_mesh.vertex_attribs.items()})
        """
        npzfile = jnp.load(file)
        vertex_attribs = {key.split(".")[1]: val
                          for key, val  in npzfile.items() if key.split(".")[0] == "VertexAttribs"}
        he_attribs = {key.split(".")[1]: val
                      for key, val  in npzfile.items() if key.split(".")[0] == "HeAttribs"}
        face_attribs = {key.split(".")[1]: val
                        for key, val  in npzfile.items() if key.split(".")[0] == "FaceAttribs"}
        return GeomMesh(n_vertices=npzfile['n_vertices'].item(),
                        n_hes=npzfile['n_hes'].item(),
                        n_faces=npzfile['n_faces'].item(),
                        vertices=npzfile['vertices'],
                        face_positions=npzfile['face_positions'],
                        vertex_attribs=vertex_attribs,
                        he_attribs=he_attribs,
                        face_attribs=face_attribs)

    # equality comparisons. Two meshes are equal if all of the arrays they contain are equal.
    
    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GeomMesh):
            return False          
        if not self.n_items==other.n_items:
            return False
        return jax.tree_util.tree_all(jax.tree.map(jnp.allclose, jax.tree_util.tree_flatten(self)[0],
                                                                 jax.tree_util.tree_flatten(other)[0]))

# %% ../nbs/03_halfedge_datastructure.ipynb #a3a0cf80
def get_voronoi_face_positions(vertices: Float[jax.Array, "n_vertices 2"], hemesh: HeMesh
                               ) -> Float[jax.Array, "n_faces 2"]:
    """Get face positions of geommesh to the circumcenters of the faces defined by hemesh."""
    face_positions = jax.vmap(trig.get_circumcenter)(*vertices[hemesh.faces].transpose((1,0,2)))
    return face_positions

def set_voronoi_face_positions(geommesh: GeomMesh, hemesh: HeMesh) -> GeomMesh:
    """Set face positions of geommesh to the circumcenters of the faces defined by hemesh."""
    face_positions = get_voronoi_face_positions(geommesh.vertices, hemesh)
    return dataclasses.replace(geommesh, face_positions=face_positions)

# %% ../nbs/03_halfedge_datastructure.ipynb #504fefa9-e469-4056-a6b9-a5496b3f6ff3
class Mesh(NamedTuple):
    """Combine geometric and connectivity info into a single object."""
    geommesh: GeomMesh
    hemesh: HeMesh

# %% ../nbs/03_halfedge_datastructure.ipynb #b4ccf185-8b5b-46f9-8d3f-9c7f7d77f516
def cellplot(hemesh: HeMesh, face_positions: Float[jax.Array, "n_faces 2"],
             cell_colors: None | str | Float[np.ndarray, "4"] | Float[np.ndarray, "n_vertices 4"] =None,
             mpl_polygon_kwargs: None | dict[str, Any] = None) -> mpl.collections.PatchCollection:
    """
    Plot a cell tesselation.
    
    cell_colors can be either a single color (for all cells) or a vector of rgba values.
    Only interior cells are plotted.
    """
    if mpl_polygon_kwargs is None:
        mpl_polygon_kwargs = {"lw": 1, "ec": "k"}
    # formatting for the cell colors - make into a list
    if cell_colors is None:
        cell_colors = np.zeros((hemesh.n_vertices, 4))
    if isinstance(cell_colors, str):
        cell_colors = [cell_colors for v in range(hemesh.n_vertices)]
    if isinstance(cell_colors, Iterable):
        assert len(cell_colors) in [4, hemesh.n_vertices], "Cell color must be 1 or n_vertices rgba values"
        if len(cell_colors) == 4:
            cell_colors = [cell_colors for v in range(hemesh.n_vertices)]
    # iterate over non-boundary vertices.
    polygons = []
    bdry = hemesh.is_bdry
    for v in range(hemesh.n_vertices):
        if not bdry[v]:
            polygon_edges = hemesh.iterate_around_vertex(v)
            polygon_vertices = face_positions[hemesh.heface[np.array(polygon_edges)]]
            polygons.append(mpl.patches.Polygon(polygon_vertices, color=cell_colors[v], **mpl_polygon_kwargs))
    return mpl.collections.PatchCollection(polygons, match_original=True)

# %% ../nbs/03_halfedge_datastructure.ipynb #d8e2ff2f
def tree_stack(xs : list[PyTree], axis=0) -> PyTree:
    """Stack a sequence of identical-structure pytrees along a new axis."""
    return jax.tree.map(lambda *leaves: jnp.stack(leaves, axis=axis), *xs)

def tree_unstack(xb: PyTree, axis=0) -> list[PyTree]:
    """Unstack a batched pytree along axis into a list of pytrees."""
    leaves, treedef = jax.tree.flatten(xb)
    B = leaves[0].shape[axis]
    # split every leaf along batch dimension
    per = [jax.tree.unflatten(treedef, [leaf.take(indices=i, axis=axis)  for leaf in leaves])
           for i in range(B)]
    return per

# %% ../nbs/03_halfedge_datastructure.ipynb #2a1c1f7c-4c6e-4312-9820-cf497590c452
@functools.partial(jax.jit, static_argnames=['check_boundary'])
def flip_edge(hemesh: HeMesh, e: Int[jax.Array, ""], check_boundary: bool = False) -> HeMesh:
    """
    Flip half-edge e in a half-edge mesh.
    
    See https://jerryyin.info/geometry-processing-algorithms/half-edge/. The algorithm
    is slightly modified since we keep track of the origin and destination of a half-edge,
    and use arrays instead of pointers. Returns a new HeMesh, does not modify in-place.
    """
    if check_boundary:
        assert (hemesh.heface[e] !=-1 and hemesh.heface[hemesh.twin[e]] != -1), "Cannot flip boundary edge"

    # identify relevant elements
    e5 = hemesh.prv[e]
    e4 = hemesh.nxt[e]
    twin = hemesh.twin[e]
    e1 = hemesh.prv[twin] 
    e0 = hemesh.nxt[twin] 

    # make sure thereâ€™s no vertex or face references to e or twin
    incident = hemesh.incident.at[jnp.array([hemesh.orig[e], hemesh.orig[twin]])].set(
        jnp.array([hemesh.twin[e5], hemesh.twin[e1]]))
    face_incident = hemesh.face_incident.at[jnp.array([hemesh.heface[e], hemesh.heface[twin]])].set(
        jnp.array([e5, e1])) # e1, e5 don't change face

    # update the data structure to do the T1
    nxt = hemesh.nxt.at[jnp.array([e, twin])].set(jnp.array([e5, e1]))
    prv = hemesh.prv.at[jnp.array([e, twin])].set(jnp.array([e0, e4]))
    orig = hemesh.orig.at[jnp.array([e, twin])].set(jnp.array([hemesh.orig[e1], hemesh.orig[e5]]) )
    dest = hemesh.dest.at[jnp.array([e, twin])].set(jnp.array([hemesh.dest[e4], hemesh.dest[e0]]))

    nxt = nxt.at[jnp.array([e0, e1, e4, e5])].set(jnp.array([e, e4, twin, e0]) )
    prv = prv.at[jnp.array([e0, e1, e4, e5])].set(jnp.array([e5, twin, e1, e]) )
    heface = hemesh.heface.at[jnp.array([e0, e4])].set(jnp.array([hemesh.heface[e5], hemesh.heface[e1]]))

    return HeMesh(incident, orig, dest, jnp.copy(hemesh.twin), nxt, prv, heface, face_incident, hemesh.inf_vertices)

# %% ../nbs/03_halfedge_datastructure.ipynb #a5bb78ce-454d-492c-b95e-797d1ed1f2aa
def get_he_length(vertices: Float[jax.Array, "n_vertices dim"],
                    hemesh: HeMesh) -> Float[jax.Array, " n_hes"]:
    """Get lengths of half-edges (triangulation/primal edges)."""
    return jnp.linalg.norm(vertices[hemesh.orig]-vertices[hemesh.dest], axis=-1)

def get_signed_dual_he_length(vertices: Float[jax.Array, "n_vertices 2"],
                              face_positions: Float[jax.Array, "n_faces 2"],
                              hemesh: HeMesh) -> Float[jax.Array, " n_hes"]:
    """Compute lengths of dual edges. Boundary dual edges get length 1. Negative sign = flipped edge."""
    edges = vertices[hemesh.orig]-vertices[hemesh.dest]
    dual_edges = face_positions[hemesh.heface]-face_positions[hemesh.heface[hemesh.twin]]
    signed_squared_length = jnp.einsum('vi,vi->v', edges, dual_edges @ trig.get_rot_mat(np.pi/2))
    signed_length = jnp.sign(signed_squared_length) * jnp.sqrt(jnp.abs(signed_squared_length))
    signed_length = jnp.where(hemesh.is_bdry_edge, 1, signed_length)
    return signed_length

# %% ../nbs/03_halfedge_datastructure.ipynb #242d6ee1-d553-45fc-852f-a80fbb4a589a
@jax.jit
def flip_by_id(hemesh: HeMesh, ids: Int[jax.Array, " flips"], to_flip: Bool[jax.Array, " flips"]) -> HeMesh:
    """Flip half-edges from ids array if the to_flip is True. Wraps flip_edge."""
    def scan_fun(h, x): # flips edge e if its length < 0 and edge is unique. Otherwise, you undo your flips!
        return jax.lax.cond(x[1], lambda hh: flip_edge(hh, x[0]), lambda hh: hh, h), None
    xs = jnp.stack([ids, to_flip], axis=1)  
    flipped_hemesh, _ = jax.lax.scan(scan_fun, init=hemesh, xs=xs)
    return flipped_hemesh

@jax.jit
def flip_all(hemesh: HeMesh, to_flip: Bool[jax.Array, " n_hes"]) -> HeMesh:
    """Flip all (unique) half-edges where to_flip is True in a half-edge mesh. Wraps flip_edge."""
    def scan_fun(h, e): # flips edge e if its length < 0 and edge is unique. Otherwise, you undo your flips!
        return jax.lax.cond(to_flip[e] & hemesh.is_unique[e],
                            lambda hh: flip_edge(hh, e), lambda hh: hh, h), None
    flipped_hemesh, _ = jax.lax.scan(scan_fun, init=hemesh, xs=jnp.arange(hemesh.n_hes) )
    return flipped_hemesh
