# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_adjacency_operators.ipynb.

# %% auto #0
__all__ = ['get_exterior_gradient', 'get_exterior_circulation', 'sum_he_to_vertex_incoming', 'sum_he_to_vertex_opposite',
           'sum_he_to_face', 'sum_face_to_he', 'sum_vertex_to_face', 'average_vertex_to_face', 'sum_face_to_vertex',
           'average_face_to_vertex', 'get_coordination_number', 'compute_uniform_laplacian', 'get_uniform_laplacian']

# %% ../nbs/05_adjacency_operators.ipynb #d159edd4-4456-41f8-b520-8b1b69219c67
import numpy as np
import igl

# %% ../nbs/05_adjacency_operators.ipynb #9f1cb15c-86cd-4e64-8f21-d4726216cd2f
import jax
import jax.numpy as jnp
import jax.experimental.sparse as jsparse

# %% ../nbs/05_adjacency_operators.ipynb #723a50d1-f5c2-435c-9026-39b6067f426d
from jaxtyping import Float 

# %% ../nbs/05_adjacency_operators.ipynb #cef3ff0a
from . import mesh as msh

# %% ../nbs/05_adjacency_operators.ipynb #4a7c1a65
def get_exterior_gradient(hemesh: msh.HeMesh, v_field: Float[jax.Array, "n_vertices ..."]) -> Float[jax.Array, "n_hes ..."]:
    return v_field[hemesh.dest] - v_field[hemesh.orig]

def get_exterior_circulation(hemesh: msh.HeMesh, he_field: Float[jax.Array, "n_hes ..."]) -> Float[jax.Array, "n_faces ..."]:
    return he_field[hemesh.prv[hemesh.face_incident]]+he_field[hemesh.face_incident]+he_field[hemesh.nxt[hemesh.face_incident]] 

# %% ../nbs/05_adjacency_operators.ipynb #8749ff1e
def sum_he_to_vertex_incoming(hemesh: msh.HeMesh, he_field: Float[jax.Array, "n_hes ..."]
                              ) -> Float[jax.Array, "n_vertices ..."]:
    """
    Sum a half-edge field onto destination vertices.

    hemesh: connectivity information
    he_field: (n_hes,) or (n_hes, d) array
    """
    out_shape = (hemesh.n_vertices,) + he_field.shape[1:]  # supports scalar or vector fields
    v_field = jnp.zeros(out_shape, dtype=he_field.dtype)
    # Scatter-add: for each half-edge h, add he_field[h] to v_field[dest[h]]
    return v_field.at[hemesh.dest].add(he_field)

def sum_he_to_vertex_opposite(hemesh: msh.HeMesh, he_field: Float[jax.Array, "n_hes ..."]
                              ) -> Float[jax.Array, "n_vertices ..."]:
    """
    Sum a half-edge field onto opposite vertices.

    Attention: can include boundary half-edges!

    hemesh: connectivity information
    he_field: (n_hes,) or (n_hes, d) array
    """
    out_shape = (hemesh.n_vertices,) + he_field.shape[1:]  # supports scalar or vector fields
    v_field = jnp.zeros(out_shape, dtype=he_field.dtype)
    return v_field.at[hemesh.dest[hemesh.nxt]].add(he_field)


# %% ../nbs/05_adjacency_operators.ipynb #c4634b84
def sum_he_to_face(hemesh: msh.HeMesh, he_field: Float[jax.Array, "n_hes ..."]
                  ) -> Float[jax.Array, "n_faces ..."]:
    """Sum over all half-edges of a face. Alias of get_exterior_circulation."""
    return he_field[hemesh.prv[hemesh.face_incident]]+he_field[hemesh.face_incident]+he_field[hemesh.nxt[hemesh.face_incident]] 

def sum_face_to_he(hemesh: msh.HeMesh, f_field: Float[jax.Array, "n_faces ..."]
                  ) -> Float[jax.Array, "n_hes ..."]:
    """Sum face-field to half-edges. Sums over the face of the half-edge and its twin."""
    return f_field[hemesh.face_incident] + f_field[hemesh.face_incident[hemesh.twin]]

# %% ../nbs/05_adjacency_operators.ipynb #566e2cf7
def sum_vertex_to_face(hemesh: msh.HeMesh, v_field: Float[jax.Array, "n_vertices ..."]
                  ) -> Float[jax.Array, "n_faces ..."]:
    """Sum vertex-field to faces. Sums over the vertices of the face."""
    return (v_field[hemesh.orig[hemesh.face_incident]]
            + v_field[hemesh.dest[hemesh.face_incident]]
            + v_field[hemesh.dest[hemesh.nxt[hemesh.face_incident]]])

def average_vertex_to_face(hemesh: msh.HeMesh, v_field: Float[jax.Array, "n_vertices ..."]
                  ) -> Float[jax.Array, "n_faces ..."]:
    """Average vertex-field to faces."""
    return sum_vertex_to_face(hemesh, v_field) / 3

def sum_face_to_vertex(hemesh: msh.HeMesh, f_field: Float[jax.Array, "n_faces ..."]
                      ) -> Float[jax.Array, "n_vertices ..."]:
    """Sum face-field to vertices. Sums over the faces incident on the vertex."""
    out_shape = (hemesh.n_vertices,) + f_field.shape[1:]  # supports scalar or vector fields
    v_field = jnp.zeros(out_shape, dtype=f_field.dtype)
    v_field = v_field.at[hemesh.orig[hemesh.face_incident]].add(f_field)
    v_field = v_field.at[hemesh.dest[hemesh.face_incident]].add(f_field)
    v_field = v_field.at[hemesh.dest[hemesh.nxt[hemesh.face_incident]]].add(f_field)

    return v_field

def average_face_to_vertex(hemesh: msh.HeMesh, f_field: Float[jax.Array, "n_faces ..."]
                           ) -> Float[jax.Array, "n_vertices ..."]:
    """Average face-field to vertices. Uniform weights."""
    summed_field =  sum_face_to_vertex(hemesh, f_field)
    weights = sum_face_to_vertex(hemesh, jnp.ones(hemesh.n_faces))
    return (summed_field.T / weights.T).T # .T for broadcasting

# %% ../nbs/05_adjacency_operators.ipynb #52d7cd28
def get_coordination_number(hemesh: msh.HeMesh) -> Float[jax.Array, " n_vertices"]:
    return sum_he_to_vertex_incoming(hemesh, jnp.ones(hemesh.n_hes))

# %% ../nbs/05_adjacency_operators.ipynb #f74e78fb
def compute_uniform_laplacian(hemesh: msh.HeMesh, v_field: Float[jax.Array, "n_vertices ..."]
                              ) -> Float[jax.Array, "n_vertices ..."]:
    """Computes the uniform Laplacian of a vector field. Non-normalized, positive definite."""
    he_gradient = get_exterior_gradient(hemesh, v_field)
    return sum_he_to_vertex_incoming(hemesh, he_gradient)

def get_uniform_laplacian(hemesh: msh.HeMesh) -> jsparse.BCOO:
    """Returns the uniform Laplacian matrix as a sparse matrix. Non-normalized, positive definite."""
    row = hemesh.dest
    col = hemesh.orig
    data = -jnp.ones(hemesh.n_hes)
    data_diagonal = get_coordination_number(hemesh)
    row_diagonal, col_diagonal = jnp.arange(hemesh.n_vertices), jnp.arange(hemesh.n_vertices)
    data = jnp.concatenate([data, data_diagonal])
    row, col = jnp.concatenate([row, row_diagonal]), jnp.concatenate([col, col_diagonal])
    L = jsparse.BCOO((data, jnp.stack([row, col], axis=1)), shape=(hemesh.n_vertices, hemesh.n_vertices))
    return L
