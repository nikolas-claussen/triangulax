# triangulax


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

This package provides data-structures for triangular meshes and
functions for geometry processing based on JAX and fully compatible with
JAX’s just-in-time compilation and automatic differentiation.

The current use case is to create a simulation framework for the
mechanics of 2D tissues ([Active tension
networks](https://www.pnas.org/doi/10.1073/pnas.2321928121),
[area-perimeter vertex
model](https://journals.aps.org/prx/abstract/10.1103/PhysRevX.6.021011),
non-confluent tissues like in [Kim,
2021](https://www.nature.com/articles/s41567-021-01215-1)) compatible
with automatic differentiation/JAX. The ultimate goal is to use
gradient-based optimization to identify models for tissue dynamics that
produce certain behaviors of interest.

## Developer Guide

This package is developed based on jupyter notebooks, which are
converted into python modules using `nbdev`.

### Install triangulax in Development mode

1.  Clone the github repository

``` sh
$ git clone https://github.com/nikolas-claussen/triangulax.git
```

2.  Create a conda environment with all Python dependencies

``` sh
$ conda env create -n triangulax -f triangulax.yml
$ conda activate triangulax
```

3.  Install the `triangulax` package

``` sh
# make sure triangulax package is installed in development mode
$ pip install -e .
```

4.  If necessary, edit the package notebooks and export

``` sh
# make changes under nbs/ directory
# ...

# compile to have changes apply to triangulax
$ nbdev_prepare
```

## Usage

### Documentation

Documentation can be found hosted on this GitHub
[repository](https://github.com/nikolas-claussen/triangulax)’s
[pages](https://nikolas-claussen.github.io/triangulax/).

## How to use

Currently, only the `mesh` module is complete. It contains a half-edge
data structure for triangular meshes compatible with JAX.

``` python
import igl
import jax.numpy as jnp
from triangulax import mesh as msh


# load example mesh and convert to half-edge mesh
vertices, _, _, faces, _, _ = igl.readOBJ("test_meshes/disk.obj")
hemesh = msh.HeMesh.from_triangles(vertices.shape[0], faces)

# with the half-edge mesh, you can carry out various operations, like computing the coordination number by summing incoming half-edges per vertex

coord_number = jnp.zeros(hemesh.n_vertices)
coord_number.at[hemesh.dest].add(jnp.ones(hemesh.n_hes))
```

    2
