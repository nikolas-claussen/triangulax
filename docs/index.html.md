# triangulax


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## Developer Guide

This package is developed based on jupyter notebooks, which are
converted into python modules using `nbdev`. Take a look at
`.github/workflows/copilot-instructions.md` for details.

### Install triangulax in Development mode

1.  Clone the github repository

``` sh
$ git clone https://github.com/nikolas-claussen/triangulax.git
```

2.  Create a conda environment with all Python dependencies

``` sh
$ conda env create -n triangulax -f triangulax.yml
$ conda activate triangulax
```

3.  Install the `triangulax` package

``` sh
# make sure triangulax package is installed in development mode
$ pip install -e .
```

4.  If necessary, edit the package notebooks and export

``` sh
# make changes under nbs/ directory
# ...

# compile to have changes apply to triangulax
$ nbdev_prepare
```

## Documentation

Documentation can be found hosted on this GitHub
[repository](https://github.com/nikolas-claussen/triangulax)â€™s
[pages](https://nikolas-claussen.github.io/triangulax/).

## Usage

- The `mesh` module provides a half-edge data structure for triangular
  meshes compatible with JAX.
- The `linops` module provides linear operators on meshes (gradient,
  Laplacian)
- The notebook `nbs/05_example_simulation.ipynb` showcases how to
  simulate mesh dynamics with `triangulax`

### Minimal example

``` python
import igl
import jax
import jax.numpy as jnp
from triangulax import mesh, linops

# load example mesh and convert to half-edge mesh

vertices, _, _, faces, _, _ = igl.readOBJ("test_meshes/disk.obj")
hemesh = mesh.HeMesh.from_triangles(vertices.shape[0], faces)

# with the half-edge mesh, you can carry out various operations, for example
# compute the coordination number by summing incoming half-edges per vertex

coord_number = jnp.zeros(hemesh.n_vertices)
coord_number = coord_number.at[hemesh.dest].add(jnp.ones(hemesh.n_hes))
print("Mean coordination number:", coord_number.mean())

# Let's define a simple geometric function and compute its gradient with JAX

def mean_voronoi_area(vertices, hemesh: mesh.HeMesh) -> float:
    """Compute the mean Voronoi area per vertex."""
    voronoi_areas = linops.get_cell_area(vertices, hemesh)
    return jnp.mean(voronoi_areas)

value, gradient = jax.value_and_grad(mean_voronoi_area)(vertices, hemesh)
print("Mean gradient norm:", jnp.linalg.norm(gradient, axis=1).mean())
```

    Mean coordination number: 5.40458
    Mean gradient norm: 0.009738781

    Warning: readOBJ() ignored non-comment line 3:
      o flat_tri_ecmc
