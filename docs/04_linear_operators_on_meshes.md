

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## Adjacency-like operators on half-edge meshes

Using the
[`HeMesh`](https://nikolas-claussen.github.io/triangulax/halfedge_datastructure.html#hemesh)
data structure, we can efficiently “traverse” our mesh. Using such
traversals, one can express many of the key *linear operators* defined
by the mesh adjacency structure, for example:

- Sum over all half-edges “incoming” to a vertex (special case: *count*
  the incoming edges, i.e., compute the coordination number)
- Compute the finite-element gradient of a function defined on vertices

These operations can be done efficiently using a “gather/scatter”
approach, see
[`jax.numpy.ndarray.at`](https://docs.jax.dev/en/latest/_autosummary/jax.numpy.ndarray.at.html#jax.numpy.ndarray.at).
There is no need to explicitly instantiate a matrix for the operators.

``` python
# load test data

mesh = TriMesh.read_obj("test_meshes/disk.obj")
hemesh = msh.HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)
geommesh = msh.GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)

mesh_3d = TriMesh.read_obj("test_meshes/disk.obj", dim=3)
geommesh_3d = msh.GeomMesh(*hemesh.n_items, mesh_3d.vertices, mesh_3d.face_positions)
```

    Warning: readOBJ() ignored non-comment line 3:
      o flat_tri_ecmc
    Warning: readOBJ() ignored non-comment line 3:
      o flat_tri_ecmc

------------------------------------------------------------------------

<a
href="https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/linops.py#L41"
target="_blank" style="float:right; font-size:smaller">source</a>

### average_faces_to_vertices

``` python

def average_faces_to_vertices(
    hemesh:HeMesh, vertices:Float[Array, 'n_vertices dim'], face_field:Float[Array, 'n_faces ...']
)->Float[Array, 'n_vertices ...']:

```

*Average per-face field onto vertices, weighted by triangle area.*

------------------------------------------------------------------------

<a
href="https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/linops.py#L33"
target="_blank" style="float:right; font-size:smaller">source</a>

### average_vertices_to_faces

``` python

def average_vertices_to_faces(
    hemesh:HeMesh, vertex_field:Float[Array, 'n_vertices ...']
)->Float[Array, 'n_faces ...']:

```

*Average per-vertex field onto faces (uniform weights).*

``` python
# tests vs libigl
key = jax.random.PRNGKey(123)

u_v = jax.random.normal(key, (hemesh.n_vertices,))
faces_avg_jax = average_vertices_to_faces(hemesh, u_v)
faces_avg_igl = igl.average_onto_faces(np.asarray(hemesh.faces), np.asarray(u_v))

rel_err_faces = np.linalg.norm(np.asarray(faces_avg_jax) - faces_avg_igl) / np.linalg.norm(faces_avg_igl)
print("vertex->face rel. error:", rel_err_faces)

u_f = jax.random.normal(key, (hemesh.n_faces,))
verts_avg_jax = average_faces_to_vertices(hemesh, geommesh.vertices, u_f)

# libigl reference using area-weighted averaging
V = np.asarray(geommesh.vertices)
F = np.asarray(hemesh.faces)
areas_np = 0.5 * igl.doublearea(V, F)
accum = np.zeros(hemesh.n_vertices)
area_accum = np.zeros(hemesh.n_vertices)
uf_np = np.asarray(u_f)
for i, f in enumerate(F):
    accum[f] += areas_np[i] * uf_np[i]
    area_accum[f] += areas_np[i]
verts_avg_ref = accum / np.maximum(area_accum, 1e-12)

rel_err_verts = np.linalg.norm(np.asarray(verts_avg_jax) - verts_avg_ref) / np.linalg.norm(verts_avg_ref)
print("face->vertex rel. error:", rel_err_verts)
```

    vertex->face rel. error: 1.0413393664022524e-16
    face->vertex rel. error: 1.3698911362107636e-16

### Computing cell areas, perimeters, etc via corners

To compute, for instance, the cell area using the shoelace formula, you
need to iterate around the faces adjacent to a vertex. This is not
straightforward to vectorize because the number of adjacent faces per
vertex can vary (there can be 5-, 6-, 7-sided cells etc.). One way to
solve this is a scheme in which the lists of adjacent faces are “padded”
in some manner, so that they are all the same length. This is
cumbersome. Instead, let us split all “cell-based” quantities into
contributions from “corners”, i.e., half-edges, like this:

![image.png](04_linear_operators_on_meshes_files/figure-commonmark/9a657caf-1-image.png)
Source:
[CGAL](https://doc.cgal.org/latest/Weights/group__PkgWeightsRefVoronoiRegionWeights.html)

To compute the total area, we can sum over all half-edges (*r*, *p*)
opposite to a vertex *q*. Numerically, this can be achieved efficiently
using gather/scatter operations.

------------------------------------------------------------------------

<a
href="https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/linops.py#L78"
target="_blank" style="float:right; font-size:smaller">source</a>

### sum_he_to_vertex_opposite

``` python

def sum_he_to_vertex_opposite(
    hemesh:HeMesh, he_field:Float[Array, 'n_hes ...']
)->Float[Array, 'n_vertices ...']:

```

*Sum a half-edge field onto opposite vertices.*

Attention: can include boundary half-edges!

hemesh: connectivity information he_field: (n_hes,) or (n_hes, d) array

------------------------------------------------------------------------

<a
href="https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/linops.py#L65"
target="_blank" style="float:right; font-size:smaller">source</a>

### sum_he_to_vertex_incoming

``` python

def sum_he_to_vertex_incoming(
    hemesh:HeMesh, he_field:Float[Array, 'n_hes ...']
)->Float[Array, 'n_vertices ...']:

```

*Sum a half-edge field onto destination vertices.*

hemesh: connectivity information he_field: (n_hes,) or (n_hes, d) array

------------------------------------------------------------------------

<a
href="https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/linops.py#L94"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_cell_areas

``` python

def get_cell_areas(
    geommesh:GeomMesh, hemesh:HeMesh
)->Float[Array, 'n_vertices']:

```

*Compute areas of cells by mesh traversal (don’t use for simulation,
inefficient).*

Boundary vertices get area 0.

``` python
## Let's use the adjacency matrix to compute the area of all cells. First, compute all corner areas

a, b, c = (hemesh.dest[hemesh.nxt], hemesh.dest[hemesh.prv], hemesh.dest)

corner_areas = jax.vmap(trig.get_voronoi_corner_area)(geommesh.vertices[a], geommesh.vertices[b], geommesh.vertices[c])
cell_areas_corner = sum_he_to_vertex_opposite(hemesh, corner_areas)
cell_areas_corner = cell_areas_corner.at[hemesh.is_bdry].set(0)
```

``` python
# for comparison, compute the areas by mesh traversal

cell_areas_iterative = -1*get_cell_areas(geommesh, hemesh)
np.abs(cell_areas_iterative-cell_areas_corner).max() # works!
```

    np.float64(0.42505900310931344)

------------------------------------------------------------------------

<a
href="https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/linops.py#L112"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_coordination_number

``` python

def get_coordination_number(
    hemesh:HeMesh
)->Float[Array, 'n_vertices']:

```

``` python
# using the gather/scatter trick, we can also compute the coordination number of each vertex

get_coordination_number(hemesh)
```

    Array([4., 6., 6., 7., 6., 6., 6., 6., 6., 4., 4., 6., 6., 5., 6., 6., 6.,
           5., 5., 6., 3., 4., 6., 6., 6., 7., 5., 6., 6., 7., 7., 6., 4., 4.,
           3., 7., 6., 6., 5., 7., 6., 6., 6., 6., 7., 5., 4., 5., 5., 6., 6.,
           7., 7., 5., 6., 6., 7., 5., 3., 5., 7., 6., 5., 6., 5., 6., 7., 6.,
           5., 4., 5., 5., 6., 6., 6., 6., 6., 7., 6., 6., 4., 6., 6., 5., 6.,
           4., 4., 6., 6., 6., 7., 4., 6., 6., 6., 5., 6., 6., 6., 4., 4., 6.,
           6., 6., 6., 7., 6., 4., 4., 5., 4., 4., 3., 4., 4., 3., 4., 3., 5.,
           4., 3., 4., 3., 5., 6., 6., 6., 6., 6., 6., 4.], dtype=float64)

------------------------------------------------------------------------

<a
href="https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/linops.py#L131"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_cell_perimeter

``` python

def get_cell_perimeter(
    vertices:Float[Array, 'n_vertices dim'], hemesh:HeMesh
)->Float[Array, 'n_vertices']:

```

*Compute Voronoi perimeters for each vertex.*

------------------------------------------------------------------------

<a
href="https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/linops.py#L120"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_cell_area

``` python

def get_cell_area(
    vertices:Float[Array, 'n_vertices dim'], hemesh:HeMesh
)->Float[Array, 'n_vertices']:

```

*Compute Voronoi area for each vertex.*

------------------------------------------------------------------------

<a
href="https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/linops.py#L116"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_triangle_areas

``` python

def get_triangle_areas(
    vertices:Float[Array, 'n_vertices dim'], hemesh:HeMesh
)->Float[Array, 'n_faces']:

```

*Compute (unsigned) triangle areas in a mesh.*

### Finite-element gradient and cotan-Laplacian

Next, we implement gradient (per-vertex scalar field -\> per-face vector
field) and the cotan-Laplacian (vertex -\> vertex) using gather/scatter
ops like above. The cotan-Laplacian is the discretization of the Laplace
Beltrami operator on a triangular mesh.

In both cases, we start with a scalar field *u*<sub>*i*</sub> defined
per vertex *i* of the triangulation. The finite-element gradient is
defined for each face *i**j**k*, like so:
(∇*u*)<sub>*i**j**k*</sub> = ∑<sub>*l* ∈ {*i*, *j*, *k*}</sub>*u*<sub>*l*</sub>∇*ϕ*<sub>*l*</sub>
where *ϕ*<sub>*i*</sub> is a linear finite element test function (linear
Lagrange element) and has gradient
$$
    \nabla\phi_i = \frac{1}{2a\_{ijk}} (\mathbf{v}\_k-\mathbf{v}\_j)^\perp
$$
plus cyclic permutations. Here, *a*<sub>*i**j**k*</sub> is the triangle
area, **v**<sub>*i*</sub> are the vertex positions, and ()<sup>⟂</sup>
denotes rotation by 90 degrees (in 3D, you rotate about the triangle
normal).

The cot-Laplacian computes the following per-vertex field:
$$
(\Delta u)\_i = \frac{1}{2} \sum\_{j} (\cot\alpha_j +\cot\beta_j) (u_j-u_i)
$$
where the sum is over adjacent vertices, and
*α*<sub>*j*</sub>, *β*<sub>*j*</sub> are the two triangle angles
“opposite” to the edge *i**j*.

To check for correctness, we can compare with [this `libgigl`
tutorial](https://libigl.github.io/libigl-python-bindings/tut-chapter1/),
using the test mesh and some random test fields.

------------------------------------------------------------------------

<a
href="https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/linops.py#L143"
target="_blank" style="float:right; font-size:smaller">source</a>

### compute_cotan_laplace

``` python

def compute_cotan_laplace(
    hemesh:HeMesh, vertices:Float[Array, 'n_vertices dim'], vertex_field:Float[Array, 'n_vertices ...']
)->Float[Array, 'n_vertices ...']:

```

*Compute cotangent laplacian of a per-vertex field (natural boundary
conditions).*

------------------------------------------------------------------------

<a
href="https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/linops.py#L166"
target="_blank" style="float:right; font-size:smaller">source</a>

### cotan_laplace_sparse

``` python

def cotan_laplace_sparse(
    hemesh:HeMesh, vertices:Float[Array, 'n_vertices dim']
)->BCOO:

```

*Assemble cotangent Laplacian as a sparse matrix (BCOO).*

``` python
# Test against libigl cotmatrix (natural boundary conditions)
key = jax.random.PRNGKey(0)
u = jax.random.normal(key, (hemesh.n_vertices,))
u_vec = jax.random.normal(key, (hemesh.n_vertices, 3))

L = igl.cotmatrix(np.asarray(geommesh.vertices), np.asarray(hemesh.faces))

lap_jax = compute_cotan_laplace(hemesh, geommesh.vertices, u)
lap_igl = L @ np.asarray(u)

rel_err = np.linalg.norm(np.asarray(lap_jax) - lap_igl) / np.linalg.norm(lap_igl)
print("scalar field rel. error:", rel_err)

lap_jax_vec = compute_cotan_laplace(hemesh, geommesh.vertices, u_vec)
lap_igl_vec = L @ np.asarray(u_vec)

rel_err_vec = np.linalg.norm(np.asarray(lap_jax_vec) - lap_igl_vec) / np.linalg.norm(lap_igl_vec)
print("vector field rel. error:", rel_err_vec)
```

    scalar field rel. error: 3.678610050757719e-12
    vector field rel. error: 3.659299534118066e-12

``` python
# test sparse cotan Laplacian vs apply function
key = jax.random.PRNGKey(0)
u_test = jax.random.normal(key, (hemesh.n_vertices,))

L_sparse = cotan_laplace_sparse(hemesh, geommesh.vertices)
lap_sparse = L_sparse @ u_test
lap_apply = compute_cotan_laplace(hemesh, geommesh.vertices, u_test)

rel_err_sparse = jnp.linalg.norm(lap_sparse - lap_apply) / jnp.linalg.norm(lap_apply)
print("cotan sparse vs apply rel. error:", rel_err_sparse)
```

    cotan sparse vs apply rel. error: 1.3520071722257924e-16

------------------------------------------------------------------------

<a
href="https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/linops.py#L217"
target="_blank" style="float:right; font-size:smaller">source</a>

### compute_gradient_3d

``` python

def compute_gradient_3d(
    hemesh:HeMesh, vertices:Float[Array, 'n_vertices 3'], vertex_field:Float[Array, 'n_vertices ...']
)->Float[Array, 'n_faces 3 ...']:

```

*Compute the linear finite-element gradient (constant per face).*

------------------------------------------------------------------------

<a
href="https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/linops.py#L193"
target="_blank" style="float:right; font-size:smaller">source</a>

### compute_gradient_2d

``` python

def compute_gradient_2d(
    hemesh:HeMesh, vertices:Float[Array, 'n_vertices 2'], vertex_field:Float[Array, 'n_vertices ...']
)->Float[Array, 'n_faces 2 ...']:

```

*Compute the linear finite-element gradient (constant per face).*

``` python
# here's how to compute the gradient in libigl

grad_matrix = igl.grad(np.asarray(geommesh.vertices), np.asarray(hemesh.faces))
# calculate the gradient of field by matrix multiplication
grad_igl = grad_matrix @ np.asarray(u)
# order='F' copied from igl tutorial
grad_igl = grad_igl.reshape((hemesh.n_faces, geommesh.dim), order='F')
```

``` python
# test jax and libigl implementations

grad_jax = compute_gradient_2d(hemesh, geommesh.vertices, u)

rel_err_grad = np.linalg.norm(np.asarray(grad_jax) - grad_igl) / np.linalg.norm(grad_igl)
print("gradient rel. error:", rel_err_grad)
```

    gradient rel. error: 1.413315746703021e-16

``` python
# same test, in 3d

grad_matrix_3d = igl.grad(np.asarray(geommesh_3d.vertices), np.asarray(hemesh.faces))
grad_igl_3d = grad_matrix_3d @ np.asarray(u)
grad_igl_3d = grad_igl_3d.reshape((hemesh.n_faces, geommesh_3d.dim), order='F')

grad_jax_3d = compute_gradient_3d(hemesh, geommesh_3d.vertices, u)

rel_err_grad_3d = np.linalg.norm(np.asarray(grad_jax_3d) - grad_igl_3d) / np.linalg.norm(grad_igl_3d)
print("gradient rel. error:", rel_err_grad_3d)
```

    gradient rel. error: 1.5657863888820882e-16

### Wrapping as linear operators

It’s often useful to think of functions like
[`compute_cotan_laplace()`](https://nikolas-claussen.github.io/triangulax/linear_operators_on_meshes.html#compute_cotan_laplace)
as a linear operator on fields on meshes. For example, imagine you want
to solve the Laplace equation on a mesh with fixed vertex positions and
connectivity. You will want to use a linear solver. Luckily, most such
solvers only need to be able to compute the action of a linear operator
on an input vector, and don’t need an explicit matrix representation.

In the JAX ecosystem, the `lineax` library defines linear solvers. We
can *wrap*
[`compute_cotan_laplace()`](https://nikolas-claussen.github.io/triangulax/linear_operators_on_meshes.html#compute_cotan_laplace)
as a linear operator, which allows us to pass it into iterative linear
algebra algorithms.

------------------------------------------------------------------------

<a
href="https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/linops.py#L266"
target="_blank" style="float:right; font-size:smaller">source</a>

### diag_jsparse

``` python

def diag_jsparse(
    v:Float[Array, 'N'], k:int=0
)->BCOO:

```

*Construct a diagonal jax.sparse array. Plugin replacement for np.diag*

------------------------------------------------------------------------

<a
href="https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/linops.py#L241"
target="_blank" style="float:right; font-size:smaller">source</a>

### scipy_to_bcoo

``` python

def scipy_to_bcoo(
    A, # Input sparse matrix (CSR or CSC recommended)
)->BCOO: # Equivalent JAX sparse matrix

```

*Convert a SciPy sparse matrix (CSC or CSR) to a JAX BCOO sparse matrix*
without converting to dense.

``` python
mesh = TriMesh.read_obj("test_meshes/disk.obj")

hemesh = msh.HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)
geommesh = msh.GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)
```

    Warning: readOBJ() ignored non-comment line 3:
      o flat_tri_ecmc

``` python
# "bake in" the connectivity and vertex positions

laplace_op = functools.partial(compute_cotan_laplace, hemesh, geommesh.vertices)
_ = laplace_op(u)
```

``` python
# define the linear operator

laplace_op_lx = lineax.FunctionLinearOperator(laplace_op,
                                              input_structure=jax.eval_shape(laplace_op, u))

# now you can use the linear operator to compute matrix representations, solve linear systems, etc.
mat = laplace_op_lx.as_matrix()
mat.shape
```

    (131, 131)

------------------------------------------------------------------------

<a
href="https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/linops.py#L278"
target="_blank" style="float:right; font-size:smaller">source</a>

### linear_op_to_sparse

``` python

def linear_op_to_sparse(
    op:callable, in_shape:tuple, out_shape:tuple, dtype:Union=None, chunk_size:int=256, tol:float=0.0
)->BCOO:

```

*Build a sparse matrix for a linear map using batched one-hot probes.*

Note: this function is general, but not necessarily very efficient for
large matrix sizes.

``` python
# compare sparse construction to lineax dense matrix (small meshes only)
if hemesh.n_vertices <= 2000:
    laplace_op_local = functools.partial(compute_cotan_laplace, hemesh, geommesh.vertices)
    laplace_op_lx_local = lineax.FunctionLinearOperator(laplace_op_local,
                                                        input_structure=jax.eval_shape(laplace_op_local, u))
    sp_mat = linear_op_to_sparse(laplace_op_local, (hemesh.n_vertices,), (hemesh.n_vertices,))
    mat_dense = laplace_op_lx_local.as_matrix()
    rel_err_sparse = jnp.linalg.norm(sp_mat.todense() - mat_dense) / jnp.linalg.norm(mat_dense)
    print("sparse vs lineax rel. error:", rel_err_sparse)
else:
    print("Skipping dense comparison for large mesh.")
```

    Skipping dense comparison for large mesh.

``` python
## now let's try with a large mesh

mesh = TriMesh.read_obj("test_meshes/torus_high_resolution.obj")
hemesh = msh.HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)
geommesh = msh.GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)

laplace_op = jax.jit(functools.partial(compute_cotan_laplace, hemesh, geommesh.vertices))
```

    Warning: readOBJ() ignored non-comment line 3:
      o Torus

``` python
hemesh
```

    HeMesh(N_V=36864, N_HE=221184, N_F=73728)

``` python
sparse_laplace_op =  linear_op_to_sparse(laplace_op, (hemesh.n_vertices,), (hemesh.n_vertices,))
```

``` python
sparse_laplace_op.shape
```

    (36864, 36864)

``` python
igl.cotmatrix(geommesh.vertices, hemesh.faces)
```

    <Compressed Sparse Column sparse matrix of dtype 'float64'
        with 258048 stored elements and shape (36864, 36864)>
