[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "triangulax",
    "section": "",
    "text": "This package is developed based on jupyter notebooks, which are converted into python modules using nbdev. Take a look at .github/workflows/copilot-instructions.md for details.\n\n\n\nClone the github repository\n\n$ git clone https://github.com/nikolas-claussen/triangulax.git\n\nCreate a conda environment with all Python dependencies\n\n$ conda env create -n triangulax -f triangulax.yml\n$ conda activate triangulax\n\nInstall the triangulax package\n\n# make sure triangulax package is installed in development mode\n$ pip install -e .\n\nIf necessary, edit the package notebooks and export\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to triangulax\n$ nbdev_prepare",
    "crumbs": [
      "triangulax"
    ]
  },
  {
    "objectID": "index.html#developer-guide",
    "href": "index.html#developer-guide",
    "title": "triangulax",
    "section": "",
    "text": "This package is developed based on jupyter notebooks, which are converted into python modules using nbdev. Take a look at .github/workflows/copilot-instructions.md for details.\n\n\n\nClone the github repository\n\n$ git clone https://github.com/nikolas-claussen/triangulax.git\n\nCreate a conda environment with all Python dependencies\n\n$ conda env create -n triangulax -f triangulax.yml\n$ conda activate triangulax\n\nInstall the triangulax package\n\n# make sure triangulax package is installed in development mode\n$ pip install -e .\n\nIf necessary, edit the package notebooks and export\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to triangulax\n$ nbdev_prepare",
    "crumbs": [
      "triangulax"
    ]
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "triangulax",
    "section": "Documentation",
    "text": "Documentation\nDocumentation can be found hosted on this GitHub repository’s pages.",
    "crumbs": [
      "triangulax"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "triangulax",
    "section": "Usage",
    "text": "Usage\n\nThe mesh module provides a half-edge data structure for triangular meshes compatible with JAX.\nThe linops module provides linear operators on meshes (gradient, Laplacian)\nThe notebook nbs/05_example_simulation.ipynb showcases how to simulate mesh dynamics with triangulax\n\n\nMinimal example\n\nimport igl\nimport jax\nimport jax.numpy as jnp\nfrom triangulax import mesh, linops\n\n# load example mesh and convert to half-edge mesh\n\nvertices, _, _, faces, _, _ = igl.readOBJ(\"test_meshes/disk.obj\")\nhemesh = mesh.HeMesh.from_triangles(vertices.shape[0], faces)\n\n# with the half-edge mesh, you can carry out various operations, for example\n# compute the coordination number by summing incoming half-edges per vertex\n\ncoord_number = jnp.zeros(hemesh.n_vertices)\ncoord_number = coord_number.at[hemesh.dest].add(jnp.ones(hemesh.n_hes))\nprint(\"Mean coordination number:\", coord_number.mean())\n\n# Let's define a simple geometric function and compute its gradient with JAX\n\ndef mean_voronoi_area(vertices, hemesh: mesh.HeMesh) -&gt; float:\n    \"\"\"Compute the mean Voronoi area per vertex.\"\"\"\n    voronoi_areas = linops.get_cell_area(vertices, hemesh)\n    return jnp.mean(voronoi_areas)\n\nvalue, gradient = jax.value_and_grad(mean_voronoi_area)(vertices, hemesh)\nprint(\"Mean gradient norm:\", jnp.linalg.norm(gradient, axis=1).mean())\n\nMean coordination number: 5.40458\nMean gradient norm: 0.009738781\n\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc",
    "crumbs": [
      "triangulax"
    ]
  },
  {
    "objectID": "01_triangular_meshes.html",
    "href": "01_triangular_meshes.html",
    "title": "triangulax",
    "section": "",
    "text": "triangulax is a library for working with triangular meshes using JAX. In this notebook, however, we define some tools for loading, processing, and saving triangular meshes outside of JAX. The dataclass TriMesh keeps the different pieces of a triangulation in one place. The use case of this module is to interface with JAX-external code, like the excellent igl geometry processing library, prepare initial conditions for simulations, etc. The data structure for JAX-based code is defined in the mesh module, notebook 03.\nThe simplest way to represent a triangulation is by a list of vertices and faces (triangles):\n\nA set of vertices, i.e., a \\((N_V, 2)\\) dimensional array datatype float.\nA set of faces, a \\((N_F, 3)\\) dimensional array of datatype int. Each row is an ordered triple of vertex indices that form a face.\n(Optional) A set of face centers, a \\((N_F, 2)\\) dimensional array of datatype float. An entry is the position of the dual vertex of a the triangulation face (think circumcenter).\n\nTo read and write, we use the .obj-file format. We will also make heavy use of the igl geometry processing library. The TriMesh class is a “holder” for loading, saving, visualizing, etc meshes, and not to be used for numerical computation. .\n\n\nOne use case of triangulax is simulations of 2D cell tilings. The simplest way to represent a cell tiling is by its dual triangular mesh (one triangulation vertex per cell). We will represent cell tilings by 2D Voronoi tessellations and variants thereof (like power diagrams). This means that we can represent the cell network as a 2D triangulation with vertices \\(V\\) and faces \\(F\\). We will first consider the case where the number of vertices does not change. Cells can, however, rearrange (T1-transitions/edge flips in the triangulation). Such flips also conserve the number of faces and edges.\n\nsource\n\n\n\n\ndef TriMesh(\n    vertices:Float[Array, 'n_vertices dim'], faces:Int[Array, 'n_faces 3'], face_positions:Union=None\n)-&gt;None:\n\nSimple class for reading, holding, transforming, and saving triangular meshes.\nA TriMesh comprises vertices and faces, describing a surface in 2d or 3d. In addition, there can be a 2d/3d position for every face (think Voronoi dual of the triangulation).\nVertices and faces are jnp.arrays. Each face is a triple of vertex indices. Vertices and faces are ordered - this is essential so that we know which attribute vector entry goes to which vector/edge/face. Faces in a face are assumed to be in counter-clockwise order.\nMeshes are read and written in the .obj format (https://en.wikipedia.org/wiki/Wavefront_.obj_file). To store face_positions, we abuse the vn (vertex normal) entry of an .obj file. Face positions will be written in order corresponding to faces. When reading from an .obj file, edges are recomputed from faces and initialized in alpha-numerical ordering. An .obj file expects 3d positions; the z-position is ignored when reading and set to 0 when writing for 2d meshes.\nAttributes\ndim : int = 2\nvertices : Float[jax.Array, “n_vertices dim”]\nfaces : Int[jax.Array, “n_faces 3”]\nface_positions : Float[jax.Array, “n_faces dim”]\nProperty methods (use like attributes)\nn_vertices : int\nhas_inf_vertex : bool\nStatic methods\nread_obj : str -&gt; TriMesh\nMethods\nwrite_obj : str -&gt; None\n\n# test reading a mesh\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.float64'&gt; requested in array is not available, and will be truncated to dtype float32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.int64'&gt; requested in array is not available, and will be truncated to dtype int32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)\n\n\n\n# test computing the circumcenter of each face. should be equidistant to all vertex points\n\ndists = jnp.stack([jnp.linalg.norm(mesh.vertices[mesh.faces[:,i]]-mesh.face_positions, axis=1) for i in [0,1,2]], axis=1)\n\njnp.allclose(dists[:,0], dists[:,1]) and jnp.allclose(dists[:,1], dists[:,2])\n\nArray(True, dtype=bool)\n\n\n\n# test writing face positions to vn entries\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nfilename = \"test_meshes/disk_write_test.obj\"\nmesh.write_obj(filename, save_face_positions=True)\nmesh = TriMesh.read_obj(filename, read_face_positions=True)\n\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.float64'&gt; requested in array is not available, and will be truncated to dtype float32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.int64'&gt; requested in array is not available, and will be truncated to dtype int32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)\n\n\n\n\n\nSome functions to create meshes based on the Delaunay triangulation of a point set.\n\nPoisson (vertices placed uniformly at random) in disk or box\nGinibre (vertices placed at uniform with self-repulsion)\nTriangular lattice\n\nSome functions for plotting meshes:\n\nPlot triangulation with vertex and face labels (for debugging)\nPlot cell tesselation\n\n\nsource\n\n\n\n\ndef generate_triangular_lattice(\n    nx:int, ny:int\n)-&gt;Float[Array, 'nx*ny 2']:\n\nGet points for rectangular patch of triangular lattice with nx, ny points.\n\nsource\n\n\n\n\ndef generate_poisson_points(\n    n_vertices:int, limit_x:float=1, limit_y:float=1\n)-&gt;Float[Array, 'n_vertices 2']:\n\nSample n_vertices points from the Poisson ensemble in rectangle [-limit_x/2, limit_x/2] * [-limit_y/2, limit_y/2].\n\nsource\n\n\n\n\ndef generate_ginibre_points(\n    n_vertices:int\n)-&gt;Float[Array, 'n_vertices 2']:\n\nSample n_vertices points from the Ginibre ensemble. Points are scaled to unit disk.\n\n#points = generate_triangular_lattice(10, 10)\n\npoints = generate_ginibre_points(100)\nmesh = TriMesh(vertices=points, faces=jnp.array(spatial.Delaunay(points).simplices))\n\nplt.triplot(*points.T, mesh.faces)\n\nplt.scatter(*points.T)\nplt.axis(\"equal\")\n\n(np.float64(-1.6629634499549866),\n np.float64(1.632395327091217),\n np.float64(-1.5740285992622376),\n np.float64(1.561158287525177))\n\n\n\n\n\n\n\n\n\n\n\n\n\nsource\n\n\n\n\ndef get_adjacent_vertex_indices(\n    faces:Int[Array, 'n_faces 3'], n_vertices:int\n)-&gt;list:\n\nFor each vertex, get the indices of the adjacent vertices in correct order. For boundary vertices, this list contains the vertex itself.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\nneighbors = get_adjacent_vertex_indices(mesh.faces, mesh.n_vertices)\n\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.float64'&gt; requested in array is not available, and will be truncated to dtype float32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.int64'&gt; requested in array is not available, and will be truncated to dtype int32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)",
    "crumbs": [
      "Loading, processing, and saving triangular meshes"
    ]
  },
  {
    "objectID": "01_triangular_meshes.html#loading-processing-and-saving-triangular-meshes",
    "href": "01_triangular_meshes.html#loading-processing-and-saving-triangular-meshes",
    "title": "triangulax",
    "section": "",
    "text": "triangulax is a library for working with triangular meshes using JAX. In this notebook, however, we define some tools for loading, processing, and saving triangular meshes outside of JAX. The dataclass TriMesh keeps the different pieces of a triangulation in one place. The use case of this module is to interface with JAX-external code, like the excellent igl geometry processing library, prepare initial conditions for simulations, etc. The data structure for JAX-based code is defined in the mesh module, notebook 03.\nThe simplest way to represent a triangulation is by a list of vertices and faces (triangles):\n\nA set of vertices, i.e., a \\((N_V, 2)\\) dimensional array datatype float.\nA set of faces, a \\((N_F, 3)\\) dimensional array of datatype int. Each row is an ordered triple of vertex indices that form a face.\n(Optional) A set of face centers, a \\((N_F, 2)\\) dimensional array of datatype float. An entry is the position of the dual vertex of a the triangulation face (think circumcenter).\n\nTo read and write, we use the .obj-file format. We will also make heavy use of the igl geometry processing library. The TriMesh class is a “holder” for loading, saving, visualizing, etc meshes, and not to be used for numerical computation. .\n\n\nOne use case of triangulax is simulations of 2D cell tilings. The simplest way to represent a cell tiling is by its dual triangular mesh (one triangulation vertex per cell). We will represent cell tilings by 2D Voronoi tessellations and variants thereof (like power diagrams). This means that we can represent the cell network as a 2D triangulation with vertices \\(V\\) and faces \\(F\\). We will first consider the case where the number of vertices does not change. Cells can, however, rearrange (T1-transitions/edge flips in the triangulation). Such flips also conserve the number of faces and edges.\n\nsource\n\n\n\n\ndef TriMesh(\n    vertices:Float[Array, 'n_vertices dim'], faces:Int[Array, 'n_faces 3'], face_positions:Union=None\n)-&gt;None:\n\nSimple class for reading, holding, transforming, and saving triangular meshes.\nA TriMesh comprises vertices and faces, describing a surface in 2d or 3d. In addition, there can be a 2d/3d position for every face (think Voronoi dual of the triangulation).\nVertices and faces are jnp.arrays. Each face is a triple of vertex indices. Vertices and faces are ordered - this is essential so that we know which attribute vector entry goes to which vector/edge/face. Faces in a face are assumed to be in counter-clockwise order.\nMeshes are read and written in the .obj format (https://en.wikipedia.org/wiki/Wavefront_.obj_file). To store face_positions, we abuse the vn (vertex normal) entry of an .obj file. Face positions will be written in order corresponding to faces. When reading from an .obj file, edges are recomputed from faces and initialized in alpha-numerical ordering. An .obj file expects 3d positions; the z-position is ignored when reading and set to 0 when writing for 2d meshes.\nAttributes\ndim : int = 2\nvertices : Float[jax.Array, “n_vertices dim”]\nfaces : Int[jax.Array, “n_faces 3”]\nface_positions : Float[jax.Array, “n_faces dim”]\nProperty methods (use like attributes)\nn_vertices : int\nhas_inf_vertex : bool\nStatic methods\nread_obj : str -&gt; TriMesh\nMethods\nwrite_obj : str -&gt; None\n\n# test reading a mesh\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.float64'&gt; requested in array is not available, and will be truncated to dtype float32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.int64'&gt; requested in array is not available, and will be truncated to dtype int32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)\n\n\n\n# test computing the circumcenter of each face. should be equidistant to all vertex points\n\ndists = jnp.stack([jnp.linalg.norm(mesh.vertices[mesh.faces[:,i]]-mesh.face_positions, axis=1) for i in [0,1,2]], axis=1)\n\njnp.allclose(dists[:,0], dists[:,1]) and jnp.allclose(dists[:,1], dists[:,2])\n\nArray(True, dtype=bool)\n\n\n\n# test writing face positions to vn entries\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nfilename = \"test_meshes/disk_write_test.obj\"\nmesh.write_obj(filename, save_face_positions=True)\nmesh = TriMesh.read_obj(filename, read_face_positions=True)\n\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.float64'&gt; requested in array is not available, and will be truncated to dtype float32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.int64'&gt; requested in array is not available, and will be truncated to dtype int32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)\n\n\n\n\n\nSome functions to create meshes based on the Delaunay triangulation of a point set.\n\nPoisson (vertices placed uniformly at random) in disk or box\nGinibre (vertices placed at uniform with self-repulsion)\nTriangular lattice\n\nSome functions for plotting meshes:\n\nPlot triangulation with vertex and face labels (for debugging)\nPlot cell tesselation\n\n\nsource\n\n\n\n\ndef generate_triangular_lattice(\n    nx:int, ny:int\n)-&gt;Float[Array, 'nx*ny 2']:\n\nGet points for rectangular patch of triangular lattice with nx, ny points.\n\nsource\n\n\n\n\ndef generate_poisson_points(\n    n_vertices:int, limit_x:float=1, limit_y:float=1\n)-&gt;Float[Array, 'n_vertices 2']:\n\nSample n_vertices points from the Poisson ensemble in rectangle [-limit_x/2, limit_x/2] * [-limit_y/2, limit_y/2].\n\nsource\n\n\n\n\ndef generate_ginibre_points(\n    n_vertices:int\n)-&gt;Float[Array, 'n_vertices 2']:\n\nSample n_vertices points from the Ginibre ensemble. Points are scaled to unit disk.\n\n#points = generate_triangular_lattice(10, 10)\n\npoints = generate_ginibre_points(100)\nmesh = TriMesh(vertices=points, faces=jnp.array(spatial.Delaunay(points).simplices))\n\nplt.triplot(*points.T, mesh.faces)\n\nplt.scatter(*points.T)\nplt.axis(\"equal\")\n\n(np.float64(-1.6629634499549866),\n np.float64(1.632395327091217),\n np.float64(-1.5740285992622376),\n np.float64(1.561158287525177))\n\n\n\n\n\n\n\n\n\n\n\n\n\nsource\n\n\n\n\ndef get_adjacent_vertex_indices(\n    faces:Int[Array, 'n_faces 3'], n_vertices:int\n)-&gt;list:\n\nFor each vertex, get the indices of the adjacent vertices in correct order. For boundary vertices, this list contains the vertex itself.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\nneighbors = get_adjacent_vertex_indices(mesh.faces, mesh.n_vertices)\n\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.float64'&gt; requested in array is not available, and will be truncated to dtype float32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.int64'&gt; requested in array is not available, and will be truncated to dtype int32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)",
    "crumbs": [
      "Loading, processing, and saving triangular meshes"
    ]
  },
  {
    "objectID": "02_coding_in_JAX_notes.html",
    "href": "02_coding_in_JAX_notes.html",
    "title": "Coding in JAX",
    "section": "",
    "text": "triangulax aims to create a triangulation datastructure compatible with the JAX library for automatic differentiation and numerical computing (see JAX- the sharp bits). What does this mean in practice?\nTo provide type signatures for all functions (what are the inputs? what do the array dimensions mean?), we use jaxtyping. Lateron, we will alsop use the equinox library, which adds a few useful tools to JAX.",
    "crumbs": [
      "Coding in JAX"
    ]
  },
  {
    "objectID": "02_coding_in_JAX_notes.html#simulation-loops-with-jax.lax.scan",
    "href": "02_coding_in_JAX_notes.html#simulation-loops-with-jax.lax.scan",
    "title": "Coding in JAX",
    "section": "Simulation loops with jax.lax.scan",
    "text": "Simulation loops with jax.lax.scan\nIn simulations, we generally start with an initial state (call it init), do a series of timesteps (via a function make_step(state)), and record some “measurement” at each timestep (via a measure(state) function). As a result, we get a timeseries of measurements, and the final simulation state. In normal python, you would do that with a for loop. When working with JAX, we need to replace control-flow operations like for with their JAX pendant. For for loops, this is jax.lax.scan(f, init, xs), which is equivalent to the python code\ndef scan(f, init, xs):\n  carry = init\n  ys = []\n  for x in xs:\n    carry, y = f(carry, x)\n    ys.append(y)\n  return carry, np.stack(ys)\nIn our pattern, xs is the vector of time-points timepoints, and the “scanning-function” f is generally comprised of two parts, a time-step and a measurement/logging step (above, we logged energy and T1 count):\ndef f(carry, t):\n    new_state = make_step(carry, t)\n    measurements = measure(new_state)\n    return new_state, measurements\nThe carry variable contains all information about the state of the simulation. Typically, carry is also composed of multiple pieces (the, the physical state physical_state, as well as ancilliary variables like the ODE solver state solver_state). To keep things organized, it can make sense to define dataclasses for the simulation state and the measurements, like this (schematic) example:\n@jax.tree_util.register_dataclass\n@dataclass\nclass SimState:\n    physical_state: jax.Array\n    solver_state: dict  # or another PyTree\n    current_time: jax.Array\n\n@jax.tree_util.register_dataclass\n@dataclass\nclass Log:\n    energy: float\n\ndef scan_function(carry: SimState, next_time: jax.Array) -&gt; tuple[SimState, Log]:\n    physical_state, solver_state = make_step(carry.physical_state, carry.solver_state,\n                                             carry.current_time, next_time)\n    log = Log(energy=compute_energy(physical_state))\n    return SimState(physical_state, solver_state), log\n\ntimepoints = jnp.arange(t0, t1, dt)\ninit = ... # define initial condition\nfinal_state, measurements = jax.lax.scan(scan_function, init, timepoints)",
    "crumbs": [
      "Coding in JAX"
    ]
  },
  {
    "objectID": "03_halfedge_datastructure.html",
    "href": "03_halfedge_datastructure.html",
    "title": "triangulax",
    "section": "",
    "text": "In the TriMesh class, we represent a mesh a list of triangles. However, many common operations are difficult with this data structure. For example, how do you get all the neighbors of a given vertex, or compute the area of a dual cell?\nFor simulation and geometry processing, we need a different representation of the adjacency information. Typically, this is achieved by a half-edge mesh (HE) data structure. We represent the HE data structure by 3 sets of integer index arrays:\n\nVertices: 1 \\((N_V,)\\) matrix, whose entry for vertex \\(i\\) is an arbitrary HE incident on \\(i\\)\nEdges: 6 \\((2N_E,)\\) matrices, [origin, dest, nxt, prv, twin, face] for each half-edge (face is undefined for boundary half-edges).\nFaces, 1 \\((N_F, 1)\\) matrix, whose entry for face \\(i\\) is an arbitrary HE in \\(i\\). (Not to be confused with the \\((N_F, 3)\\) matrix of vertex IDs used previously).\n\nAdditionally, there are two float arrays for vertex and face positions, as previously. However, we split combinatorial and geometric information - a HeMesh class for the combinatorics, and a couple of regular arrays for the vertex positions, face positions, and vertex/half-edge/face attributes. The latter are packaged into a GeomMesh class. Together, the pair (GeomMesh, HeMesh) describes a mesh (like vertices/faces pair). A named tuple Mesh comines the two.\nThe first task is to create a helper function to plot mesh connectivity, and to create the half-edge connectivity matrices from the more conventional list-of-triangles format. The latter is somewhat involved.\nWe follow the notes in notebook 02 to ensure JAX compatibility.\n\nsource\n\n\n\ndef label_plot(\n    vertices:Float[Array, 'n_vertices 2'], faces:Int[Array, 'n_faces 3'], hemesh:Union=None, vertex_labels:bool=True,\n    face_labels:bool=True, ax:Union=None, fontsize:Union=None\n)-&gt;None:\n\nFor debugging purposes. Plot triangular mesh with face/vertex labels in black/blue. If hemesh is not None, the connectivity info from it is used to plot the half-edge labels.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\nplt.triplot(*mesh.vertices.T, mesh.faces)\nlabel_plot(mesh.vertices, mesh.faces, fontsize=10)\nplt.axis(\"equal\")\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n(np.float64(-1.10003475),\n np.float64(1.09628575),\n np.float64(-1.09934025),\n np.float64(1.09050125))\n\n\n\n\n\n\n\n\n\n\nsource\n\n\n\n\ndef get_half_edge_arrays_vectorized(\n    n_vertices:int, faces:Int[Array, 'n_faces 3']\n)-&gt;list:\n\nGet half-edge data structure arrays from faces (vectorized).\nReturns: incident, orig, dest, twin, nxt, prv, heface, face_incident\n\nmesh_high_res = TriMesh.read_obj(\"test_meshes/torus_high_resolution.obj\")\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\nWarning: readOBJ() ignored non-comment line 3:\n  o Torus\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\nresults = get_half_edge_arrays(mesh.vertices.shape[0], mesh.faces)\n\n61.8 ms ± 496 μs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n\n\n\n# test vectorized vs reference implementation for two meshes\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nref = get_half_edge_arrays(mesh.vertices.shape[0], mesh.faces)\nfast = get_half_edge_arrays_vectorized(mesh.vertices.shape[0], mesh.faces)\n\nprint(\"Equal?\", all([jnp.array_equal(a, b) for a, b in zip(ref, fast)]))\n\nmesh = TriMesh.read_obj(\"test_meshes/sphere.obj\")\nref = get_half_edge_arrays(mesh.vertices.shape[0], mesh.faces)\nfast = get_half_edge_arrays_vectorized(mesh.vertices.shape[0], mesh.faces)\n\nprint(\"Equal?\", all([jnp.array_equal(a, b) for a, b in zip(ref, fast)]))\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\nWarning: readOBJ() ignored non-comment line 3:\n  o Icosphere\n\n\nEqual? True\nEqual? True\n\n\n\nfast = get_half_edge_arrays_vectorized(mesh.vertices.shape[0], mesh.faces)\n\n776 μs ± 13.8 μs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n\n\n\nfast = get_half_edge_arrays_vectorized(mesh_high_res.vertices.shape[0], mesh_high_res.faces)\n\nCPU times: user 228 ms, sys: 12.7 ms, total: 240 ms\nWall time: 233 ms\n\n\n\nsource\n\n\n\n\ndef HeMesh(\n    incident:Int[Array, '*batch n_vertices'], orig:Int[Array, '*batch n_hes'], dest:Int[Array, '*batch n_hes'],\n    twin:Int[Array, '*batch n_hes'], nxt:Int[Array, '*batch n_hes'], prv:Int[Array, '*batch n_hes'],\n    heface:Int[Array, '*batch n_hes'], face_incident:Int[Array, '*batch n_faces'], inf_vertices:Union=()\n)-&gt;None:\n\nHalf-edge mesh data structure for triangular meshes.\nA half-edge mesh is described by a set of half-edges and several arrays that specify their connectivity (see markup explanation above). This class serves as a container for multiple arrays. For future compatibility with JAX, after initialization, do not modify these arrays in-place; always return a new HeMesh object. The mesh vertices may live in whatever dimension - this does not affect the connectivity bookkeeping.\nHalf-edge meshes are initialized from a list of triangles and a number of vertices, and can return the original triangles (e.g., to save as a .obj).\nAll information and methods are purely “combinatorial”. The HeMesh class does not contain the vertex or face positions. These are saved in the GeomHeMesh class that combines a HeMesh (combinatorics) with a couple of other arrays (geometry).\n—Conventions—\nFor vertices, the incident half-edge points away from the vertex.\nTo describe the mesh boundary, there are two options: 1. Initialize from a triangulation with a boundary. Half-edges without a face (boundary) are assigned heface=-1. 2. Initialize from a triangulation without boundary, where certain vertices are “at infinity”. They should have coordinates [np.inf, np.inf]. Each infinity vertex corresponds to one boundary. For a single boundary, the vertex at infinity is, by convention, the final one.\nStarting from a set of triangles, the half-edges are initialized as follows: The 1st N_edges half-edges are (origin_vertex, destination_vertex), in lexicographic order, with origin_vertex &lt; destination_vertex. The 2nd N_edges are their twins, in the same order.\nAttributes\nincident : Int[jax.Array, “n_vertices”]\norig : Int[jax.Array, “n_hes”]\ndest : Int[jax.Array, “n_hes”]\nnxt : Int[jax.Array, “n_hes”]\nprv : Int[jax.Array, “n_hes”]\ntwin : Int[jax.Array, “n_hes”]\nheface : Int[jax.Array, “n_hes”]\nface_incident : Int[jax.Array, “n_faces”]\ninf_vertices : tuple[Int]\nProperty methods (use like attributes)\nn_vertices : int\nn_hes : int\nn_faces : int\nn_items : tuple[int, int, int]\nfaces : Int[jax.Array, “n_faces 3”]\nhas_inf_vertex : bool\nis_inf_face : Bool[jax.Array, “n_faces”]\nis_unique : Bool[jax.Array, “n_hes”]\nis_inf_he : Bool[jax.Array, “n_hes”]\nis_bdry_he : Bool[jax.Array, “n_hes”]\nis_bdry_edge : Bool[jax.Array, “n_hes”]\nis_bdry : Bool[jax.Array, “n_vertices”]\nStatic methods\nfrom_triangles : tuple[int, Int[jax.Array, “n_faces 3”], Int[jax.Array, “n_boundaries”] -&gt; HeMesh\nClass methods\niterate_around_vertex : int -&gt; Int[jax.Array, “n_neighbors”]\nsave : str -&gt; None:\nStatic methods\nload : str -&gt; HeMesh\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\n# hemeshes can be compared for equali and are registered as py-trees\n\nleafs, ts = jax.tree_util.tree_flatten(hemesh)\n\nhemesh, hemesh == hemesh\n\n(HeMesh(N_V=131, N_HE=708, N_F=224), True)\n\n\n\n# test iteration around vertex\nhemesh.dest[hemesh.iterate_around_vertex(69)], hemesh.orig[hemesh.iterate_around_vertex(56)]\n\n(Array([80, 68, 56, 46], dtype=int64),\n Array([56, 56, 56, 56, 56, 56, 56], dtype=int64))\n\n\n\n# boundary in cc-wise order\n(hemesh.orig[187], hemesh.dest[187]), hemesh.heface[187], hemesh.is_bdry_he[187],\n\n((Array(58, dtype=int64), Array(70, dtype=int64)),\n Array(-1, dtype=int64),\n Array(True, dtype=bool))\n\n\n\nhemesh.is_bdry_he[187], hemesh.is_bdry_he[541], hemesh.heface[541]\n\n(Array(True, dtype=bool), Array(False, dtype=bool), Array(145, dtype=int64))\n\n\n\n# to model mesh boundaries, we can add an \"infinity\" vertex. Not done here, see below\nhemesh.has_inf_vertex, hemesh.inf_vertices\n\n(False, ())\n\n\n\nfig = plt.figure(figsize=(14,14))\n\nplt.triplot(*mesh.vertices.T, hemesh.faces)\nlabel_plot(mesh.vertices, hemesh.faces, fontsize=10, hemesh=hemesh, face_labels=False)\nplt.axis(\"equal\")\n\n(np.float64(-1.10003475),\n np.float64(1.09628575),\n np.float64(-1.09934025),\n np.float64(1.09050125))\n\n\n\n\n\n\n\n\n\n\n# here is how you would do mesh traversal with jax.lax. The issues is that the output size needs to be fixed\n# ahead of time, so \n\nself = hemesh\nmax_valence = 10\nv = 10\n\ninitial = jnp.hstack([jnp.array([self.incident[v]]), -1*jnp.ones(max_valence-1, dtype=int)])\njax.lax.fori_loop(1, max_valence, lambda i, x: x.at[i].set(self.twin[x[i-1]]), initial)\n\nArray([ 47, 401,  47, 401,  47, 401,  47, 401,  47, 401], dtype=int64)\n\n\n\n\n\nSo far, our mesh representations TriMesh and HeMesh work for triangular meshes with and without boundary. In the HeMesh class, boundary half-edges are assigned to a fictitious -1 face. This convention has a downside. It is not possible to modify the boundary loop of the mesh by edge flips - doing so would result in an invalid state. In a simulation, this artificially limits the mesh’s ability to deform. Instead, we can add “vertices at infinity” and connect al edges in a given boundary to \\(\\infty\\). This turns the mesh into a topological sphere. Now, one can flip boundary edges without the overall number of half-edges changing (so the array shape stays the same). Multiple boundaries are also supported. Each boundary corresponds to a distinct \\(\\infty\\)-vertex (for example, 2 for a cylinder).\nThe coordinates of the fictitious vertices are set to [np.inf, np.inf] by convention. The boundary is found by iterating around \\(\\infty\\). By convention, \\(\\infty\\)-vertices, if they exists, are the final vertices of the mesh (don’t rely on this - implementation detail).\nWe generally assume that the mesh has only a single connected component.\nThe HeMesh class can deal with both the -1-face and the \\(\\infty\\)-vertices conventions. The latter are listed in the inf_vertices attribute of a HeMesh.\n\nsource\n\n\n\n\ndef connect_boundary_to_infinity(\n    vertices:Float[Array, 'n_vertices 2'], # Vertex positions.\n    faces:Int[Array, 'n_faces 3'], # Faces (triangles) as list of vertex indices.\n)-&gt;tuple: # Vertex positions with infinity vertices appended.\nOne infinity vertex per boundary loop.\n\nConnect boundary loop(s) to infinity.\nNew vertices are appeneded to the end of vertex array and have coordinates [np.inf, np.inf].\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\nnew_vertices, new_faces, infinity_vertices = connect_boundary_to_infinity(mesh.vertices, mesh.faces)\nmesh_infty = TriMesh(vertices=new_vertices, faces=new_faces)\nhemesh_infty = HeMesh.from_triangles(mesh_infty.vertices.shape[0], mesh_infty.faces,\n                                     inf_vertices=infinity_vertices)\n\n\nigl.is_edge_manifold(mesh_infty.faces)[0], igl.is_vertex_manifold(mesh_infty.faces)[0]\n\n(True, np.True_)\n\n\n\nhemesh_infty.dest[hemesh_infty.iterate_around_vertex(-1)], igl.boundary_loop(mesh.faces)\n\n(Array([  0,  10,  21,  34,  47,  58,  70,  86,  91, 100, 108, 113, 114,\n        110, 111, 112, 107,  99,  85,  80,  69,  46,  33,  32,  20,   9,\n        130, 121, 120, 119, 118, 117, 116, 115, 123, 122], dtype=int64),\n array([  0, 122, 123, 115, 116, 117, 118, 119, 120, 121, 130,   9,  20,\n         32,  33,  46,  69,  80,  85,  99, 107, 112, 111, 110, 114, 113,\n        108, 100,  91,  86,  70,  58,  47,  34,  21,  10], dtype=int64))\n\n\n\nhemesh_infty.dest[hemesh_infty.iterate_around_vertex(0)], hemesh.dest[hemesh.iterate_around_vertex(0)]\n\n(Array([  1,  11,  10, 131, 122], dtype=int64),\n Array([  1,  11,  10, 122], dtype=int64))\n\n\n\n(hemesh.is_bdry == (hemesh_infty.is_bdry[:-1] &gt;0)).all()\n\nArray(True, dtype=bool)\n\n\n\n# to get back the original faces/vertices, do this:\n\n_ = hemesh_infty.faces[~hemesh_infty.is_inf_face]",
    "crumbs": [
      "Half-edge meshes"
    ]
  },
  {
    "objectID": "03_halfedge_datastructure.html#half-edge-meshes",
    "href": "03_halfedge_datastructure.html#half-edge-meshes",
    "title": "triangulax",
    "section": "",
    "text": "In the TriMesh class, we represent a mesh a list of triangles. However, many common operations are difficult with this data structure. For example, how do you get all the neighbors of a given vertex, or compute the area of a dual cell?\nFor simulation and geometry processing, we need a different representation of the adjacency information. Typically, this is achieved by a half-edge mesh (HE) data structure. We represent the HE data structure by 3 sets of integer index arrays:\n\nVertices: 1 \\((N_V,)\\) matrix, whose entry for vertex \\(i\\) is an arbitrary HE incident on \\(i\\)\nEdges: 6 \\((2N_E,)\\) matrices, [origin, dest, nxt, prv, twin, face] for each half-edge (face is undefined for boundary half-edges).\nFaces, 1 \\((N_F, 1)\\) matrix, whose entry for face \\(i\\) is an arbitrary HE in \\(i\\). (Not to be confused with the \\((N_F, 3)\\) matrix of vertex IDs used previously).\n\nAdditionally, there are two float arrays for vertex and face positions, as previously. However, we split combinatorial and geometric information - a HeMesh class for the combinatorics, and a couple of regular arrays for the vertex positions, face positions, and vertex/half-edge/face attributes. The latter are packaged into a GeomMesh class. Together, the pair (GeomMesh, HeMesh) describes a mesh (like vertices/faces pair). A named tuple Mesh comines the two.\nThe first task is to create a helper function to plot mesh connectivity, and to create the half-edge connectivity matrices from the more conventional list-of-triangles format. The latter is somewhat involved.\nWe follow the notes in notebook 02 to ensure JAX compatibility.\n\nsource\n\n\n\ndef label_plot(\n    vertices:Float[Array, 'n_vertices 2'], faces:Int[Array, 'n_faces 3'], hemesh:Union=None, vertex_labels:bool=True,\n    face_labels:bool=True, ax:Union=None, fontsize:Union=None\n)-&gt;None:\n\nFor debugging purposes. Plot triangular mesh with face/vertex labels in black/blue. If hemesh is not None, the connectivity info from it is used to plot the half-edge labels.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\nplt.triplot(*mesh.vertices.T, mesh.faces)\nlabel_plot(mesh.vertices, mesh.faces, fontsize=10)\nplt.axis(\"equal\")\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n(np.float64(-1.10003475),\n np.float64(1.09628575),\n np.float64(-1.09934025),\n np.float64(1.09050125))\n\n\n\n\n\n\n\n\n\n\nsource\n\n\n\n\ndef get_half_edge_arrays_vectorized(\n    n_vertices:int, faces:Int[Array, 'n_faces 3']\n)-&gt;list:\n\nGet half-edge data structure arrays from faces (vectorized).\nReturns: incident, orig, dest, twin, nxt, prv, heface, face_incident\n\nmesh_high_res = TriMesh.read_obj(\"test_meshes/torus_high_resolution.obj\")\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\nWarning: readOBJ() ignored non-comment line 3:\n  o Torus\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\nresults = get_half_edge_arrays(mesh.vertices.shape[0], mesh.faces)\n\n61.8 ms ± 496 μs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n\n\n\n# test vectorized vs reference implementation for two meshes\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nref = get_half_edge_arrays(mesh.vertices.shape[0], mesh.faces)\nfast = get_half_edge_arrays_vectorized(mesh.vertices.shape[0], mesh.faces)\n\nprint(\"Equal?\", all([jnp.array_equal(a, b) for a, b in zip(ref, fast)]))\n\nmesh = TriMesh.read_obj(\"test_meshes/sphere.obj\")\nref = get_half_edge_arrays(mesh.vertices.shape[0], mesh.faces)\nfast = get_half_edge_arrays_vectorized(mesh.vertices.shape[0], mesh.faces)\n\nprint(\"Equal?\", all([jnp.array_equal(a, b) for a, b in zip(ref, fast)]))\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\nWarning: readOBJ() ignored non-comment line 3:\n  o Icosphere\n\n\nEqual? True\nEqual? True\n\n\n\nfast = get_half_edge_arrays_vectorized(mesh.vertices.shape[0], mesh.faces)\n\n776 μs ± 13.8 μs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n\n\n\nfast = get_half_edge_arrays_vectorized(mesh_high_res.vertices.shape[0], mesh_high_res.faces)\n\nCPU times: user 228 ms, sys: 12.7 ms, total: 240 ms\nWall time: 233 ms\n\n\n\nsource\n\n\n\n\ndef HeMesh(\n    incident:Int[Array, '*batch n_vertices'], orig:Int[Array, '*batch n_hes'], dest:Int[Array, '*batch n_hes'],\n    twin:Int[Array, '*batch n_hes'], nxt:Int[Array, '*batch n_hes'], prv:Int[Array, '*batch n_hes'],\n    heface:Int[Array, '*batch n_hes'], face_incident:Int[Array, '*batch n_faces'], inf_vertices:Union=()\n)-&gt;None:\n\nHalf-edge mesh data structure for triangular meshes.\nA half-edge mesh is described by a set of half-edges and several arrays that specify their connectivity (see markup explanation above). This class serves as a container for multiple arrays. For future compatibility with JAX, after initialization, do not modify these arrays in-place; always return a new HeMesh object. The mesh vertices may live in whatever dimension - this does not affect the connectivity bookkeeping.\nHalf-edge meshes are initialized from a list of triangles and a number of vertices, and can return the original triangles (e.g., to save as a .obj).\nAll information and methods are purely “combinatorial”. The HeMesh class does not contain the vertex or face positions. These are saved in the GeomHeMesh class that combines a HeMesh (combinatorics) with a couple of other arrays (geometry).\n—Conventions—\nFor vertices, the incident half-edge points away from the vertex.\nTo describe the mesh boundary, there are two options: 1. Initialize from a triangulation with a boundary. Half-edges without a face (boundary) are assigned heface=-1. 2. Initialize from a triangulation without boundary, where certain vertices are “at infinity”. They should have coordinates [np.inf, np.inf]. Each infinity vertex corresponds to one boundary. For a single boundary, the vertex at infinity is, by convention, the final one.\nStarting from a set of triangles, the half-edges are initialized as follows: The 1st N_edges half-edges are (origin_vertex, destination_vertex), in lexicographic order, with origin_vertex &lt; destination_vertex. The 2nd N_edges are their twins, in the same order.\nAttributes\nincident : Int[jax.Array, “n_vertices”]\norig : Int[jax.Array, “n_hes”]\ndest : Int[jax.Array, “n_hes”]\nnxt : Int[jax.Array, “n_hes”]\nprv : Int[jax.Array, “n_hes”]\ntwin : Int[jax.Array, “n_hes”]\nheface : Int[jax.Array, “n_hes”]\nface_incident : Int[jax.Array, “n_faces”]\ninf_vertices : tuple[Int]\nProperty methods (use like attributes)\nn_vertices : int\nn_hes : int\nn_faces : int\nn_items : tuple[int, int, int]\nfaces : Int[jax.Array, “n_faces 3”]\nhas_inf_vertex : bool\nis_inf_face : Bool[jax.Array, “n_faces”]\nis_unique : Bool[jax.Array, “n_hes”]\nis_inf_he : Bool[jax.Array, “n_hes”]\nis_bdry_he : Bool[jax.Array, “n_hes”]\nis_bdry_edge : Bool[jax.Array, “n_hes”]\nis_bdry : Bool[jax.Array, “n_vertices”]\nStatic methods\nfrom_triangles : tuple[int, Int[jax.Array, “n_faces 3”], Int[jax.Array, “n_boundaries”] -&gt; HeMesh\nClass methods\niterate_around_vertex : int -&gt; Int[jax.Array, “n_neighbors”]\nsave : str -&gt; None:\nStatic methods\nload : str -&gt; HeMesh\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\n# hemeshes can be compared for equali and are registered as py-trees\n\nleafs, ts = jax.tree_util.tree_flatten(hemesh)\n\nhemesh, hemesh == hemesh\n\n(HeMesh(N_V=131, N_HE=708, N_F=224), True)\n\n\n\n# test iteration around vertex\nhemesh.dest[hemesh.iterate_around_vertex(69)], hemesh.orig[hemesh.iterate_around_vertex(56)]\n\n(Array([80, 68, 56, 46], dtype=int64),\n Array([56, 56, 56, 56, 56, 56, 56], dtype=int64))\n\n\n\n# boundary in cc-wise order\n(hemesh.orig[187], hemesh.dest[187]), hemesh.heface[187], hemesh.is_bdry_he[187],\n\n((Array(58, dtype=int64), Array(70, dtype=int64)),\n Array(-1, dtype=int64),\n Array(True, dtype=bool))\n\n\n\nhemesh.is_bdry_he[187], hemesh.is_bdry_he[541], hemesh.heface[541]\n\n(Array(True, dtype=bool), Array(False, dtype=bool), Array(145, dtype=int64))\n\n\n\n# to model mesh boundaries, we can add an \"infinity\" vertex. Not done here, see below\nhemesh.has_inf_vertex, hemesh.inf_vertices\n\n(False, ())\n\n\n\nfig = plt.figure(figsize=(14,14))\n\nplt.triplot(*mesh.vertices.T, hemesh.faces)\nlabel_plot(mesh.vertices, hemesh.faces, fontsize=10, hemesh=hemesh, face_labels=False)\nplt.axis(\"equal\")\n\n(np.float64(-1.10003475),\n np.float64(1.09628575),\n np.float64(-1.09934025),\n np.float64(1.09050125))\n\n\n\n\n\n\n\n\n\n\n# here is how you would do mesh traversal with jax.lax. The issues is that the output size needs to be fixed\n# ahead of time, so \n\nself = hemesh\nmax_valence = 10\nv = 10\n\ninitial = jnp.hstack([jnp.array([self.incident[v]]), -1*jnp.ones(max_valence-1, dtype=int)])\njax.lax.fori_loop(1, max_valence, lambda i, x: x.at[i].set(self.twin[x[i-1]]), initial)\n\nArray([ 47, 401,  47, 401,  47, 401,  47, 401,  47, 401], dtype=int64)\n\n\n\n\n\nSo far, our mesh representations TriMesh and HeMesh work for triangular meshes with and without boundary. In the HeMesh class, boundary half-edges are assigned to a fictitious -1 face. This convention has a downside. It is not possible to modify the boundary loop of the mesh by edge flips - doing so would result in an invalid state. In a simulation, this artificially limits the mesh’s ability to deform. Instead, we can add “vertices at infinity” and connect al edges in a given boundary to \\(\\infty\\). This turns the mesh into a topological sphere. Now, one can flip boundary edges without the overall number of half-edges changing (so the array shape stays the same). Multiple boundaries are also supported. Each boundary corresponds to a distinct \\(\\infty\\)-vertex (for example, 2 for a cylinder).\nThe coordinates of the fictitious vertices are set to [np.inf, np.inf] by convention. The boundary is found by iterating around \\(\\infty\\). By convention, \\(\\infty\\)-vertices, if they exists, are the final vertices of the mesh (don’t rely on this - implementation detail).\nWe generally assume that the mesh has only a single connected component.\nThe HeMesh class can deal with both the -1-face and the \\(\\infty\\)-vertices conventions. The latter are listed in the inf_vertices attribute of a HeMesh.\n\nsource\n\n\n\n\ndef connect_boundary_to_infinity(\n    vertices:Float[Array, 'n_vertices 2'], # Vertex positions.\n    faces:Int[Array, 'n_faces 3'], # Faces (triangles) as list of vertex indices.\n)-&gt;tuple: # Vertex positions with infinity vertices appended.\nOne infinity vertex per boundary loop.\n\nConnect boundary loop(s) to infinity.\nNew vertices are appeneded to the end of vertex array and have coordinates [np.inf, np.inf].\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\nnew_vertices, new_faces, infinity_vertices = connect_boundary_to_infinity(mesh.vertices, mesh.faces)\nmesh_infty = TriMesh(vertices=new_vertices, faces=new_faces)\nhemesh_infty = HeMesh.from_triangles(mesh_infty.vertices.shape[0], mesh_infty.faces,\n                                     inf_vertices=infinity_vertices)\n\n\nigl.is_edge_manifold(mesh_infty.faces)[0], igl.is_vertex_manifold(mesh_infty.faces)[0]\n\n(True, np.True_)\n\n\n\nhemesh_infty.dest[hemesh_infty.iterate_around_vertex(-1)], igl.boundary_loop(mesh.faces)\n\n(Array([  0,  10,  21,  34,  47,  58,  70,  86,  91, 100, 108, 113, 114,\n        110, 111, 112, 107,  99,  85,  80,  69,  46,  33,  32,  20,   9,\n        130, 121, 120, 119, 118, 117, 116, 115, 123, 122], dtype=int64),\n array([  0, 122, 123, 115, 116, 117, 118, 119, 120, 121, 130,   9,  20,\n         32,  33,  46,  69,  80,  85,  99, 107, 112, 111, 110, 114, 113,\n        108, 100,  91,  86,  70,  58,  47,  34,  21,  10], dtype=int64))\n\n\n\nhemesh_infty.dest[hemesh_infty.iterate_around_vertex(0)], hemesh.dest[hemesh.iterate_around_vertex(0)]\n\n(Array([  1,  11,  10, 131, 122], dtype=int64),\n Array([  1,  11,  10, 122], dtype=int64))\n\n\n\n(hemesh.is_bdry == (hemesh_infty.is_bdry[:-1] &gt;0)).all()\n\nArray(True, dtype=bool)\n\n\n\n# to get back the original faces/vertices, do this:\n\n_ = hemesh_infty.faces[~hemesh_infty.is_inf_face]",
    "crumbs": [
      "Half-edge meshes"
    ]
  },
  {
    "objectID": "03_halfedge_datastructure.html#mesh-geometry-and-per-mesh-variables",
    "href": "03_halfedge_datastructure.html#mesh-geometry-and-per-mesh-variables",
    "title": "triangulax",
    "section": "Mesh geometry and per-mesh variables",
    "text": "Mesh geometry and per-mesh variables\nMesh geometry (vertex and face positions) and per-mesh-item (per-face, per-half-edge, per-vertex) variables are combined into a second data class, the GeomMesh.\n\nsource\n\nGeomMesh\n\ndef GeomMesh(\n    n_vertices:int, n_hes:int, n_faces:int, vertices:Float[Array, '*batch n_vertices dim'],\n    face_positions:Float[Array, '*batch n_faces 2']=&lt;factory&gt;, vertex_attribs:dict=&lt;factory&gt;,\n    he_attribs:dict=&lt;factory&gt;, face_attribs:dict=&lt;factory&gt;\n)-&gt;None:\n\nData class for holding mesh geometry and mesh-associated variables. To be combined with a HeMesh to specify the connectivity.\nOne array (for vertex positions) must always be present. A second, but optional, standard entry is a set of positions for each face. The mesh coordinates can live in 2d or 3d.\nOptionally, vertices, half-edges, and faces can have attributes (stored as dictionaries). The keys of the dictionary should be taken from a suitable ‘enum’. The values are ndarrays, whose 0th axis is (vertices/edges/faces). These attribute dicts are initialized empty and can be set afterwards.\nSee documentation on HeMesh\nAttributes\nvertices : Float[jax.Array, “n_vertices 2”]\nface_positions : Float[jax.Array, “n_faces 2”]\nvertex_attribs : dict[IntEnum, Float[jax.Array, “n_vertices *”]]\nhe_attribs : dict[IntEnum, Float[jax.Array, “n_hes *”]]\nface_attribs : dict[IntEnum, Float[jax.Array, “n_faces *”]]\nProperty methods (use like attributes)\nn_items : tuple[int, int, int]\ndim : int\nClass methods\nvalidate_dimensions : bool\nStatic methods\nload : str -&gt; GeomHeMesh\n\nsource\n\n\nset_voronoi_face_positions\n\ndef set_voronoi_face_positions(\n    geommesh:GeomMesh, hemesh:HeMesh\n)-&gt;GeomMesh:\n\nSet face positions of geommesh to the circumcenters of the faces defined by hemesh.\n\nsource\n\n\nget_voronoi_face_positions\n\ndef get_voronoi_face_positions(\n    vertices:Float[Array, 'n_vertices 2'], hemesh:HeMesh\n)-&gt;Float[Array, 'n_faces 2']:\n\nGet face positions of geommesh to the circumcenters of the faces defined by hemesh.\n\nsource\n\n\nMesh\n\ndef Mesh(\n    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD\n):\n\nCombine geometric and connectivity info into a single object.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)\ncombined_mesh = Mesh(geommesh, hemesh)\ncombined_mesh\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\nMesh(geommesh=GeomMesh(D=2,N_V=131, N_HE=708, N_F=224), hemesh=HeMesh(N_V=131, N_HE=708, N_F=224))\n\n\n\nleafs, ts = jax.tree_util.tree_flatten(geommesh) # also a pytree\nts\n\nPyTreeDef(CustomNode(GeomMesh[(131, 708, 224)], [*, *, {}, {}, {}]))\n\n\n\ngeommesh, geommesh.n_vertices, geommesh.vertices.shape, geommesh.check_compatibility(hemesh), geommesh == geommesh\n\n(GeomMesh(D=2,N_V=131, N_HE=708, N_F=224), 131, (131, 2), True, True)\n\n\n\nsource\n\n\ncellplot\n\ndef cellplot(\n    hemesh:HeMesh, face_positions:Float[Array, 'n_faces 2'], cell_colors:Union=None, mpl_polygon_kwargs:Union=None\n)-&gt;PatchCollection:\n\nPlot a cell tesselation.\ncell_colors can be either a single color (for all cells) or a vector of rgba values. Only interior cells are plotted.\n\nplt.triplot(*geommesh.vertices.T, hemesh.faces)\npolygons = cellplot(hemesh, geommesh.face_positions,\n                    cell_colors=np.array([0,0,1,0.5]), mpl_polygon_kwargs={\"lw\": 1, \"ec\": \"k\"})\nax = plt.gca()\nax.add_collection(polygons)\n\nplt.axis(\"equal\")\n\n(np.float64(-1.10003475),\n np.float64(1.09628575),\n np.float64(-1.09934025),\n np.float64(1.09050125))\n\n\n\n\n\n\n\n\n\n\n\nVertex, half-edge, and face properties\nIn simulations, we will often want to attach extra information to a mesh’s vertices/edges/faces. In the GeomMesh class, these are saved in three dictionaries, vertex_attribs, he_attribs, face_attribs. Each key/value pair represents one property (for example, the cell target area). All values are arrays, and the first axis corresponds to the number of vertices/half-edges/faces, respectively. To keep track of the possible attributes, we use IntEnum’s as keys (this also ensures keys are hashable, as required by JAX)\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommmesh = GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\n# this is how you set up an enum. It is important to use IntEnum, so we can _order_ the enums.\n# The precise Enum you will use depends on your application.\n\nclass VertexAttribs(IntEnum):\n    TARGET_AREA = 1\n    TARGET_PERIMETER = 2\n\nclass HeAttribs(IntEnum):\n    EDGE_TENSION = 1\n\nclass FaceAttribs(IntEnum):\n    FACE_AREA = 1\n\n\n# you can iterate over enums, and they are hashable. The latter is essential for JAX!\nprint([a for a in VertexAttribs])\n# there are multiple ways to access enum entries:\nhash(VertexAttribs.TARGET_PERIMETER), HeAttribs.EDGE_TENSION, HeAttribs['EDGE_TENSION'], HeAttribs.EDGE_TENSION.name\n\n[&lt;VertexAttribs.TARGET_AREA: 1&gt;, &lt;VertexAttribs.TARGET_PERIMETER: 2&gt;]\n\n\n(2, &lt;HeAttribs.EDGE_TENSION: 1&gt;, &lt;HeAttribs.EDGE_TENSION: 1&gt;, 'EDGE_TENSION')\n\n\n\n# at initialization, a HeMesh's attribute dictionaries are empty\ngeommmesh.vertex_attribs\n\n{}\n\n\n\n# set some attributes\n\nkey1 = jax.random.key(0)\n_, key2 = jax.random.split(key1)\n_, key3 = jax.random.split(key2)\n\ngeommmesh = dataclasses.replace(geommmesh, vertex_attribs={VertexAttribs.TARGET_AREA: jax.random.normal(key=key1,shape=geommmesh.n_vertices),\n                                                           VertexAttribs.TARGET_PERIMETER: jax.random.normal(key=key2, shape=geommmesh.n_vertices)})\ngeommmesh = dataclasses.replace(geommmesh, he_attribs={HeAttribs.EDGE_TENSION: jax.random.normal(key=key3, shape=geommmesh.n_hes)})\n\n\ngeommmesh.he_attribs.keys()\n\ndict_keys([&lt;HeAttribs.EDGE_TENSION: 1&gt;])",
    "crumbs": [
      "Half-edge meshes"
    ]
  },
  {
    "objectID": "03_halfedge_datastructure.html#batching",
    "href": "03_halfedge_datastructure.html#batching",
    "title": "triangulax",
    "section": "Batching",
    "text": "Batching\nIn our simulations, we may want to “batch” over several initial conditions/random seeds/etc (analogous to batching over training data in normal ML). In JAX, we can efficiently and concisely vectorize operations over such “batch axes” with jax.vmap.\nTo batch over our custom data structures, we need to pull a small trick - convert a list of HeMesh/GeomMeshe instances into a single mesh with a batch axis for the various arrays. Luckily, this can be done using JAX’s pytree tools. The resulting meshes have an extra “batch” axis in all their array.\n\nsource\n\ntree_unstack\n\ndef tree_unstack(\n    xb:PyTree, axis:int=0\n)-&gt;list:\n\nUnstack a batched pytree along axis into a list of pytrees.\n\nsource\n\n\ntree_stack\n\ndef tree_stack(\n    xs:list, axis:int=0\n)-&gt;PyTree:\n\nStack a sequence of identical-structure pytrees along a new axis.\n\n## Let us create a bunch of meshes with different initial positions and see if we can batch over them using vmap\n\nkey = jax.random.key(0)\nsigma = 0.02\n\nbatch_geom = []\nbatch_he = []\nfor i in range(3):\n    key, subkey = jax.random.split(key)\n    random_noise = jax.random.normal(subkey, shape=geommmesh.vertices.shape)\n    batch_geom.append(dataclasses.replace(geommmesh, vertices=geommmesh.vertices+sigma*random_noise))\n    batch_he.append(copy.copy(hemesh))\n\n\n# define a test function to appy over the batch\n\ndef test_function(geommesh: GeomMesh, hemesh: HeMesh) -&gt; Float[jax.Array, \" n_vertices\"]:\n    \"\"\"Dummy test function.\"\"\"\n    return jnp.ones(geommesh.n_vertices)\n\n\n# naive batching does not work. JAX needs a \"struct-of-arrays\", but a list of HeMeshes is an \"array-of-structs\"\n# see https://stackoverflow.com/questions/79123001/storing-and-jax-vmap-over-pytrees\n\ntry:\n    jax.vmap(test_function)(batch_geom, batch_he)\nexcept ValueError as e:\n    print(\"Expected error:\", e)\n\nExpected error: vmap got inconsistent sizes for array axes to be mapped:\n  * most axes (21 of them) had size 708, e.g. axis 0 of argument geommesh[0].he_attribs[&lt;HeAttribs.EDGE_TENSION: 1&gt;] of type float64[708];\n  * some axes (12 of them) had size 131, e.g. axis 0 of argument geommesh[0].vertices of type float64[131,2];\n  * some axes (6 of them) had size 224, e.g. axis 0 of argument geommesh[0].face_positions of type float64[224,2]\n\n\n\n# instead, we use a jax.tree.map to \"push\" the list axis into the underlying arrays.\n# the resulting meshes have an extra batch dimension in all of their arrays.\n\nbatch_he_array = tree_stack(batch_he)\nbatch_geom_array = tree_stack(batch_geom)\nbatch_he_array, batch_geom_array, batch_geom_array.vertices.shape\n\n(HeMesh(N_V=131, N_HE=708, N_F=224),\n GeomMesh(D=2,N_V=131, N_HE=708, N_F=224),\n (3, 131, 2))\n\n\n\n# now it works! The result is a single object with batch axis\n\nbatch_out =jax.vmap(test_function)(batch_geom_array, batch_he_array)\nbatch_out.shape\n\n(3, 131)\n\n\n\n# we can unpack things again into a list of meshes\n\nisinstance(tree_unstack(batch_out), list)\n\nTrue",
    "crumbs": [
      "Half-edge meshes"
    ]
  },
  {
    "objectID": "03_halfedge_datastructure.html#edge-flips-t1s",
    "href": "03_halfedge_datastructure.html#edge-flips-t1s",
    "title": "triangulax",
    "section": "Edge flips / T1s",
    "text": "Edge flips / T1s\nIn our simulations, cells will exchange neighbors (T1-event). In the triangulation, this corresponds to an edge flip. We now implement the edge flip algorithm for HeMeshes. We basically edit the various connectivity arrays (in a JAX-compatible way).\nThe algorithm (and the naming conventions in flip_edge) are from here.\nBefore\n\n\n\nimage.png\n\n\nAfter\n\n\n\nimage.png\n\n\n\nsource\n\nflip_edge\n\ndef flip_edge(\n    hemesh:HeMesh, e:Int[Array, ''], check_boundary:bool=False\n)-&gt;HeMesh:\n\nFlip half-edge e in a half-edge mesh.\nSee https://jerryyin.info/geometry-processing-algorithms/half-edge/. The algorithm is slightly modified since we keep track of the origin and destination of a half-edge, and use arrays instead of pointers. Returns a new HeMesh, does not modify in-place.\n\nsource\n\n\nget_signed_dual_he_length\n\ndef get_signed_dual_he_length(\n    vertices:Float[Array, 'n_vertices 2'], face_positions:Float[Array, 'n_faces 2'], hemesh:HeMesh\n)-&gt;Float[Array, 'n_hes']:\n\nCompute lengths of dual edges. Boundary dual edges get length 1. Negative sign = flipped edge.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\nplt.triplot(*geommesh.vertices.T, hemesh.faces)\nax = plt.gca()\np = cellplot(hemesh, geommesh.face_positions,\n             cell_colors=np.array([0,0,0,0.1]), mpl_polygon_kwargs={\"lw\": 1, \"ec\": \"k\"})\nplt.gca().add_collection(p)\n\nplt.axis(\"equal\")\n\n(np.float64(-1.10003475),\n np.float64(1.09628575),\n np.float64(-1.09934025),\n np.float64(1.09050125))\n\n\n\n\n\n\n\n\n\n\n# edges and dual edges should be orthogonal since we are using circumcenters\n\nedges = geommesh.vertices[hemesh.orig]-geommesh.vertices[hemesh.dest]\ndual_edges = (geommesh.face_positions[hemesh.heface]\n              -geommesh.face_positions[hemesh.heface[hemesh.twin]])\n\njnp.allclose(jnp.einsum('vi,vi-&gt;v', edges[~hemesh.is_bdry_edge], dual_edges[~hemesh.is_bdry_edge]), 0)\n\nArray(True, dtype=bool)\n\n\n\n# computing the signed edge length shows that there are some \"flipped\" edges.\n\nsigned_squared_length = jnp.einsum('vi,vi-&gt;v', edges, dual_edges @ trig.get_rot_mat(np.pi/2))\njnp.where((signed_squared_length &lt; -0.0) & ~hemesh.is_bdry_edge )[0]\n\nArray([  9, 185, 191, 335, 363, 539, 545, 689], dtype=int64)\n\n\n\nset_voronoi_face_positions\n\n&lt;function __main__.set_voronoi_face_positions(geommesh: __main__.GeomMesh, hemesh: __main__.HeMesh) -&gt; __main__.GeomMesh&gt;\n\n\n\n# flip edge and recompute face positions\n\nflipped_hemesh = flip_edge(hemesh, e=335)\nflipped_geommesh = set_voronoi_face_positions(geommesh, flipped_hemesh)\n\n\n# connectivity is still valid\n\nigl.is_edge_manifold(hemesh.faces)[0], igl.is_edge_manifold(flipped_hemesh.faces)[0], flipped_hemesh.iterate_around_vertex(100)\n\n(True, True, Array([298, 299, 630, 632], dtype=int64))\n\n\n\n# you can see the flipped edge between vertices 126-117 in the plot below (middle right)\n\nfig = plt.figure(figsize=(8,8))\n\nplt.triplot(*geommesh.vertices.T, hemesh.faces)\nplt.triplot(*flipped_geommesh.vertices.T, flipped_hemesh.faces)\n\nax = plt.gca()\np1 = cellplot(hemesh, geommesh.face_positions,\n         cell_colors=np.array([0.,0.,0.,0.]), mpl_polygon_kwargs={\"lw\": 1, \"ec\": \"k\"})\np2 = cellplot(flipped_hemesh, flipped_geommesh.face_positions,\n              cell_colors=np.array([0.,0.,0.,0.]), mpl_polygon_kwargs={\"lw\": 1, \"ec\": \"tab:orange\"})\nax.add_collection(p1)\nax.add_collection(p2)\nplt.axis(\"equal\")\n\nlabel_plot(geommesh.vertices, hemesh.faces, fontsize=10, face_labels=False)\n\n\n\n\n\n\n\n\n\nRepeated flips\nIn a simulation, we need to carry out edge flips at every timestep. The function flip_edge(hemesh: HeMesh, e: int) -&gt; HeMesh does a single edge flip by modifying the connectivity arrays. Luckily, it is already JAX-compatible (we can JIT-compile it).\nTo carry out multiple flips, we must do the flips in sequence (otherwise, you risk leaving the mesh in an invalid state). To make things JAX-compatible, we do a jax.lax.scan scan over all half-edges.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\ndual_lengths = get_signed_dual_he_length(geommesh.vertices, geommesh.face_positions, hemesh)\nedges = jnp.where((dual_lengths &lt; -0.05) & ~hemesh.is_bdry_edge & hemesh.is_unique)[0]\n# we only want to flip unique hes!\nedges, edges.size\n\n(Array([  9, 185, 191, 335], dtype=int64), 4)\n\n\n\nsource\n\n\n\nflip_all\n\ndef flip_all(\n    hemesh:HeMesh, to_flip:Bool[Array, 'n_hes']\n)-&gt;HeMesh:\n\nFlip all (unique) half-edges where to_flip is True in a half-edge mesh. Wraps flip_edge.\n\nto_flip = (dual_lengths &lt; 0) & ~jnp.isnan(dual_lengths)\n\nflipped_hemesh = flip_all(hemesh, to_flip=to_flip)\n\n\nflipped_hemesh = flip_all(hemesh, to_flip=(dual_lengths&lt;0.02)) # no extra recompile\n\n\nflipped_geommesh = set_voronoi_face_positions(geommesh, flipped_hemesh)\n\n\nfig = plt.figure(figsize=(8,8))\n\nplt.triplot(*geommesh.vertices.T, hemesh.faces)\nplt.triplot(*flipped_geommesh.vertices.T, flipped_hemesh.faces)\n\nax = plt.gca()\nax = plt.gca()\np1 = cellplot(hemesh, geommesh.face_positions,\n         cell_colors=np.array([0.,0.,0.,0.]), mpl_polygon_kwargs={\"lw\": 1, \"ec\": \"k\"})\np2 = cellplot(flipped_hemesh, flipped_geommesh.face_positions,\n              cell_colors=np.array([0.,0.,0.,0.]), mpl_polygon_kwargs={\"lw\": 1, \"ec\": \"tab:orange\"})\nax.add_collection(p1)\nax.add_collection(p2)\nplt.axis(\"equal\")\n\nlabel_plot(geommesh.vertices, hemesh.faces, fontsize=10, face_labels=False)",
    "crumbs": [
      "Half-edge meshes"
    ]
  },
  {
    "objectID": "03_halfedge_datastructure.html#saving-to-disk",
    "href": "03_halfedge_datastructure.html#saving-to-disk",
    "title": "triangulax",
    "section": "Saving to disk",
    "text": "Saving to disk\nWe save and load TriMesh meshes as standard .obj files (with the hack of using vn lines for the face positions). The HeMesh class is basically a collection of arrays, which we can save to disk using numpy.\n\nfrom tempfile import TemporaryFile\n\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\noutfile = TemporaryFile()\n\nhemesh.save(outfile)\n_ = outfile.seek(0) # simulates closing & reopening file\nnpzfile = np.load(outfile)\nnpzfile.files\n\n['incident',\n 'orig',\n 'dest',\n 'twin',\n 'nxt',\n 'prv',\n 'heface',\n 'face_incident',\n 'inf_vertices']\n\n\n\noutfile = TemporaryFile()\n\nhemesh.save(outfile)\n_ = outfile.seek(0) # simulates closing & reopening file\nreloaded = HeMesh.load(outfile)\n\nnp.allclose(reloaded.faces, hemesh.faces)\n\nTrue\n\n\n\nNext steps\nLooks good - the JAX-compatible triangular-mesh data structures seem to work. In particular, the tricky T1/edge-flip function. Next steps: toy simulation, notebook 01.",
    "crumbs": [
      "Half-edge meshes"
    ]
  },
  {
    "objectID": "04_linear_operators_on_meshes.html",
    "href": "04_linear_operators_on_meshes.html",
    "title": "triangulax",
    "section": "",
    "text": "Using the HeMesh data structure, we can efficiently “traverse” our mesh. Using such traversals, one can express many of the key linear operators defined by the mesh adjacency structure, for example:\n\nSum over all half-edges “incoming” to a vertex (special case: count the incoming edges, i.e., compute the coordination number)\nCompute the finite-element gradient of a function defined on vertices\n\nThese operations can be done efficiently using a “gather/scatter” approach, see jax.numpy.ndarray.at. There is no need to explicitly instantiate a matrix for the operators.\n\n# load test data\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = msh.HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = msh.GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)\n\nmesh_3d = TriMesh.read_obj(\"test_meshes/disk.obj\", dim=3)\ngeommesh_3d = msh.GeomMesh(*hemesh.n_items, mesh_3d.vertices, mesh_3d.face_positions)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\nsource\n\n\n\ndef average_faces_to_vertices(\n    hemesh:HeMesh, vertices:Float[Array, 'n_vertices dim'], face_field:Float[Array, 'n_faces ...']\n)-&gt;Float[Array, 'n_vertices ...']:\n\nAverage per-face field onto vertices, weighted by triangle area.\n\nsource\n\n\n\n\ndef average_vertices_to_faces(\n    hemesh:HeMesh, vertex_field:Float[Array, 'n_vertices ...']\n)-&gt;Float[Array, 'n_faces ...']:\n\nAverage per-vertex field onto faces (uniform weights).\n\n# tests vs libigl\nkey = jax.random.PRNGKey(123)\n\nu_v = jax.random.normal(key, (hemesh.n_vertices,))\nfaces_avg_jax = average_vertices_to_faces(hemesh, u_v)\nfaces_avg_igl = igl.average_onto_faces(np.asarray(hemesh.faces), np.asarray(u_v))\n\nrel_err_faces = np.linalg.norm(np.asarray(faces_avg_jax) - faces_avg_igl) / np.linalg.norm(faces_avg_igl)\nprint(\"vertex-&gt;face rel. error:\", rel_err_faces)\n\nu_f = jax.random.normal(key, (hemesh.n_faces,))\nverts_avg_jax = average_faces_to_vertices(hemesh, geommesh.vertices, u_f)\n\n# libigl reference using area-weighted averaging\nV = np.asarray(geommesh.vertices)\nF = np.asarray(hemesh.faces)\nareas_np = 0.5 * igl.doublearea(V, F)\naccum = np.zeros(hemesh.n_vertices)\narea_accum = np.zeros(hemesh.n_vertices)\nuf_np = np.asarray(u_f)\nfor i, f in enumerate(F):\n    accum[f] += areas_np[i] * uf_np[i]\n    area_accum[f] += areas_np[i]\nverts_avg_ref = accum / np.maximum(area_accum, 1e-12)\n\nrel_err_verts = np.linalg.norm(np.asarray(verts_avg_jax) - verts_avg_ref) / np.linalg.norm(verts_avg_ref)\nprint(\"face-&gt;vertex rel. error:\", rel_err_verts)\n\nvertex-&gt;face rel. error: 1.0413393664022524e-16\nface-&gt;vertex rel. error: 1.3698911362107636e-16\n\n\n\n\n\nTo compute, for instance, the cell area using the shoelace formula, you need to iterate around the faces adjacent to a vertex. This is not straightforward to vectorize because the number of adjacent faces per vertex can vary (there can be 5-, 6-, 7-sided cells etc.). One way to solve this is a scheme in which the lists of adjacent faces are “padded” in some manner, so that they are all the same length. This is cumbersome. Instead, let us split all “cell-based” quantities into contributions from “corners”, i.e., half-edges, like this:\n Source: CGAL\nTo compute the total area, we can sum over all half-edges \\((r,p)\\) opposite to a vertex \\(q\\). Numerically, this can be achieved efficiently using gather/scatter operations.\n\nsource\n\n\n\n\ndef sum_he_to_vertex_opposite(\n    hemesh:HeMesh, he_field:Float[Array, 'n_hes ...']\n)-&gt;Float[Array, 'n_vertices ...']:\n\nSum a half-edge field onto opposite vertices.\nAttention: can include boundary half-edges!\nhemesh: connectivity information he_field: (n_hes,) or (n_hes, d) array\n\nsource\n\n\n\n\ndef sum_he_to_vertex_incoming(\n    hemesh:HeMesh, he_field:Float[Array, 'n_hes ...']\n)-&gt;Float[Array, 'n_vertices ...']:\n\nSum a half-edge field onto destination vertices.\nhemesh: connectivity information he_field: (n_hes,) or (n_hes, d) array\n\nsource\n\n\n\n\ndef get_cell_areas(\n    geommesh:GeomMesh, hemesh:HeMesh\n)-&gt;Float[Array, 'n_vertices']:\n\nCompute areas of cells by mesh traversal (don’t use for simulation, inefficient).\nBoundary vertices get area 0.\n\n## Let's use the adjacency matrix to compute the area of all cells. First, compute all corner areas\n\na, b, c = (hemesh.dest[hemesh.nxt], hemesh.dest[hemesh.prv], hemesh.dest)\n\ncorner_areas = jax.vmap(trig.get_voronoi_corner_area)(geommesh.vertices[a], geommesh.vertices[b], geommesh.vertices[c])\ncell_areas_corner = sum_he_to_vertex_opposite(hemesh, corner_areas)\ncell_areas_corner = cell_areas_corner.at[hemesh.is_bdry].set(0)\n\n\n# for comparison, compute the areas by mesh traversal\n\ncell_areas_iterative = -get_cell_areas(geommesh, hemesh)\nnp.abs(cell_areas_iterative-cell_areas_corner).max() # works!\n\nnp.float64(4.85722573273506e-17)\n\n\n\nsource\n\n\n\n\ndef get_coordination_number(\n    hemesh:HeMesh\n)-&gt;Float[Array, 'n_vertices']:\n\n\n# using the gather/scatter trick, we can also compute the coordination number of each vertex\n\nget_coordination_number(hemesh)\n\nArray([4., 6., 6., 7., 6., 6., 6., 6., 6., 4., 4., 6., 6., 5., 6., 6., 6.,\n       5., 5., 6., 3., 4., 6., 6., 6., 7., 5., 6., 6., 7., 7., 6., 4., 4.,\n       3., 7., 6., 6., 5., 7., 6., 6., 6., 6., 7., 5., 4., 5., 5., 6., 6.,\n       7., 7., 5., 6., 6., 7., 5., 3., 5., 7., 6., 5., 6., 5., 6., 7., 6.,\n       5., 4., 5., 5., 6., 6., 6., 6., 6., 7., 6., 6., 4., 6., 6., 5., 6.,\n       4., 4., 6., 6., 6., 7., 4., 6., 6., 6., 5., 6., 6., 6., 4., 4., 6.,\n       6., 6., 6., 7., 6., 4., 4., 5., 4., 4., 3., 4., 4., 3., 4., 3., 5.,\n       4., 3., 4., 3., 5., 6., 6., 6., 6., 6., 6., 4.], dtype=float64)\n\n\n\nsource\n\n\n\n\ndef get_cell_perimeters(\n    vertices:Float[Array, 'n_vertices dim'], hemesh:HeMesh\n)-&gt;Float[Array, 'n_vertices']:\n\nCompute Voronoi perimeters for each vertex.\n\nsource\n\n\n\n\ndef get_cell_areas(\n    vertices:Float[Array, 'n_vertices dim'], hemesh:HeMesh\n)-&gt;Float[Array, 'n_vertices']:\n\nCompute Voronoi area for each vertex.\n\nsource\n\n\n\n\ndef get_triangle_areas(\n    vertices:Float[Array, 'n_vertices dim'], hemesh:HeMesh\n)-&gt;Float[Array, 'n_faces ...']:\n\nCompute oriented triangle areas in a mesh.\n\n\n\nNext, we implement gradient (per-vertex scalar field -&gt; per-face vector field) and the cotan-Laplacian (vertex -&gt; vertex) using gather/scatter ops like above. The cotan-Laplacian is the discretization of the Laplace Beltrami operator on a triangular mesh.\nIn both cases, we start with a scalar field \\(u_i\\) defined per vertex \\(i\\) of the triangulation. The finite-element gradient is defined for each face \\(ijk\\), like so: \\[\n(\\nabla u)_{ijk} = \\sum_{l\\in \\{i,j,k\\}} u_l \\nabla\\phi_l\n\\] where \\(\\phi_i\\) is a linear finite element test function (linear Lagrange element) and has gradient \\[\n    \\nabla\\phi_i = \\frac{1}{2a_{ijk}} (\\mathbf{v}_k-\\mathbf{v}_j)^\\perp\n\\] plus cyclic permutations. Here, \\(a_{ijk}\\) is the triangle area, \\(\\mathbf{v}_i\\) are the vertex positions, and \\(()^\\perp\\) denotes rotation by 90 degrees (in 3D, you rotate about the triangle normal).\nThe cot-Laplacian computes the following per-vertex field: \\[\n(\\Delta u)_i = \\frac{1}{2} \\sum_{j} (\\cot\\alpha_j +\\cot\\beta_j) (u_j-u_i)\n\\] where the sum is over adjacent vertices, and \\(\\alpha_j, \\beta_j\\) are the two triangle angles “opposite” to the edge \\(ij\\).\nTo check for correctness, we can compare with this libgigl tutorial, using the test mesh and some random test fields.\n\nsource\n\n\n\n\ndef compute_cotan_laplace(\n    hemesh:HeMesh, vertices:Float[Array, 'n_vertices dim'], vertex_field:Float[Array, 'n_vertices ...']\n)-&gt;Float[Array, 'n_vertices ...']:\n\nCompute cotangent laplacian of a per-vertex field (natural boundary conditions).\n\nsource\n\n\n\n\ndef cotan_laplace_sparse(\n    hemesh:HeMesh, vertices:Float[Array, 'n_vertices dim']\n)-&gt;BCOO:\n\nAssemble cotangent Laplacian as a sparse matrix (BCOO).\n\n# Test against libigl cotmatrix (natural boundary conditions)\nkey = jax.random.PRNGKey(0)\nu = jax.random.normal(key, (hemesh.n_vertices,))\nu_vec = jax.random.normal(key, (hemesh.n_vertices, 3))\n\nL = igl.cotmatrix(np.asarray(geommesh.vertices), np.asarray(hemesh.faces))\n\nlap_jax = compute_cotan_laplace(hemesh, geommesh.vertices, u)\nlap_igl = L @ np.asarray(u)\n\nrel_err = np.linalg.norm(np.asarray(lap_jax) - lap_igl) / np.linalg.norm(lap_igl)\nprint(\"scalar field rel. error:\", rel_err)\n\nlap_jax_vec = compute_cotan_laplace(hemesh, geommesh.vertices, u_vec)\nlap_igl_vec = L @ np.asarray(u_vec)\n\nrel_err_vec = np.linalg.norm(np.asarray(lap_jax_vec) - lap_igl_vec) / np.linalg.norm(lap_igl_vec)\nprint(\"vector field rel. error:\", rel_err_vec)\n\nscalar field rel. error: 3.678610050757719e-12\nvector field rel. error: 3.659299534118066e-12\n\n\n\n# test sparse cotan Laplacian vs apply function\nkey = jax.random.PRNGKey(0)\nu_test = jax.random.normal(key, (hemesh.n_vertices,))\n\nL_sparse = cotan_laplace_sparse(hemesh, geommesh.vertices)\nlap_sparse = L_sparse @ u_test\nlap_apply = compute_cotan_laplace(hemesh, geommesh.vertices, u_test)\n\nrel_err_sparse = jnp.linalg.norm(lap_sparse - lap_apply) / jnp.linalg.norm(lap_apply)\nprint(\"cotan sparse vs apply rel. error:\", rel_err_sparse)\n\ncotan sparse vs apply rel. error: 1.3520071722257924e-16\n\n\n\nsource\n\n\n\n\ndef compute_gradient_3d(\n    hemesh:HeMesh, vertices:Float[Array, 'n_vertices 3'], vertex_field:Float[Array, 'n_vertices ...']\n)-&gt;Float[Array, 'n_faces 3 ...']:\n\nCompute the linear finite-element gradient (constant per face).\n\nsource\n\n\n\n\ndef compute_gradient_2d(\n    hemesh:HeMesh, vertices:Float[Array, 'n_vertices 2'], vertex_field:Float[Array, 'n_vertices ...']\n)-&gt;Float[Array, 'n_faces 2 ...']:\n\nCompute the linear finite-element gradient (constant per face).\n\n# here's how to compute the gradient in libigl\n\ngrad_matrix = igl.grad(np.asarray(geommesh.vertices), np.asarray(hemesh.faces))\n# calculate the gradient of field by matrix multiplication\ngrad_igl = grad_matrix @ np.asarray(u)\n# order='F' copied from igl tutorial\ngrad_igl = grad_igl.reshape((hemesh.n_faces, geommesh.dim), order='F')\n\n\n# test jax and libigl implementations\n\ngrad_jax = compute_gradient_2d(hemesh, geommesh.vertices, u)\n\nrel_err_grad = np.linalg.norm(np.asarray(grad_jax) - grad_igl) / np.linalg.norm(grad_igl)\nprint(\"gradient rel. error:\", rel_err_grad)\n\ngradient rel. error: 1.413315746703021e-16\n\n\n\n# same test, in 3d\n\ngrad_matrix_3d = igl.grad(np.asarray(geommesh_3d.vertices), np.asarray(hemesh.faces))\ngrad_igl_3d = grad_matrix_3d @ np.asarray(u)\ngrad_igl_3d = grad_igl_3d.reshape((hemesh.n_faces, geommesh_3d.dim), order='F')\n\ngrad_jax_3d = compute_gradient_3d(hemesh, geommesh_3d.vertices, u)\n\nrel_err_grad_3d = np.linalg.norm(np.asarray(grad_jax_3d) - grad_igl_3d) / np.linalg.norm(grad_igl_3d)\nprint(\"gradient rel. error:\", rel_err_grad_3d)\n\ngradient rel. error: 1.5657863888820882e-16\n\n\n\n\n\nIt’s often useful to think of functions like compute_cotan_laplace() as a linear operator on fields on meshes. For example, imagine you want to solve the Laplace equation on a mesh with fixed vertex positions and connectivity. You will want to use a linear solver. Luckily, most such solvers only need to be able to compute the action of a linear operator on an input vector, and don’t need an explicit matrix representation.\nIn the JAX ecosystem, the lineax library defines linear solvers. We can wrap compute_cotan_laplace() as a linear operator, which allows us to pass it into iterative linear algebra algorithms.\n\nsource\n\n\n\n\ndef diag_jsparse(\n    v:Float[Array, 'N'], k:int=0\n)-&gt;BCOO:\n\nConstruct a diagonal jax.sparse array. Plugin replacement for np.diag\n\nsource\n\n\n\n\ndef scipy_to_bcoo(\n    A, # Input sparse matrix (CSR or CSC recommended)\n)-&gt;BCOO: # Equivalent JAX sparse matrix\n\nConvert a SciPy sparse matrix (CSC or CSR) to a JAX BCOO sparse matrix without converting to dense.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\nhemesh = msh.HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = msh.GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\n# \"bake in\" the connectivity and vertex positions\n\nlaplace_op = functools.partial(compute_cotan_laplace, hemesh, geommesh.vertices)\n_ = laplace_op(u)\n\n\n# define the linear operator\n\nlaplace_op_lx = lineax.FunctionLinearOperator(laplace_op,\n                                              input_structure=jax.eval_shape(laplace_op, u))\n\n# now you can use the linear operator to compute matrix representations, solve linear systems, etc.\nmat = laplace_op_lx.as_matrix()\nmat.shape\n\n(131, 131)\n\n\n\nsource\n\n\n\n\ndef linear_op_to_sparse(\n    op:callable, in_shape:tuple, out_shape:tuple, dtype:Union=None, chunk_size:int=256, tol:float=0.0\n)-&gt;BCOO:\n\nBuild a sparse matrix for a linear map using batched one-hot probes.\nNote: this function is general, but not necessarily very efficient for large matrix sizes.\n\n# compare sparse construction to lineax dense matrix (small meshes only)\nif hemesh.n_vertices &lt;= 2000:\n    laplace_op_local = functools.partial(compute_cotan_laplace, hemesh, geommesh.vertices)\n    laplace_op_lx_local = lineax.FunctionLinearOperator(laplace_op_local,\n                                                        input_structure=jax.eval_shape(laplace_op_local, u))\n    sp_mat = linear_op_to_sparse(laplace_op_local, (hemesh.n_vertices,), (hemesh.n_vertices,))\n    mat_dense = laplace_op_lx_local.as_matrix()\n    rel_err_sparse = jnp.linalg.norm(sp_mat.todense() - mat_dense) / jnp.linalg.norm(mat_dense)\n    print(\"sparse vs lineax rel. error:\", rel_err_sparse)\nelse:\n    print(\"Skipping dense comparison for large mesh.\")\n\nSkipping dense comparison for large mesh.\n\n\n\n## now let's try with a large mesh\n\nmesh = TriMesh.read_obj(\"test_meshes/torus_high_resolution.obj\")\nhemesh = msh.HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = msh.GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)\n\nlaplace_op = jax.jit(functools.partial(compute_cotan_laplace, hemesh, geommesh.vertices))\n\nWarning: readOBJ() ignored non-comment line 3:\n  o Torus\n\n\n\nhemesh\n\nHeMesh(N_V=36864, N_HE=221184, N_F=73728)\n\n\n\nsparse_laplace_op =  linear_op_to_sparse(laplace_op, (hemesh.n_vertices,), (hemesh.n_vertices,))\n\n\nsparse_laplace_op.shape\n\n(36864, 36864)\n\n\n\nigl.cotmatrix(geommesh.vertices, hemesh.faces)\n\n&lt;Compressed Sparse Column sparse matrix of dtype 'float64'\n    with 258048 stored elements and shape (36864, 36864)&gt;",
    "crumbs": [
      "Adjacency-like operators on half-edge meshes"
    ]
  },
  {
    "objectID": "04_linear_operators_on_meshes.html#adjacency-like-operators-on-half-edge-meshes",
    "href": "04_linear_operators_on_meshes.html#adjacency-like-operators-on-half-edge-meshes",
    "title": "triangulax",
    "section": "",
    "text": "Using the HeMesh data structure, we can efficiently “traverse” our mesh. Using such traversals, one can express many of the key linear operators defined by the mesh adjacency structure, for example:\n\nSum over all half-edges “incoming” to a vertex (special case: count the incoming edges, i.e., compute the coordination number)\nCompute the finite-element gradient of a function defined on vertices\n\nThese operations can be done efficiently using a “gather/scatter” approach, see jax.numpy.ndarray.at. There is no need to explicitly instantiate a matrix for the operators.\n\n# load test data\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = msh.HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = msh.GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)\n\nmesh_3d = TriMesh.read_obj(\"test_meshes/disk.obj\", dim=3)\ngeommesh_3d = msh.GeomMesh(*hemesh.n_items, mesh_3d.vertices, mesh_3d.face_positions)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\nsource\n\n\n\ndef average_faces_to_vertices(\n    hemesh:HeMesh, vertices:Float[Array, 'n_vertices dim'], face_field:Float[Array, 'n_faces ...']\n)-&gt;Float[Array, 'n_vertices ...']:\n\nAverage per-face field onto vertices, weighted by triangle area.\n\nsource\n\n\n\n\ndef average_vertices_to_faces(\n    hemesh:HeMesh, vertex_field:Float[Array, 'n_vertices ...']\n)-&gt;Float[Array, 'n_faces ...']:\n\nAverage per-vertex field onto faces (uniform weights).\n\n# tests vs libigl\nkey = jax.random.PRNGKey(123)\n\nu_v = jax.random.normal(key, (hemesh.n_vertices,))\nfaces_avg_jax = average_vertices_to_faces(hemesh, u_v)\nfaces_avg_igl = igl.average_onto_faces(np.asarray(hemesh.faces), np.asarray(u_v))\n\nrel_err_faces = np.linalg.norm(np.asarray(faces_avg_jax) - faces_avg_igl) / np.linalg.norm(faces_avg_igl)\nprint(\"vertex-&gt;face rel. error:\", rel_err_faces)\n\nu_f = jax.random.normal(key, (hemesh.n_faces,))\nverts_avg_jax = average_faces_to_vertices(hemesh, geommesh.vertices, u_f)\n\n# libigl reference using area-weighted averaging\nV = np.asarray(geommesh.vertices)\nF = np.asarray(hemesh.faces)\nareas_np = 0.5 * igl.doublearea(V, F)\naccum = np.zeros(hemesh.n_vertices)\narea_accum = np.zeros(hemesh.n_vertices)\nuf_np = np.asarray(u_f)\nfor i, f in enumerate(F):\n    accum[f] += areas_np[i] * uf_np[i]\n    area_accum[f] += areas_np[i]\nverts_avg_ref = accum / np.maximum(area_accum, 1e-12)\n\nrel_err_verts = np.linalg.norm(np.asarray(verts_avg_jax) - verts_avg_ref) / np.linalg.norm(verts_avg_ref)\nprint(\"face-&gt;vertex rel. error:\", rel_err_verts)\n\nvertex-&gt;face rel. error: 1.0413393664022524e-16\nface-&gt;vertex rel. error: 1.3698911362107636e-16\n\n\n\n\n\nTo compute, for instance, the cell area using the shoelace formula, you need to iterate around the faces adjacent to a vertex. This is not straightforward to vectorize because the number of adjacent faces per vertex can vary (there can be 5-, 6-, 7-sided cells etc.). One way to solve this is a scheme in which the lists of adjacent faces are “padded” in some manner, so that they are all the same length. This is cumbersome. Instead, let us split all “cell-based” quantities into contributions from “corners”, i.e., half-edges, like this:\n Source: CGAL\nTo compute the total area, we can sum over all half-edges \\((r,p)\\) opposite to a vertex \\(q\\). Numerically, this can be achieved efficiently using gather/scatter operations.\n\nsource\n\n\n\n\ndef sum_he_to_vertex_opposite(\n    hemesh:HeMesh, he_field:Float[Array, 'n_hes ...']\n)-&gt;Float[Array, 'n_vertices ...']:\n\nSum a half-edge field onto opposite vertices.\nAttention: can include boundary half-edges!\nhemesh: connectivity information he_field: (n_hes,) or (n_hes, d) array\n\nsource\n\n\n\n\ndef sum_he_to_vertex_incoming(\n    hemesh:HeMesh, he_field:Float[Array, 'n_hes ...']\n)-&gt;Float[Array, 'n_vertices ...']:\n\nSum a half-edge field onto destination vertices.\nhemesh: connectivity information he_field: (n_hes,) or (n_hes, d) array\n\nsource\n\n\n\n\ndef get_cell_areas(\n    geommesh:GeomMesh, hemesh:HeMesh\n)-&gt;Float[Array, 'n_vertices']:\n\nCompute areas of cells by mesh traversal (don’t use for simulation, inefficient).\nBoundary vertices get area 0.\n\n## Let's use the adjacency matrix to compute the area of all cells. First, compute all corner areas\n\na, b, c = (hemesh.dest[hemesh.nxt], hemesh.dest[hemesh.prv], hemesh.dest)\n\ncorner_areas = jax.vmap(trig.get_voronoi_corner_area)(geommesh.vertices[a], geommesh.vertices[b], geommesh.vertices[c])\ncell_areas_corner = sum_he_to_vertex_opposite(hemesh, corner_areas)\ncell_areas_corner = cell_areas_corner.at[hemesh.is_bdry].set(0)\n\n\n# for comparison, compute the areas by mesh traversal\n\ncell_areas_iterative = -get_cell_areas(geommesh, hemesh)\nnp.abs(cell_areas_iterative-cell_areas_corner).max() # works!\n\nnp.float64(4.85722573273506e-17)\n\n\n\nsource\n\n\n\n\ndef get_coordination_number(\n    hemesh:HeMesh\n)-&gt;Float[Array, 'n_vertices']:\n\n\n# using the gather/scatter trick, we can also compute the coordination number of each vertex\n\nget_coordination_number(hemesh)\n\nArray([4., 6., 6., 7., 6., 6., 6., 6., 6., 4., 4., 6., 6., 5., 6., 6., 6.,\n       5., 5., 6., 3., 4., 6., 6., 6., 7., 5., 6., 6., 7., 7., 6., 4., 4.,\n       3., 7., 6., 6., 5., 7., 6., 6., 6., 6., 7., 5., 4., 5., 5., 6., 6.,\n       7., 7., 5., 6., 6., 7., 5., 3., 5., 7., 6., 5., 6., 5., 6., 7., 6.,\n       5., 4., 5., 5., 6., 6., 6., 6., 6., 7., 6., 6., 4., 6., 6., 5., 6.,\n       4., 4., 6., 6., 6., 7., 4., 6., 6., 6., 5., 6., 6., 6., 4., 4., 6.,\n       6., 6., 6., 7., 6., 4., 4., 5., 4., 4., 3., 4., 4., 3., 4., 3., 5.,\n       4., 3., 4., 3., 5., 6., 6., 6., 6., 6., 6., 4.], dtype=float64)\n\n\n\nsource\n\n\n\n\ndef get_cell_perimeters(\n    vertices:Float[Array, 'n_vertices dim'], hemesh:HeMesh\n)-&gt;Float[Array, 'n_vertices']:\n\nCompute Voronoi perimeters for each vertex.\n\nsource\n\n\n\n\ndef get_cell_areas(\n    vertices:Float[Array, 'n_vertices dim'], hemesh:HeMesh\n)-&gt;Float[Array, 'n_vertices']:\n\nCompute Voronoi area for each vertex.\n\nsource\n\n\n\n\ndef get_triangle_areas(\n    vertices:Float[Array, 'n_vertices dim'], hemesh:HeMesh\n)-&gt;Float[Array, 'n_faces ...']:\n\nCompute oriented triangle areas in a mesh.\n\n\n\nNext, we implement gradient (per-vertex scalar field -&gt; per-face vector field) and the cotan-Laplacian (vertex -&gt; vertex) using gather/scatter ops like above. The cotan-Laplacian is the discretization of the Laplace Beltrami operator on a triangular mesh.\nIn both cases, we start with a scalar field \\(u_i\\) defined per vertex \\(i\\) of the triangulation. The finite-element gradient is defined for each face \\(ijk\\), like so: \\[\n(\\nabla u)_{ijk} = \\sum_{l\\in \\{i,j,k\\}} u_l \\nabla\\phi_l\n\\] where \\(\\phi_i\\) is a linear finite element test function (linear Lagrange element) and has gradient \\[\n    \\nabla\\phi_i = \\frac{1}{2a_{ijk}} (\\mathbf{v}_k-\\mathbf{v}_j)^\\perp\n\\] plus cyclic permutations. Here, \\(a_{ijk}\\) is the triangle area, \\(\\mathbf{v}_i\\) are the vertex positions, and \\(()^\\perp\\) denotes rotation by 90 degrees (in 3D, you rotate about the triangle normal).\nThe cot-Laplacian computes the following per-vertex field: \\[\n(\\Delta u)_i = \\frac{1}{2} \\sum_{j} (\\cot\\alpha_j +\\cot\\beta_j) (u_j-u_i)\n\\] where the sum is over adjacent vertices, and \\(\\alpha_j, \\beta_j\\) are the two triangle angles “opposite” to the edge \\(ij\\).\nTo check for correctness, we can compare with this libgigl tutorial, using the test mesh and some random test fields.\n\nsource\n\n\n\n\ndef compute_cotan_laplace(\n    hemesh:HeMesh, vertices:Float[Array, 'n_vertices dim'], vertex_field:Float[Array, 'n_vertices ...']\n)-&gt;Float[Array, 'n_vertices ...']:\n\nCompute cotangent laplacian of a per-vertex field (natural boundary conditions).\n\nsource\n\n\n\n\ndef cotan_laplace_sparse(\n    hemesh:HeMesh, vertices:Float[Array, 'n_vertices dim']\n)-&gt;BCOO:\n\nAssemble cotangent Laplacian as a sparse matrix (BCOO).\n\n# Test against libigl cotmatrix (natural boundary conditions)\nkey = jax.random.PRNGKey(0)\nu = jax.random.normal(key, (hemesh.n_vertices,))\nu_vec = jax.random.normal(key, (hemesh.n_vertices, 3))\n\nL = igl.cotmatrix(np.asarray(geommesh.vertices), np.asarray(hemesh.faces))\n\nlap_jax = compute_cotan_laplace(hemesh, geommesh.vertices, u)\nlap_igl = L @ np.asarray(u)\n\nrel_err = np.linalg.norm(np.asarray(lap_jax) - lap_igl) / np.linalg.norm(lap_igl)\nprint(\"scalar field rel. error:\", rel_err)\n\nlap_jax_vec = compute_cotan_laplace(hemesh, geommesh.vertices, u_vec)\nlap_igl_vec = L @ np.asarray(u_vec)\n\nrel_err_vec = np.linalg.norm(np.asarray(lap_jax_vec) - lap_igl_vec) / np.linalg.norm(lap_igl_vec)\nprint(\"vector field rel. error:\", rel_err_vec)\n\nscalar field rel. error: 3.678610050757719e-12\nvector field rel. error: 3.659299534118066e-12\n\n\n\n# test sparse cotan Laplacian vs apply function\nkey = jax.random.PRNGKey(0)\nu_test = jax.random.normal(key, (hemesh.n_vertices,))\n\nL_sparse = cotan_laplace_sparse(hemesh, geommesh.vertices)\nlap_sparse = L_sparse @ u_test\nlap_apply = compute_cotan_laplace(hemesh, geommesh.vertices, u_test)\n\nrel_err_sparse = jnp.linalg.norm(lap_sparse - lap_apply) / jnp.linalg.norm(lap_apply)\nprint(\"cotan sparse vs apply rel. error:\", rel_err_sparse)\n\ncotan sparse vs apply rel. error: 1.3520071722257924e-16\n\n\n\nsource\n\n\n\n\ndef compute_gradient_3d(\n    hemesh:HeMesh, vertices:Float[Array, 'n_vertices 3'], vertex_field:Float[Array, 'n_vertices ...']\n)-&gt;Float[Array, 'n_faces 3 ...']:\n\nCompute the linear finite-element gradient (constant per face).\n\nsource\n\n\n\n\ndef compute_gradient_2d(\n    hemesh:HeMesh, vertices:Float[Array, 'n_vertices 2'], vertex_field:Float[Array, 'n_vertices ...']\n)-&gt;Float[Array, 'n_faces 2 ...']:\n\nCompute the linear finite-element gradient (constant per face).\n\n# here's how to compute the gradient in libigl\n\ngrad_matrix = igl.grad(np.asarray(geommesh.vertices), np.asarray(hemesh.faces))\n# calculate the gradient of field by matrix multiplication\ngrad_igl = grad_matrix @ np.asarray(u)\n# order='F' copied from igl tutorial\ngrad_igl = grad_igl.reshape((hemesh.n_faces, geommesh.dim), order='F')\n\n\n# test jax and libigl implementations\n\ngrad_jax = compute_gradient_2d(hemesh, geommesh.vertices, u)\n\nrel_err_grad = np.linalg.norm(np.asarray(grad_jax) - grad_igl) / np.linalg.norm(grad_igl)\nprint(\"gradient rel. error:\", rel_err_grad)\n\ngradient rel. error: 1.413315746703021e-16\n\n\n\n# same test, in 3d\n\ngrad_matrix_3d = igl.grad(np.asarray(geommesh_3d.vertices), np.asarray(hemesh.faces))\ngrad_igl_3d = grad_matrix_3d @ np.asarray(u)\ngrad_igl_3d = grad_igl_3d.reshape((hemesh.n_faces, geommesh_3d.dim), order='F')\n\ngrad_jax_3d = compute_gradient_3d(hemesh, geommesh_3d.vertices, u)\n\nrel_err_grad_3d = np.linalg.norm(np.asarray(grad_jax_3d) - grad_igl_3d) / np.linalg.norm(grad_igl_3d)\nprint(\"gradient rel. error:\", rel_err_grad_3d)\n\ngradient rel. error: 1.5657863888820882e-16\n\n\n\n\n\nIt’s often useful to think of functions like compute_cotan_laplace() as a linear operator on fields on meshes. For example, imagine you want to solve the Laplace equation on a mesh with fixed vertex positions and connectivity. You will want to use a linear solver. Luckily, most such solvers only need to be able to compute the action of a linear operator on an input vector, and don’t need an explicit matrix representation.\nIn the JAX ecosystem, the lineax library defines linear solvers. We can wrap compute_cotan_laplace() as a linear operator, which allows us to pass it into iterative linear algebra algorithms.\n\nsource\n\n\n\n\ndef diag_jsparse(\n    v:Float[Array, 'N'], k:int=0\n)-&gt;BCOO:\n\nConstruct a diagonal jax.sparse array. Plugin replacement for np.diag\n\nsource\n\n\n\n\ndef scipy_to_bcoo(\n    A, # Input sparse matrix (CSR or CSC recommended)\n)-&gt;BCOO: # Equivalent JAX sparse matrix\n\nConvert a SciPy sparse matrix (CSC or CSR) to a JAX BCOO sparse matrix without converting to dense.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\nhemesh = msh.HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = msh.GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\n# \"bake in\" the connectivity and vertex positions\n\nlaplace_op = functools.partial(compute_cotan_laplace, hemesh, geommesh.vertices)\n_ = laplace_op(u)\n\n\n# define the linear operator\n\nlaplace_op_lx = lineax.FunctionLinearOperator(laplace_op,\n                                              input_structure=jax.eval_shape(laplace_op, u))\n\n# now you can use the linear operator to compute matrix representations, solve linear systems, etc.\nmat = laplace_op_lx.as_matrix()\nmat.shape\n\n(131, 131)\n\n\n\nsource\n\n\n\n\ndef linear_op_to_sparse(\n    op:callable, in_shape:tuple, out_shape:tuple, dtype:Union=None, chunk_size:int=256, tol:float=0.0\n)-&gt;BCOO:\n\nBuild a sparse matrix for a linear map using batched one-hot probes.\nNote: this function is general, but not necessarily very efficient for large matrix sizes.\n\n# compare sparse construction to lineax dense matrix (small meshes only)\nif hemesh.n_vertices &lt;= 2000:\n    laplace_op_local = functools.partial(compute_cotan_laplace, hemesh, geommesh.vertices)\n    laplace_op_lx_local = lineax.FunctionLinearOperator(laplace_op_local,\n                                                        input_structure=jax.eval_shape(laplace_op_local, u))\n    sp_mat = linear_op_to_sparse(laplace_op_local, (hemesh.n_vertices,), (hemesh.n_vertices,))\n    mat_dense = laplace_op_lx_local.as_matrix()\n    rel_err_sparse = jnp.linalg.norm(sp_mat.todense() - mat_dense) / jnp.linalg.norm(mat_dense)\n    print(\"sparse vs lineax rel. error:\", rel_err_sparse)\nelse:\n    print(\"Skipping dense comparison for large mesh.\")\n\nSkipping dense comparison for large mesh.\n\n\n\n## now let's try with a large mesh\n\nmesh = TriMesh.read_obj(\"test_meshes/torus_high_resolution.obj\")\nhemesh = msh.HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = msh.GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)\n\nlaplace_op = jax.jit(functools.partial(compute_cotan_laplace, hemesh, geommesh.vertices))\n\nWarning: readOBJ() ignored non-comment line 3:\n  o Torus\n\n\n\nhemesh\n\nHeMesh(N_V=36864, N_HE=221184, N_F=73728)\n\n\n\nsparse_laplace_op =  linear_op_to_sparse(laplace_op, (hemesh.n_vertices,), (hemesh.n_vertices,))\n\n\nsparse_laplace_op.shape\n\n(36864, 36864)\n\n\n\nigl.cotmatrix(geommesh.vertices, hemesh.faces)\n\n&lt;Compressed Sparse Column sparse matrix of dtype 'float64'\n    with 258048 stored elements and shape (36864, 36864)&gt;",
    "crumbs": [
      "Adjacency-like operators on half-edge meshes"
    ]
  },
  {
    "objectID": "06_self-propelled_Voronoi_model.html",
    "href": "06_self-propelled_Voronoi_model.html",
    "title": "Area-perimeter self-propelled Voronoi model",
    "section": "",
    "text": "After the toy example of notebook 05, let’s implement a slightly more complicated model, the self-propelled Voronoi area-perimeter Voronoi (VAP) model of Bi et al., 2016. This 2D model comprises most of the ingredients we will see in more general tissue mechanics simulations, from a coding perspective.\nIn brief, in the VAP, cells are modeled as the Voronoi tesselation for a series of centroids \\(\\mathbf{v}_i\\) (our triangulation vertices). Their overdamped dynamics comprises two terms: self-propulsion and relaxation of an elastic energy: \\[\\partial_t \\mathbf{v}_i = -\\nabla_{\\mathbf{v}_i} E_{AP} + v_0 \\hat{\\mathbf{n}}_i\\] For each cell \\(i\\), \\(\\hat{\\mathbf{n}}_i\\) is a unit vector (so we will represent it by an angle \\(\\theta_i\\)) that determines the direction of motion. Units of time are chosen so that the coefficient of \\(\\nabla E_{AP}\\) is \\(1\\). The energy is defined in terms of the Voronoi area \\(a_i\\) and Voronoi perimeter \\(p_i\\) of each cell: \\[E_{AP} = \\sum_i k_a(a_i-a_0)^2 + k_p(p_i-p_0)^2 \\] where \\(k_a, k_p\\) are elastic constants, and \\(a_0, p_0\\) are the target area and perimeter. They define the “shape index” \\(s_0= p_0/\\sqrt{a_0}\\). The key physics is that above a critical shape index \\(s_0^*\\), the model has a degenerate set of ground states, since for a large \\(p_0\\), there are many polygons with the given target area and perimeter (think floppy balloon).\nThe orientation \\(\\theta_i\\) of each cell is also dynamic. It undergoes rotational diffusion: \\[d\\theta_i = D_\\theta dW_{t, i} \\] where \\(dW_{t,i}\\) is Brownian motion, independent for each cell \\(i\\), and \\(D_\\theta\\) is the diffusion constant.",
    "crumbs": [
      "Area-perimeter self-propelled Voronoi model"
    ]
  },
  {
    "objectID": "06_self-propelled_Voronoi_model.html#overdamped-dynamics-with-self-propulsion",
    "href": "06_self-propelled_Voronoi_model.html#overdamped-dynamics-with-self-propulsion",
    "title": "Area-perimeter self-propelled Voronoi model",
    "section": "Overdamped dynamics with self-propulsion",
    "text": "Overdamped dynamics with self-propulsion\nNext, let’s add the self-propulsion term. We initialize the angles \\(\\theta_i\\) at random. We can store the angles as an extra vertex_attrib in our geommesh, using the functionality of the GeomMesh dataclass. We already have an IntEnum which we can use as keys to the vertex_attrib dictionary, like described in notebook 01.\nIn addition to incorporating the self-propulusion term \\(\\partial_t \\mathbf{v}_i = -\\nabla_{\\mathbf{v}_i} E_{AP} + v_0\\hat{\\mathbf{n}}_i\\), we need to do (stochastic) time steps for the angle orientation. Let’s do that with diffrax’s SDE solver, like in this tutorial. Let’s also implement the “pattern” for simulation loops with jax.lax.scan Note that the simulation can diverge if the self-propulsion term is too strong, due to effects at the boundaries. A more carefull handling of the boundaries (adding T1s on the boundaries, or using periodic BCs) is beyond the scope of this notebook.\n\nRandom numbers in JAX\nJAX takes a different approach to random numbers (and hence the noise in our SDE) than numpy. The random numbers that will be used are specified by a key and will thus be reproducible across simulations. In particular, random numbers are no impediment to auto-differentiation; they are “frozen” when taking automatic derivatives.\n\n## for this model, the simulation state becomes quite complex. Let's define a dataclass to hold it.\n\n@jax.tree_util.register_dataclass\n@dataclasses.dataclass\nclass SimState:\n    geommesh: GeomMesh\n    hemesh: HeMesh\n    cooldown_counter: Int[jax.Array, \" n_hes\"]\n    tprev: Float[jax.Array, \"\"]\n    solver_state_sp: object\n    solver_state_sde: object\n\n## we also define a dataclass to hold logging information\n\n@jax.tree_util.register_dataclass\n@dataclasses.dataclass\nclass Log:\n    geommesh: GeomMesh\n    hemesh: HeMesh\n    energy: Float[jax.Array, \"\"]\n    n_flips: Int[jax.Array, \"\"]\n\n\n# initialize orientations and store as a vertex attribute\n\nclass VertexAttribs(IntEnum):\n    SP_ORIENTATION = 1\n\nkey = jax.random.key(0)\ntheta0 = jax.random.uniform(key, shape=(hemesh.n_vertices,), minval=0.0, maxval=2*jnp.pi)\n\ngeommesh_sp = dataclasses.replace(geommesh,\n                                  vertex_attribs={VertexAttribs.SP_ORIENTATION: theta0})\n\nhemesh_sp = copy.copy(hemesh)\n\n\n## set simulation parameters\n\n# energy parameters\na0 = a_mean\ns0 = 3\np0 = s0*jnp.sqrt(a0)\nv0 = 0.005 # self-propulsion speed\nka = 1.0\nkp = 1.0\n\n# orientation dynamics parameters\ndiffusion_coeff_theta = 1.0\n\n# timestepping parameters\nstep_size = 0.02\nn_steps = 5000\n\ncooldown_steps = 5\nl_min_T1 = 0.0\n\n\n# check magnitude of the gradient forces vs the self-propulsion \n\ngrad0 = jax.grad(energy_ap)(geommesh_sp, hemesh, a0, p0, 1, 1).vertices\nsp0 = v0*jnp.stack([jnp.cos(theta0), jnp.sin(theta0)], axis=-1)\n\njnp.linalg.norm(sp0, axis=-1).mean() / jnp.linalg.norm(grad0, axis=-1).mean()\n\nArray(1.5736791, dtype=float64)\n\n\n\n## define the ODE for vertex positions\n\n@jax.jit\ndef ap_selfprop_vector_field(t: Float[jax.Array, \"\"],\n                             y: GeomMesh,\n                             args: Tuple[HeMesh, float, float, float, float, float]) -&gt; GeomMesh:\n    \"\"\"RHS for overdamped area-perimeter dynamics with self-propulsion.\"\"\"\n    hemesh, a0, p0, v0, k_a, k_p = args\n    theta = y.vertex_attribs[VertexAttribs.SP_ORIENTATION]\n    # combine energy gradient with self-propulsion\n    grad = jax.grad(energy_ap)(y, hemesh, a0, p0, k_a, k_p)\n    n_hat = jnp.stack([jnp.cos(theta), jnp.sin(theta)], axis=-1)\n    velocity = -grad.vertices + v0 * n_hat\n    # velocity = jnp.where(hemesh.is_bdry[:,None], 0, velocity)\n    # don't update the orientations here\n    zero_vertex_attribs = {key: jnp.zeros_like(val) for key, val in y.vertex_attribs.items()} \n    return dataclasses.replace(y, vertices=velocity, vertex_attribs=zero_vertex_attribs,)\nterm_sp = diffrax.ODETerm(ap_selfprop_vector_field)\n\n## define the SDE and solver for orientation dynamics\n\nkey_sde = jax.random.key(0)\ndef diffusion(t, y, args):\n    return lineax.DiagonalLinearOperator(diffusion_coeff_theta*jnp.ones(hemesh_sp.n_vertices))\ndef drift(t, y, args):\n    return jnp.zeros(hemesh_sp.n_vertices)\nbrownian_motion =  diffrax.VirtualBrownianTree(0, step_size*n_steps,\n                                               tol=1e-3, shape=(hemesh_sp.n_vertices,), key=key_sde)\nterm_sde = diffrax.MultiTerm(diffrax.ODETerm(drift), diffrax.ControlTerm(diffusion, brownian_motion))\n## Define solvers\n\nsolver_sp = diffrax.Tsit5()\nsolver_sde = diffrax.EulerHeun()\n\n\n# initialize the ancillary variables (solver state, cooldown)\n\nsolver_state_sp = solver_sp.init(term_sp, 0, step_size, geommesh_sp, (hemesh_sp, a0, p0, v0, ka, kp))\nsolver_state_sde = solver_sde.init(term_sde, 0, step_size, geommesh_sp.vertex_attribs[VertexAttribs.SP_ORIENTATION], None)\n\ntimepoints = step_size * jnp.arange(n_steps)\n\ninit = SimState(geommesh=geommesh_sp, hemesh=hemesh_sp,\n                cooldown_counter= jnp.zeros(hemesh_sp.n_hes), tprev=timepoints[0],\n                solver_state_sp=solver_state_sp, solver_state_sde=solver_state_sde)\n\n\n# define the scan function - one step of the SDE + ODE coupled system\n\n@jax.jit\ndef scan_fun(state: SimState, tnext: Float[jax.Array, \"\"],) -&gt; tuple[SimState, Log]:\n    # time-step SDE for self-propulsion orientation\n    theta = state.geommesh.vertex_attribs[VertexAttribs.SP_ORIENTATION]\n    theta, _, _, solver_state_sde, _ = solver_sde.step(term_sde, state.tprev, tnext, theta,\n                                                       None, state.solver_state_sde, made_jump=False)\n    # time-step ODE for vertex positions\n    args_sp = (state.hemesh, a0, p0, v0, ka, kp,)\n    geommesh, _, _, solver_state_sp, _ = solver_sp.step(term_sp, state.tprev, tnext, state.geommesh, args_sp,\n                                                        state.solver_state_sp, made_jump=False,)\n    geommesh = dataclasses.replace(geommesh, vertex_attribs={VertexAttribs.SP_ORIENTATION: theta})\n    # T1 transitions for connectivity\n    hemesh, cooldown_counter, to_flip = apply_flips(geommesh, state.hemesh,l_min_T1,\n                                                    state.cooldown_counter, cooldown_steps,)\n    # make measurements for log\n    energy = energy_ap(geommesh, hemesh, a0, p0, ka, kp)\n    n_flips=to_flip.sum()\n    log = Log(geommesh=geommesh, hemesh=hemesh,\n              energy=energy, n_flips=n_flips)\n    # package next state\n    next_state = SimState(geommesh=geommesh, hemesh=hemesh,\n                          cooldown_counter=cooldown_counter, tprev=tnext,\n                          solver_state_sp=solver_state_sp, solver_state_sde=solver_state_sde)\n    return next_state, log\n\n\n# Time stepping: scan advances (tprev -&gt; tnext) for both theta and vertex dynamics.\nfinal_state, logs = jax.lax.scan(scan_fun, init, timepoints)\n\n\n# Measurements logged at each step: geometry, connectivity, energy, and T1 flip counts.\n\ngeommesh_traj = msh.tree_unstack(logs.geommesh)\nhemesh_traj = msh.tree_unstack(logs.hemesh)\n\n\n\nVisualize trajectory\n\n# total displacement\nnp.linalg.norm(geommesh_traj[0].vertices-geommesh_traj[-1].vertices, axis=-1).mean()\n\nnp.float64(0.0994635637342046)\n\n\n\nfig = plt.figure(figsize=(4, 3))\n\nskip = int(np.ceil(n_steps/1000))\nplt.plot(logs.energy[::skip])\nplt.xlabel(\"step\")\nplt.ylabel(\"energy\")\n\n# add a twin y axis that shows the cummulative number of flips\nax2 = plt.gca().twinx()\nax2.plot(jnp.cumsum(logs.n_flips)[::skip], color=\"orange\")\nax2.set_ylabel(\"cumulative flips\", color=\"orange\")\nax2.set_ylim([0,logs.n_flips.sum()+1])\n\n\n\n\n\n\n\n\n\n# angle dynamics are stochastic\n\nfig = plt.figure(figsize=(4, 3))\n\ncell_id = 50\n\nplt.plot(logs.geommesh.vertex_attribs[VertexAttribs.SP_ORIENTATION][:, ::20])\n\nplt.xlabel(\"step\")\nplt.ylabel(\"orientation\")\n\nText(0, 0.5, 'orientation')\n\n\n\n\n\n\n\n\n\n\nfig, ax = plt.subplots(figsize=(4, 4))\n\n#plt.triplot(*geommesh_traj_sde[0].vertices.T, hemesh_traj_sde[0].faces)\n\n#plt.triplot(*geommesh_traj_sde[-1].vertices.T, hemesh_traj_sde[-1].faces)\n#plt.scatter(*geommesh_final.vertices.T, c=areas, cmap=\"viridis\", s=20, vmin=0)\n\n\ngeommesh_traj[-1] = msh.set_voronoi_face_positions(geommesh_traj[-1], hemesh_traj[-1])\n\nax.add_collection(msh.cellplot(hemesh_traj[0], geommesh_traj[0].face_positions,\n                               cell_colors=np.array([0.7, 0.7, 0.9, 0.2]),\n                               mpl_polygon_kwargs={\"lw\": 0.5, \"ec\": \"tab:blue\"}))\nax.add_collection(msh.cellplot(hemesh_traj[-1], geommesh_traj[-1].face_positions,\n                               cell_colors=np.array([0.9, 0.6, 0.6, 0.2]),\n                               mpl_polygon_kwargs={\"lw\": 0.5, \"ec\": \"tab:red\"}))\n\n\n\nax.set_aspect(\"equal\")\nax.autoscale_view();",
    "crumbs": [
      "Area-perimeter self-propelled Voronoi model"
    ]
  },
  {
    "objectID": "05_example_simulation.html",
    "href": "05_example_simulation.html",
    "title": "Simulation test case - optimize mesh to make triangles equilateral",
    "section": "",
    "text": "Let’s start with a simple test case to see triangulax in action. The goal is to move the vertices \\(\\mathbf{v}_i\\) of a triangulation so that all triangle edge lengths are as close to some \\(\\ell_0\\) as possible. We specify a pseudo-energy \\(E=\\sum_{ij} (|\\mathbf{v}_i-\\mathbf{v}_j| - \\ell_0)^2\\), and then minimize it using the JAX-provided gradients w.r.t the vertex positions.\nThis defines the “forward pass” of our “dynamical” model. In a second step, we can meta-optimize over the model parameters (here \\(\\ell_0\\)), to make the dynamics return some desired shape.\n\n\nJAX-compatible scientific computing libraries - useful in future steps\nimport diffrax # ODE solvers\nimport lineax # linear solvers\nimport optimistix # optimisation (scientific-computing style, e.g. conjugate gradient)\nimport optax # optimisation (ML-style, e.g. ADAM)\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport copy\n\nfrom tqdm.notebook import tqdm\n\n\nimport jax\nimport jax.numpy as jnp\n\n\njax.config.update(\"jax_enable_x64\", True)\njax.config.update(\"jax_debug_nans\", True)\njax.config.update('jax_log_compiles', False)\n\n\nimport diffrax\nimport equinox as eqx\n\n# equinox has automated \"filtering\" of JAX-transforms. So we can work with objects which are not just pytrees of arrays\n# (like neural networks) and appy jit, vmap etc\n\n\nfrom jaxtyping import Float\n\nfrom typing import Tuple\nimport dataclasses\nimport functools\n\n\n# import previously defined modules\n\nfrom triangulax import trigonometry as trg\nfrom triangulax import mesh as msh\nfrom triangulax.triangular import TriMesh\nfrom triangulax.mesh import HeMesh, GeomMesh\nfrom triangulax import linops as lin\n\n\n\nLoad example mesh\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = GeomMesh(*hemesh.n_items, vertices=mesh.vertices)\n\nhemesh\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\nHeMesh(N_V=131, N_HE=708, N_F=224)\n\n\n\nfig = plt.figure(figsize=(4, 4))\nplt.triplot(*geommesh.vertices.T, mesh.faces)\nplt.axis(\"equal\");\n\n\n\n\n\n\n\n\n\n\nForward pass - minimize energy\nWe write the energy_function using a geommesh as an argument. This is overkill for present purposes ince only the vertex positions matter, but is useful to test the machinery. For more complicated simulations, we will want to use GeomMesh as a wrapper for the various arrays.\n\ndef get_lengths(vertices: Float[jax.Array, \"n_vertices 2\"], hemesh: msh.HeMesh) -&gt; Float[jax.Array, \"n_hes 2\"]:\n    return jnp.linalg.norm(vertices[hemesh.orig]-vertices[hemesh.dest], axis=-1)\n\n@jax.jit\ndef energy_function(geommesh: GeomMesh, hemesh: HeMesh, ell_0: float=1):\n    edge_lengths = get_lengths(geommesh.vertices, hemesh)\n    edge_energy = jnp.mean((edge_lengths/ell_0-1)**2) # this way, term is \"auto-normalized\"\n    # let's add a term for the triangle areas. Use the oriented area to penalize invalid mesh configurations\n    a_0 = (np.sqrt(3)/4) * ell_0**2 # area of equilateral triangle\n    tri_area = jax.vmap(trg.get_oriented_triangle_area)(*geommesh.vertices[hemesh.faces.T])\n\n    area_energy = jnp.mean((tri_area/a_0-1)**2)\n    #jax.debug.print(\"E_l: {E_l}, E_a: {E_a}\",  E_l=edge_energy, E_a=area_energy)\n    # this is how you can print inside a JITed-function\n    return edge_energy + area_energy\n\n\nval, grad = jax.value_and_grad(energy_function)(geommesh, hemesh) # computing value and gradient of the energy\nval, grad, grad.vertices.shape # the gradient is another GeomMesh. 1.60519339\n\n(Array(1.60519339, dtype=float64),\n GeomMesh(D=2,N_V=131, N_HE=708, N_F=224),\n (131, 2))\n\n\n\nconnectivity_grad = jax.grad(energy_function, argnums=1, allow_int=True)(geommesh, hemesh)\n# we can even compute the gradient w.r.t to the connectivity matrix. It is also a HeMesh\nconnectivity_grad, connectivity_grad.dest[0] # whatever that means\n\n(HeMesh(N_V=131, N_HE=708, N_F=224), np.void((b'',), dtype=[('float0', 'V')]))\n\n\n\nEnergy optimization\nLet’s follow the patterns for writing a simulation time-stepping loop described in notebook 02.\n\n# time-stepping function\n@jax.jit\ndef make_step(geommesh: GeomMesh, hemesh: HeMesh,\n              current_time: Float[jax.Array, \"\"], next_time: Float[jax.Array, \"\"], ell_0: float = 1):\n    loss, grad = jax.value_and_grad(energy_function)(geommesh, hemesh, ell_0=ell_0)\n    updated_vertices = geommesh.vertices - (next_time-current_time)*grad.vertices\n    geommesh = dataclasses.replace(geommesh, vertices=updated_vertices)\n    return (geommesh, hemesh), loss # explicitly return the hemesh - may need to be updated by flips!\n\n\n# simulation timesteps\nstep_size = 0.02\nN_steps = 20000\ntimepoints = step_size * jnp.arange(N_steps) \n\n# parameters of the energy\nell_0 = 0.5\n\n# inital condition\ninit = ((geommesh, hemesh), timepoints[0])\n\n# scanning function - applied at each time-step\ndef scan_function(carry, next_time: jax.Array):\n    (geommesh, hemesh), current_time = carry \n    (geommesh, hemesh), loss = make_step(geommesh, hemesh, current_time, next_time, ell_0=ell_0)\n    return ((geommesh, hemesh), next_time), loss # log the loss/energy\n\n\n# run the simulation\n((geommesh_optimized, hemesh_optimized), _), loss = jax.lax.scan(scan_function, init, timepoints)\n\n\nfig = plt.figure(figsize=(4, 3))\nplt.plot(loss)\n\n\n\n\n\n\n\n\n\nfig = plt.figure(figsize=(4, 4))\nplt.triplot(*geommesh.vertices.T, hemesh.faces)\nplt.triplot(*geommesh_optimized.vertices.T, hemesh_optimized.faces)\nplt.axis(\"equal\");\n\n\n\n\n\n\n\n\n\n\nUsing an ODE solver - diffrax\nAbove, we implemented “gradient descent” for the pseudo-energy, or, equivalently, a basic forward-Euler scheme for the ODE \\(\\partial_t \\mathbf{v}_i = - \\nabla_{\\mathbf{v}_i} E\\). For more complicated models, and to minimize coding effort, it makes sense to use a pre-made ODE solver instead. The diffrax library implements ODE and SDE solvers in JAX and is compatible with autodiff (you can differentiate through the solver), since it was designed for neural differential equations.\nFor “adiabatic” dynamics, which involve mimizing an energy at every timestep, we can use the “optimistix” library.\nThe below is based on the Stepping through a solver tutorial in diffrax. The reason we want to step through the solver one-by-one is to carry out T1s (in future simulations).\n\n# define the RHS for the ODE solver\n@jax.jit\ndef vector_field(t, y, args):\n    return jax.tree_util.tree_map(lambda x: -1*x, jax.grad(energy_function)(y, *args))\nterm = diffrax.ODETerm(vector_field)\n\n# define time parameters and initial condition\ndt = 0.05\nt0 = 0.0\nt1 = 1000.0\nstep_times = jnp.arange(t0, t1, dt)\n\ny0 = geommesh\nargs = (hemesh, ell_0)\n\n# initialize the solver\nsolver = diffrax.Tsit5()\ny = y0\nstate = solver.init(term, t0, t0+dt, y0, args)\n\n\n# scan through the solve\n\ndef scan_fun(carry, t):\n    state, y, tprev = carry \n    y, _, _, state, _ = solver.step(term, tprev, t, y, args, state, made_jump=False)\n    return (state, y, t), None\n\ninit = (state, y0, t0)\n(state, y, t), _ = jax.lax.scan(scan_fun, init, step_times[1:])\n\n\nfig = plt.figure(figsize=(4, 4))\nplt.triplot(*y0.vertices.T, hemesh.faces)\nplt.triplot(*y.vertices.T, hemesh.faces)\nplt.axis(\"equal\");\n\n\n\n\n\n\n\n\n\n\n\nMeta-training\nOne use case for JAX is to differentiate through a scientific simulation, allowing one to optimize the simulation parameters towards some some desired behavior. For example, we may wish to find a triangulation dynamics that creates some target shape.\nAs a toy example, let’s take the above “dynamics” which minimizes the pseudo-energy to make all triangles equilateral. It depends on the parameter \\(\\ell_0\\). Relaxation of the pseudo-energy for some number of steps defines our “forward pass”. Let’s try to optimize \\(\\ell_0\\) so that the tissue, at the end of the energy relaxation, has some target size (of course, a contrived problem, since we know the solution from the start).\nFirst, we wrap our dynamical model as an eqx.Module, so we can optimize it just like a neural net.\n\nclass RelaxationDynamics(eqx.Module):\n    ell_0: jax.Array\n    step_size : float = eqx.field(static=True)\n    N_steps : int = eqx.field(static=True)\n\n    def __call__(self, initial_geommesh: GeomMesh, initial_hemesh: HeMesh) -&gt; Tuple[GeomMesh, HeMesh]:\n        init = ((initial_geommesh, initial_hemesh), 0)\n        def scan_fun(i, carry):\n            (geommesh, hemesh), _ = carry\n            return make_step(geommesh, hemesh, ell_0=self.ell_0,\n                             current_time=i*self.step_size, next_time=(i+1)*self.step_size)\n        (geommesh_optimized, hemesh_optimized), _ = jax.lax.fori_loop(0, N_steps, scan_fun, init, unroll=None)\n        return geommesh_optimized, hemesh_optimized\n\n\nDefine Meta-training loss\nNow we need to define our meta-training loss. In this case, it’s just the deviation of the average edge length from the total. Note how the meta-loss is distinct from the pseudo-energy we minimize during the forward pass.\nLet’s use the equinox library to handle our problem, in anticipation of more complex ones down the line.\n\n# define the meta-loss\n\ndef meta_loss(model: RelaxationDynamics, initial_geommesh: GeomMesh, initial_hemesh: HeMesh,  meta_ell0: float) -&gt; float:\n    geommesh_optimized, hemesh_optimized = model(initial_geommesh, initial_hemesh)\n    lengths = get_lengths(geommesh_optimized.vertices,  hemesh_optimized)\n    return jnp.mean((lengths/meta_ell0-1)**2)\n\n\n# initialize the model, and test the meta loss\n\ninitial_ell0 = 0.4\nmeta_ell0 = 0.3\n\nmodel_initial = RelaxationDynamics(ell_0=jnp.array([initial_ell0]), step_size=step_size, N_steps=N_steps)\nmodel_initial(geommesh, hemesh), meta_loss(model_initial, geommesh, hemesh, meta_ell0=meta_ell0)\n\n((GeomMesh(D=2,N_V=131, N_HE=708, N_F=224),\n  HeMesh(N_V=131, N_HE=708, N_F=224)),\n Array(0.13074658, dtype=float64))\n\n\n\n\nBatching\nTo evaluate the loss, we want to average over a bunch of initial conditions. These are analogous to batches in a normal ML problem.\n\n## Let's create a bunch of meshes with different initial positions and see if we can batch over them using vmap\n\nkey = jax.random.key(0)\nsigma = 0.02\nN_batch = 3\n\nbatch_geom = []\nbatch_he = []\nfor i in range(N_batch):\n    key, subkey = jax.random.split(key)\n    random_noise = jax.random.normal(subkey, shape=geommesh.vertices.shape)\n    batch_geom.append(dataclasses.replace(geommesh, vertices=geommesh.vertices+sigma*random_noise))\n    batch_he.append(copy.copy(hemesh))\n\n# we use a jax.tree.map to \"push\" the list axis into the underlying arrays.\n# the result is a single mesh object with batch axes\n\nbatch_he_array = msh.tree_stack(batch_he)\nbatch_geom_array = msh.tree_stack(batch_geom)\n\nbatch_geom_array, batch_geom_array.vertices.shape\n\n(GeomMesh(D=2,N_V=131, N_HE=708, N_F=224), (3, 131, 2))\n\n\n\n# We can apply the simulation and upack the results into a list\n\nbatch_geom_array_out, batch_he_array_out = jax.vmap(model_initial)(batch_geom_array, batch_he_array) \nbatch_geom_out = msh.tree_unstack(batch_geom_array_out)\nbatch_he_out = msh.tree_unstack(batch_he_array_out)\n\n\n# still works\n\ni = 2\nfig = plt.figure(figsize=(4, 4))\nplt.triplot(*batch_geom[i].vertices.T, batch_he[i].faces)\nplt.triplot(*batch_geom_out[i].vertices.T, batch_he_out[i].faces)\nplt.axis(\"equal\");\n\n\n\n\n\n\n\n\n\nCompute the batched loss\n\n# This is the right way to vmap the loss\njax.vmap(meta_loss, in_axes=(None, 0, 0, None))(model_initial, batch_geom_array, batch_he_array, 0.8)\n\nArray([0.24862355, 0.24863542, 0.24863226], dtype=float64)\n\n\n\n# check against non-vmapped version. pretty similar, floating point errors likely at origin of differences\n[meta_loss(model_initial, batch_geom_out[i], batch_he_out[i], 0.8) for i in range(3)]\n\n[Array(0.24848931, dtype=float64),\n Array(0.24848805, dtype=float64),\n Array(0.2484898, dtype=float64)]\n\n\n\n\n\n\nMeta-optimization\nNow we are in a position to “optiomize” our model parameter ell_0. Based on equinox CNN tutorial.\n\ndef batched_meta_loss(model, batch_geom_array, batch_he_array, meta_ell0):\n    return jnp.mean(jax.vmap(meta_loss, in_axes=(None, 0,0, None))(model, batch_geom_array, batch_he_array, meta_ell0))\n\nbatched_meta_loss_jit = jax.jit(batched_meta_loss)\n\n\n# hyper-parameters for the outer learning step.\n\nLEARNING_RATE = 1e-2\nLEARNING_STEPS = 20\nprint_every = 2\n\nstep_size = 0.01\nN_steps = 20000\n\nMETA_ELL0 = 0.4\ninitial_ell0 = 0.2\n\nmodel_initial = RelaxationDynamics(ell_0=jnp.array([initial_ell0]), step_size=step_size, N_steps=N_steps)\n\n\nloss, grads = eqx.filter_jit(eqx.filter_value_and_grad(batched_meta_loss))(model_initial,\n                                                                           batch_geom_array, batch_he_array, META_ELL0)\n\nloss, grads, grads.ell_0\n\n(Array(0.24848878, dtype=float64),\n RelaxationDynamics(ell_0=f64[1], step_size=0.01, N_steps=20000),\n Array([-2.48070057], dtype=float64))\n\n\n\nForward and reverse mode autodiff\nSince we are differentiation w.r.t. a small number of parameters (justy 1: \\(\\ell_0\\)), we can use forward mode automatic differentiation for increased efficiency. This may be the case more generally: if we want to learn “translationally invariant” models, where the parameters for all cells are equal, the parameter count we want to differentiate by may be small. Forward mode autodiff is also somewhat more “forgiving” when it comes to control flow.\nSee: https://docs.jax.dev/en/latest/notebooks/autodiff_cookbook.html\n\n@eqx.filter_jit\ndef outer_optimizer_step(model: RelaxationDynamics,\n                         batch_geom: GeomMesh, batch_he: HeMesh) -&gt; Tuple[RelaxationDynamics, float]:\n    \n    # compute loss and grad on batch\n    loss, grads = eqx.filter_value_and_grad(batched_meta_loss)(model, batch_geom_array, batch_he_array, META_ELL0)\n    updates = jax.tree.map(lambda g: None if g is None else -LEARNING_RATE * g, grads)\n    model = eqx.apply_updates(model, updates)\n    # grads is a PyTree with the same leaves as the trainable arrays of the model\n\n    # same story, but using forward mode autodiff\n    #loss, grads = eqx.filter_jvp(lambda model: batched_meta_loss(model, batch_geom_array, batch_he_array, META_ELL0),\n    #                             primals=[model,], tangents=[model,])\n    #grads = grads/model.ell_0 # we used the current model values as a tangent vector, so we need to normalize\n    #model = dataclasses.replace(model, ell_0=model.ell_0-LEARNING_RATE*grads)\n    \n    return model, loss\n\n\nmodel = model_initial\n\nfor step in tqdm(range(LEARNING_STEPS)): # in the future, could also iterate over the initial conditions/batches\n    model, loss = outer_optimizer_step(model, batch_geom_array, batch_he_array)\n    if (step % print_every) == 0:\n        print(f\"Step: {step}, loss: {loss}, param: {model.ell_0}\")\n\n# 19s with forward mode vs 32s with reverse mode.\n\n\n\n\nStep: 0, loss: 0.24848877513396528, param: [0.22480701]\nStep: 2, loss: 0.14704976288187882, param: [0.26531774]\nStep: 4, loss: 0.08837946252729935, param: [0.29610925]\nStep: 6, loss: 0.05458715535792712, param: [0.31944763]\nStep: 8, loss: 0.03524215346058218, param: [0.33709312]\nStep: 10, loss: 0.02417654272859851, param: [0.35045283]\nStep: 12, loss: 0.01779509451762013, param: [0.36062556]\nStep: 14, loss: 0.014058191845006396, param: [0.36843856]\nStep: 16, loss: 0.01182824053575723, param: [0.37449757]\nStep: 18, loss: 0.010471449413490624, param: [0.37924151]\n\n\nLooks good - the optimizer converges to the correct value of \\(\\ell_0\\).\n\n\n\nVertex, half-edge, and face properties\nIn simulations, we will often want to attach extra information to a mesh’s vertices/edges/faces. In the GeomMesh class, these are saved in three dictionaries, vertex_attribs, he_attribs, face_attribs. Each key/value pair represents one property (for example, the cell target area). All values are arrays, and the first axis corresponds to the number of vertices/half-edges/faces, respectively. To keep track of the possible attributes, we use IntEnum’s as keys (this also ensures keys are hashable, as required by JAX)\n\n# this is how you set up an enum. It is important to use IntEnum, so we can _order_ the enums.\n# The precise Enum you will use depends on your application.\n\nclass VertexAttribs(IntEnum):\n    TARGET_AREA = 1\n    TARGET_PERIMETER = 2\n\nclass HeAttribs(IntEnum):\n    EDGE_TENSION = 1\n\nclass FaceAttribs(IntEnum):\n    FACE_AREA = 1\n\n([&lt;VertexAttribs.TARGET_AREA: 1&gt;, &lt;VertexAttribs.TARGET_PERIMETER: 2&gt;], 2)\n\n\n\n# you can iterate over enums, and they are hashable. The latter is essential for JAX!\nprint([a for a in VertexAttribs])\n# there are multiple ways to access enum entries:\nhash(VertexAttribs.TARGET_PERIMETER), HeAttribs.EDGE_TENSION, HeAttribs['EDGE_TENSION'], HeAttribs.EDGE_TENSION.name\n\n[&lt;VertexAttribs.TARGET_AREA: 1&gt;, &lt;VertexAttribs.TARGET_PERIMETER: 2&gt;]\n\n\n(2, &lt;HeAttribs.EDGE_TENSION: 1&gt;, &lt;HeAttribs.EDGE_TENSION: 1&gt;, 'EDGE_TENSION')\n\n\n\n\nNext steps\nSuccess: we can solve this (stupid) toy problem. Our JAX-compatible infrastructure for vertex models seems to work, and we can autodiff through a simulation. Next steps:\n\nToy simulations with T1s\nMore complex models - say, the area-perimeter vertex model\nPlay around with neural ODEs and neural optimizers more generally.",
    "crumbs": [
      "Simulation test case - optimize mesh to make triangles equilateral"
    ]
  },
  {
    "objectID": "00_trigonometry.html",
    "href": "00_trigonometry.html",
    "title": "triangulax",
    "section": "",
    "text": "For example, the circumcenter of a triangle, which is the position of the dual Voronoi vertex.\n\n\nThroughout, we will (attempt to) provide a type signature for all functions. To do so for array-based functions, we use jaxtyping.\n\n\n\nThe aim is to create a triangulation datastructure compatible with the JAX library for automatic differentiation and numerical computing. In practice, this means that we use jnp (=jax.numpy) instead of numpy, and make sure our code follows JAX’s functional programming paradigm (see JAX- the sharp bits). There is also some extra legwork to register any new classes with JAX.\n\nsource\n\n\n\n\ndef get_perp_2d(\n    x:Float[Array, '... 2']\n)-&gt;Float[Array, '... 2']:\n\nGet perpendicular vector.\n\nsource\n\n\n\n\ndef get_rot_mat(\n    theta:float\n)-&gt;Float[Array, '2 2']:\n\nGet 2D rotation matrix from angle in radians.\n\nsource\n\n\n\n\ndef get_cot_between_vectors(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim']\n)-&gt;Float[Array, '']:\n\nCotangent of angle between two vectors\n\nsource\n\n\n\n\ndef get_angle_between_vectors(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim']\n)-&gt;Float[Array, '']:\n\nAngle between two vectors\n\nsource\n\n\n\n\ndef get_voronoi_corner_perimeter(\n    a:Float[Array, '2'], b:Float[Array, '2'], c:Float[Array, '2'], zero_clip:float=1e-10\n)-&gt;Float[Array, '']:\n\nCompute contribution to Voronoi perimeter at corner a of triangle abc. Can be negative! 2d only atm.\n\nsource\n\n\n\n\ndef get_voronoi_corner_area(\n    a:Float[Array, '2'], b:Float[Array, '2'], c:Float[Array, '2'], zero_clip:float=1e-10\n)-&gt;Float[Array, '']:\n\nCompute Voronoi area at corner a of triangle abc. Returns zero for a degenerate triangle. 2d only atm.\nTO DO: does this yield correct results for self-intersecting corner slices (circumcenter outside of triangle)?\n\nsource\n\n\n\n\ndef get_polygon_area(\n    pts:Float[Array, 'n_vertices 2']\n)-&gt;Float[Array, '']:\n\nArea of 2D polygon assuming no self-intersection.\n\nsource\n\n\n\n\ndef get_triangle_area(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim'], c:Float[Array, 'dim']\n)-&gt;Float[Array, '']:\n\nArea of triangle with vertices a, b, c. Works in dim 2 or 3.\n\nsource\n\n\n\n\ndef get_oriented_triangle_area(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim'], c:Float[Array, 'dim']\n)-&gt;Float[Array, '*']:\n\nSigned area of triangle with vertices a, b, c. If d=2, returns a scalar, if d=3, a vector.\n\nsource\n\n\n\n\ndef get_circumcenter(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim'], c:Float[Array, 'dim'], zero_clip:float=1e-10\n)-&gt;Float[Array, 'dim']:\n\nReturn circumcenter coordinates of triangle with vertices a, b, c\n\nget_polygon_area(jnp.array([[0.,0.], [0.,1.], [1.,0.]]) ), get_triangle_area(*jnp.array([[0.,0.], [0.,1.], [1.,0.]]) )\n\n(Array(0.5, dtype=float64), Array(0.5, dtype=float64))\n\n\n\nget_circumcenter(jnp.array([0.,0.]), jnp.array([0.,1.]),  jnp.array([1.,0.]))\n\nArray([0.5, 0.5], dtype=float64)\n\n\n\nget_circumcenter(jnp.array([1.,0.]), jnp.array([1.,0.]),  jnp.array([0.,1.]))\n\nArray([0., 0.], dtype=float64)\n\n\n\nget_circumcenter(jnp.array([1.,0.]), jnp.array([2.,0.]),  jnp.array([1.,0.]))\n\nArray([0., 0.], dtype=float64)\n\n\n\nget_voronoi_corner_area(jnp.array([0.,0.]), jnp.array([0.,1.]),  jnp.array([1.,0.]))\n\nArray(-0.25, dtype=float64)\n\n\n\nget_voronoi_corner_perimeter(jnp.array([0., 0.]), jnp.array([1., 0.]), jnp.array([0., 1.]))\n\nArray(1., dtype=float64)\n\n\n\n\n\n\nsource\n\n\n\n\ndef quaternion_to_rot_max(\n    q:Float[Array, '4']\n)-&gt;Float[Array, '3 3']:\n\nConvert unit quaternion into a 3d rotation matrix.\nSee https://fr.wikipedia.org/wiki/Quaternions_et_rotation_dans_l%27espace\n\nsource\n\n\n\n\ndef get_triangle_normal(\n    a:Float[Array, '3'], b:Float[Array, '3'], c:Float[Array, '3']\n)-&gt;Float[Array, '3']:\n\nCompute unit normal vector of triangle abc.\n\n\n\n\nsource\n\n\n\n\ndef get_barycentric_coordinates(\n    point:Float[Array, 'dim'], a:Float[Array, 'dim'], b:Float[Array, 'dim'], c:Float[Array, 'dim'],\n    zero_clip:float=1e-10, normalize:bool=True\n)-&gt;Float[Array, '3']:\n\nCompute barycentric coordinates of point with respect to triangle abc.\n\nvertices = jnp.array([[0., 0 ], [0., 1.], [1., 0.]])\npoint1 = jnp.array([0.5, 0.2])\n\nget_barycentric_coordinates(point1, *vertices, normalize=False)\n\nArray([0. , 0.2, 0.5], dtype=float64)\n\n\n\nvertices2 = jnp.array([[0., 0, 0], [0., 1., 0], [1., 0., 0]])\npoint2 = jnp.array([0.5, 0.2, 0.])\n\nget_barycentric_coordinates(point2, *vertices2, normalize=False)\n\nArray([0. , 0.2, 0.5], dtype=float64)\n\n\n\npoint3 = jnp.array([0.5, 0.2, 1.])\n\nget_barycentric_coordinates(point3, *vertices2, normalize=False)\n\nArray([0. , 0.2, 0.5], dtype=float64)",
    "crumbs": [
      "Basic trigonometry"
    ]
  },
  {
    "objectID": "00_trigonometry.html#basic-trigonometry",
    "href": "00_trigonometry.html#basic-trigonometry",
    "title": "triangulax",
    "section": "",
    "text": "For example, the circumcenter of a triangle, which is the position of the dual Voronoi vertex.\n\n\nThroughout, we will (attempt to) provide a type signature for all functions. To do so for array-based functions, we use jaxtyping.\n\n\n\nThe aim is to create a triangulation datastructure compatible with the JAX library for automatic differentiation and numerical computing. In practice, this means that we use jnp (=jax.numpy) instead of numpy, and make sure our code follows JAX’s functional programming paradigm (see JAX- the sharp bits). There is also some extra legwork to register any new classes with JAX.\n\nsource\n\n\n\n\ndef get_perp_2d(\n    x:Float[Array, '... 2']\n)-&gt;Float[Array, '... 2']:\n\nGet perpendicular vector.\n\nsource\n\n\n\n\ndef get_rot_mat(\n    theta:float\n)-&gt;Float[Array, '2 2']:\n\nGet 2D rotation matrix from angle in radians.\n\nsource\n\n\n\n\ndef get_cot_between_vectors(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim']\n)-&gt;Float[Array, '']:\n\nCotangent of angle between two vectors\n\nsource\n\n\n\n\ndef get_angle_between_vectors(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim']\n)-&gt;Float[Array, '']:\n\nAngle between two vectors\n\nsource\n\n\n\n\ndef get_voronoi_corner_perimeter(\n    a:Float[Array, '2'], b:Float[Array, '2'], c:Float[Array, '2'], zero_clip:float=1e-10\n)-&gt;Float[Array, '']:\n\nCompute contribution to Voronoi perimeter at corner a of triangle abc. Can be negative! 2d only atm.\n\nsource\n\n\n\n\ndef get_voronoi_corner_area(\n    a:Float[Array, '2'], b:Float[Array, '2'], c:Float[Array, '2'], zero_clip:float=1e-10\n)-&gt;Float[Array, '']:\n\nCompute Voronoi area at corner a of triangle abc. Returns zero for a degenerate triangle. 2d only atm.\nTO DO: does this yield correct results for self-intersecting corner slices (circumcenter outside of triangle)?\n\nsource\n\n\n\n\ndef get_polygon_area(\n    pts:Float[Array, 'n_vertices 2']\n)-&gt;Float[Array, '']:\n\nArea of 2D polygon assuming no self-intersection.\n\nsource\n\n\n\n\ndef get_triangle_area(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim'], c:Float[Array, 'dim']\n)-&gt;Float[Array, '']:\n\nArea of triangle with vertices a, b, c. Works in dim 2 or 3.\n\nsource\n\n\n\n\ndef get_oriented_triangle_area(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim'], c:Float[Array, 'dim']\n)-&gt;Float[Array, '*']:\n\nSigned area of triangle with vertices a, b, c. If d=2, returns a scalar, if d=3, a vector.\n\nsource\n\n\n\n\ndef get_circumcenter(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim'], c:Float[Array, 'dim'], zero_clip:float=1e-10\n)-&gt;Float[Array, 'dim']:\n\nReturn circumcenter coordinates of triangle with vertices a, b, c\n\nget_polygon_area(jnp.array([[0.,0.], [0.,1.], [1.,0.]]) ), get_triangle_area(*jnp.array([[0.,0.], [0.,1.], [1.,0.]]) )\n\n(Array(0.5, dtype=float64), Array(0.5, dtype=float64))\n\n\n\nget_circumcenter(jnp.array([0.,0.]), jnp.array([0.,1.]),  jnp.array([1.,0.]))\n\nArray([0.5, 0.5], dtype=float64)\n\n\n\nget_circumcenter(jnp.array([1.,0.]), jnp.array([1.,0.]),  jnp.array([0.,1.]))\n\nArray([0., 0.], dtype=float64)\n\n\n\nget_circumcenter(jnp.array([1.,0.]), jnp.array([2.,0.]),  jnp.array([1.,0.]))\n\nArray([0., 0.], dtype=float64)\n\n\n\nget_voronoi_corner_area(jnp.array([0.,0.]), jnp.array([0.,1.]),  jnp.array([1.,0.]))\n\nArray(-0.25, dtype=float64)\n\n\n\nget_voronoi_corner_perimeter(jnp.array([0., 0.]), jnp.array([1., 0.]), jnp.array([0., 1.]))\n\nArray(1., dtype=float64)\n\n\n\n\n\n\nsource\n\n\n\n\ndef quaternion_to_rot_max(\n    q:Float[Array, '4']\n)-&gt;Float[Array, '3 3']:\n\nConvert unit quaternion into a 3d rotation matrix.\nSee https://fr.wikipedia.org/wiki/Quaternions_et_rotation_dans_l%27espace\n\nsource\n\n\n\n\ndef get_triangle_normal(\n    a:Float[Array, '3'], b:Float[Array, '3'], c:Float[Array, '3']\n)-&gt;Float[Array, '3']:\n\nCompute unit normal vector of triangle abc.\n\n\n\n\nsource\n\n\n\n\ndef get_barycentric_coordinates(\n    point:Float[Array, 'dim'], a:Float[Array, 'dim'], b:Float[Array, 'dim'], c:Float[Array, 'dim'],\n    zero_clip:float=1e-10, normalize:bool=True\n)-&gt;Float[Array, '3']:\n\nCompute barycentric coordinates of point with respect to triangle abc.\n\nvertices = jnp.array([[0., 0 ], [0., 1.], [1., 0.]])\npoint1 = jnp.array([0.5, 0.2])\n\nget_barycentric_coordinates(point1, *vertices, normalize=False)\n\nArray([0. , 0.2, 0.5], dtype=float64)\n\n\n\nvertices2 = jnp.array([[0., 0, 0], [0., 1., 0], [1., 0., 0]])\npoint2 = jnp.array([0.5, 0.2, 0.])\n\nget_barycentric_coordinates(point2, *vertices2, normalize=False)\n\nArray([0. , 0.2, 0.5], dtype=float64)\n\n\n\npoint3 = jnp.array([0.5, 0.2, 1.])\n\nget_barycentric_coordinates(point3, *vertices2, normalize=False)\n\nArray([0. , 0.2, 0.5], dtype=float64)",
    "crumbs": [
      "Basic trigonometry"
    ]
  }
]