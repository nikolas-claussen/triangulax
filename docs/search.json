[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "triangulax",
    "section": "",
    "text": "This package provides data-structures for triangular meshes and functions for geometry processing based on JAX and fully compatible with JAX’s just-in-time compilation and automatic differentiation.\nThe current use case is to create a simulation framework for the mechanics of 2D tissues (Active tension networks, area-perimeter vertex model, non-confluent tissues like in Kim, 2021) compatible with automatic differentiation/JAX. The ultimate goal is to use gradient-based optimization to identify models for tissue dynamics that produce certain behaviors of interest.",
    "crumbs": [
      "triangulax"
    ]
  },
  {
    "objectID": "index.html#developer-guide",
    "href": "index.html#developer-guide",
    "title": "triangulax",
    "section": "Developer Guide",
    "text": "Developer Guide\nThis package is developed based on jupyter notebooks, which are converted into python modules using nbdev.\n\nInstall triangulax in Development mode\n\nClone the github repository\n\n$ git clone https://github.com/nikolas-claussen/triangulax.git\n\nCreate a conda environment with all Python dependencies\n\n$ conda env create -n triangulax -f triangulax.yml\n$ conda activate triangulax\n\nInstall the triangulax package\n\n# make sure triangulax package is installed in development mode\n$ pip install -e .\n\nIf necessary, edit the package notebooks and export\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to triangulax\n$ nbdev_prepare",
    "crumbs": [
      "triangulax"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "triangulax",
    "section": "Usage",
    "text": "Usage\n\nDocumentation\nDocumentation can be found hosted on this GitHub repository’s pages.",
    "crumbs": [
      "triangulax"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "triangulax",
    "section": "How to use",
    "text": "How to use\nCurrently, only the mesh module is complete. It contains a half-edge data structure for triangular meshes compatible with JAX.\n\nimport igl\nimport jax.numpy as jnp\nfrom triangulax import mesh as msh\n\n\n# load example mesh and convert to half-edge mesh\nvertices, _, _, faces, _, _ = igl.readOBJ(\"test_meshes/disk.obj\")\nhemesh = msh.HeMesh.from_triangles(vertices.shape[0], faces)\n\n# with the half-edge mesh, you can carry out various operations, like computing the coordination number by summing incoming half-edges per vertex\n\ncoord_number = jnp.zeros(hemesh.n_vertices)\ncoord_number.at[hemesh.dest].add(jnp.ones(hemesh.n_hes))\n\n2",
    "crumbs": [
      "triangulax"
    ]
  },
  {
    "objectID": "01_triangular_meshes.html",
    "href": "01_triangular_meshes.html",
    "title": "triangulax",
    "section": "",
    "text": "triangulax is a library for working with triangular meshes using JAX. In this notebook, however, we define some tools for loading, processing, and saving triangular meshes outside of JAX. The dataclass TriMesh keeps the different pieces of a triangulation in one place. The use case of this module is to interface with JAX-external code, like the excellent igl geometry processing library, prepare initial conditions for simulations, etc. The data structure for JAX-based code is defined in the mesh module, notebook 03.\nThe simplest way to represent a triangulation is by a list of vertices and faces (triangles):\n\nA set of vertices, i.e., a \\((N_V, 2)\\) dimensional array datatype float.\nA set of faces, a \\((N_F, 3)\\) dimensional array of datatype int. Each row is an ordered triple of vertex indices that form a face.\n(Optional) A set of face centers, a \\((N_F, 2)\\) dimensional array of datatype float. An entry is the position of the dual vertex of a the triangulation face (think circumcenter).\n\nTo read and write, we use the .obj-file format. We will also make heavy use of the igl geometry processing library. The TriMesh class is a “holder” for loading, saving, visualizing, etc meshes, and not to be used for numerical computation. .\n\n\nOne use case of triangulax is simulations of 2D cell tilings. The simplest way to represent a cell tiling is by its dual triangular mesh (one triangulation vertex per cell). We will represent cell tilings by 2D Voronoi tessellations and variants thereof (like power diagrams). This means that we can represent the cell network as a 2D triangulation with vertices \\(V\\) and faces \\(F\\). We will first consider the case where the number of vertices does not change. Cells can, however, rearrange (T1-transitions/edge flips in the triangulation). Such flips also conserve the number of faces and edges.\n\nsource\n\n\n\n\ndef TriMesh(\n    vertices:Float[Array, 'n_vertices dim'], faces:Int[Array, 'n_faces 3'], face_positions:Union=None\n)-&gt;None:\n\nSimple class for reading, holding, transforming, and saving triangular meshes.\nA TriMesh comprises vertices and faces, describing a surface in 2d or 3d. In addition, there can be a 2d/3d position for every face (think Voronoi dual of the triangulation).\nVertices and faces are jnp.arrays. Each face is a triple of vertex indices. Vertices and faces are ordered - this is essential so that we know which attribute vector entry goes to which vector/edge/face. Faces in a face are assumed to be in counter-clockwise order.\nMeshes are read and written in the .obj format (https://en.wikipedia.org/wiki/Wavefront_.obj_file). To store face_positions, we abuse the vn (vertex normal) entry of an .obj file. Face positions will be written in order corresponding to faces. When reading from an .obj file, edges are recomputed from faces and initialized in alpha-numerical ordering. An .obj file expects 3d positions; the z-position is ignored when reading and set to 0 when writing for 2d meshes.\nAttributes\ndim : int = 2\nvertices : Float[jax.Array, “n_vertices dim”]\nfaces : Int[jax.Array, “n_faces 3”]\nface_positions : Float[jax.Array, “n_faces dim”]\nProperty methods (use like attributes)\nn_vertices : int\nhas_inf_vertex : bool\nStatic methods\nread_obj : str -&gt; TriMesh\nMethods\nwrite_obj : str -&gt; None\n\n# test reading a mesh\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.float64'&gt; requested in array is not available, and will be truncated to dtype float32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.int64'&gt; requested in array is not available, and will be truncated to dtype int32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)\n\n\n\n# test computing the circumcenter of each face. should be equidistant to all vertex points\n\ndists = jnp.stack([jnp.linalg.norm(mesh.vertices[mesh.faces[:,i]]-mesh.face_positions, axis=1) for i in [0,1,2]], axis=1)\n\njnp.allclose(dists[:,0], dists[:,1]) and jnp.allclose(dists[:,1], dists[:,2])\n\nArray(True, dtype=bool)\n\n\n\n# test writing face positions to vn entries\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nfilename = \"test_meshes/disk_write_test.obj\"\nmesh.write_obj(filename, save_face_positions=True)\nmesh = TriMesh.read_obj(filename, read_face_positions=True)\n\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.float64'&gt; requested in array is not available, and will be truncated to dtype float32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.int64'&gt; requested in array is not available, and will be truncated to dtype int32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)\n\n\n\n\n\nSome functions to create meshes based on the Delaunay triangulation of a point set.\n\nPoisson (vertices placed uniformly at random) in disk or box\nGinibre (vertices placed at uniform with self-repulsion)\nTriangular lattice\n\nSome functions for plotting meshes:\n\nPlot triangulation with vertex and face labels (for debugging)\nPlot cell tesselation\n\n\nsource\n\n\n\n\ndef generate_triangular_lattice(\n    nx:int, ny:int\n)-&gt;Float[Array, 'nx*ny 2']:\n\nGet points for rectangular patch of triangular lattice with nx, ny points.\n\nsource\n\n\n\n\ndef generate_poisson_points(\n    n_vertices:int, limit_x:float=1, limit_y:float=1\n)-&gt;Float[Array, 'n_vertices 2']:\n\nSample n_vertices points from the Poisson ensemble in rectangle [-limit_x/2, limit_x/2] * [-limit_y/2, limit_y/2].\n\nsource\n\n\n\n\ndef generate_ginibre_points(\n    n_vertices:int\n)-&gt;Float[Array, 'n_vertices 2']:\n\nSample n_vertices points from the Ginibre ensemble. Points are scaled to unit disk.\n\n#points = generate_triangular_lattice(10, 10)\n\npoints = generate_ginibre_points(100)\nmesh = TriMesh(vertices=points, faces=jnp.array(spatial.Delaunay(points).simplices))\n\nplt.triplot(*points.T, mesh.faces)\n\nplt.scatter(*points.T)\nplt.axis(\"equal\")\n\n(np.float64(-1.6629634499549866),\n np.float64(1.632395327091217),\n np.float64(-1.5740285992622376),\n np.float64(1.561158287525177))\n\n\n\n\n\n\n\n\n\n\n\n\n\nsource\n\n\n\n\ndef get_adjacent_vertex_indices(\n    faces:Int[Array, 'n_faces 3'], n_vertices:int\n)-&gt;list:\n\nFor each vertex, get the indices of the adjacent vertices in correct order. For boundary vertices, this list contains the vertex itself.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\nneighbors = get_adjacent_vertex_indices(mesh.faces, mesh.n_vertices)\n\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.float64'&gt; requested in array is not available, and will be truncated to dtype float32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.int64'&gt; requested in array is not available, and will be truncated to dtype int32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)",
    "crumbs": [
      "Loading, processing, and saving triangular meshes"
    ]
  },
  {
    "objectID": "01_triangular_meshes.html#loading-processing-and-saving-triangular-meshes",
    "href": "01_triangular_meshes.html#loading-processing-and-saving-triangular-meshes",
    "title": "triangulax",
    "section": "",
    "text": "triangulax is a library for working with triangular meshes using JAX. In this notebook, however, we define some tools for loading, processing, and saving triangular meshes outside of JAX. The dataclass TriMesh keeps the different pieces of a triangulation in one place. The use case of this module is to interface with JAX-external code, like the excellent igl geometry processing library, prepare initial conditions for simulations, etc. The data structure for JAX-based code is defined in the mesh module, notebook 03.\nThe simplest way to represent a triangulation is by a list of vertices and faces (triangles):\n\nA set of vertices, i.e., a \\((N_V, 2)\\) dimensional array datatype float.\nA set of faces, a \\((N_F, 3)\\) dimensional array of datatype int. Each row is an ordered triple of vertex indices that form a face.\n(Optional) A set of face centers, a \\((N_F, 2)\\) dimensional array of datatype float. An entry is the position of the dual vertex of a the triangulation face (think circumcenter).\n\nTo read and write, we use the .obj-file format. We will also make heavy use of the igl geometry processing library. The TriMesh class is a “holder” for loading, saving, visualizing, etc meshes, and not to be used for numerical computation. .\n\n\nOne use case of triangulax is simulations of 2D cell tilings. The simplest way to represent a cell tiling is by its dual triangular mesh (one triangulation vertex per cell). We will represent cell tilings by 2D Voronoi tessellations and variants thereof (like power diagrams). This means that we can represent the cell network as a 2D triangulation with vertices \\(V\\) and faces \\(F\\). We will first consider the case where the number of vertices does not change. Cells can, however, rearrange (T1-transitions/edge flips in the triangulation). Such flips also conserve the number of faces and edges.\n\nsource\n\n\n\n\ndef TriMesh(\n    vertices:Float[Array, 'n_vertices dim'], faces:Int[Array, 'n_faces 3'], face_positions:Union=None\n)-&gt;None:\n\nSimple class for reading, holding, transforming, and saving triangular meshes.\nA TriMesh comprises vertices and faces, describing a surface in 2d or 3d. In addition, there can be a 2d/3d position for every face (think Voronoi dual of the triangulation).\nVertices and faces are jnp.arrays. Each face is a triple of vertex indices. Vertices and faces are ordered - this is essential so that we know which attribute vector entry goes to which vector/edge/face. Faces in a face are assumed to be in counter-clockwise order.\nMeshes are read and written in the .obj format (https://en.wikipedia.org/wiki/Wavefront_.obj_file). To store face_positions, we abuse the vn (vertex normal) entry of an .obj file. Face positions will be written in order corresponding to faces. When reading from an .obj file, edges are recomputed from faces and initialized in alpha-numerical ordering. An .obj file expects 3d positions; the z-position is ignored when reading and set to 0 when writing for 2d meshes.\nAttributes\ndim : int = 2\nvertices : Float[jax.Array, “n_vertices dim”]\nfaces : Int[jax.Array, “n_faces 3”]\nface_positions : Float[jax.Array, “n_faces dim”]\nProperty methods (use like attributes)\nn_vertices : int\nhas_inf_vertex : bool\nStatic methods\nread_obj : str -&gt; TriMesh\nMethods\nwrite_obj : str -&gt; None\n\n# test reading a mesh\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.float64'&gt; requested in array is not available, and will be truncated to dtype float32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.int64'&gt; requested in array is not available, and will be truncated to dtype int32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)\n\n\n\n# test computing the circumcenter of each face. should be equidistant to all vertex points\n\ndists = jnp.stack([jnp.linalg.norm(mesh.vertices[mesh.faces[:,i]]-mesh.face_positions, axis=1) for i in [0,1,2]], axis=1)\n\njnp.allclose(dists[:,0], dists[:,1]) and jnp.allclose(dists[:,1], dists[:,2])\n\nArray(True, dtype=bool)\n\n\n\n# test writing face positions to vn entries\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nfilename = \"test_meshes/disk_write_test.obj\"\nmesh.write_obj(filename, save_face_positions=True)\nmesh = TriMesh.read_obj(filename, read_face_positions=True)\n\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.float64'&gt; requested in array is not available, and will be truncated to dtype float32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.int64'&gt; requested in array is not available, and will be truncated to dtype int32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)\n\n\n\n\n\nSome functions to create meshes based on the Delaunay triangulation of a point set.\n\nPoisson (vertices placed uniformly at random) in disk or box\nGinibre (vertices placed at uniform with self-repulsion)\nTriangular lattice\n\nSome functions for plotting meshes:\n\nPlot triangulation with vertex and face labels (for debugging)\nPlot cell tesselation\n\n\nsource\n\n\n\n\ndef generate_triangular_lattice(\n    nx:int, ny:int\n)-&gt;Float[Array, 'nx*ny 2']:\n\nGet points for rectangular patch of triangular lattice with nx, ny points.\n\nsource\n\n\n\n\ndef generate_poisson_points(\n    n_vertices:int, limit_x:float=1, limit_y:float=1\n)-&gt;Float[Array, 'n_vertices 2']:\n\nSample n_vertices points from the Poisson ensemble in rectangle [-limit_x/2, limit_x/2] * [-limit_y/2, limit_y/2].\n\nsource\n\n\n\n\ndef generate_ginibre_points(\n    n_vertices:int\n)-&gt;Float[Array, 'n_vertices 2']:\n\nSample n_vertices points from the Ginibre ensemble. Points are scaled to unit disk.\n\n#points = generate_triangular_lattice(10, 10)\n\npoints = generate_ginibre_points(100)\nmesh = TriMesh(vertices=points, faces=jnp.array(spatial.Delaunay(points).simplices))\n\nplt.triplot(*points.T, mesh.faces)\n\nplt.scatter(*points.T)\nplt.axis(\"equal\")\n\n(np.float64(-1.6629634499549866),\n np.float64(1.632395327091217),\n np.float64(-1.5740285992622376),\n np.float64(1.561158287525177))\n\n\n\n\n\n\n\n\n\n\n\n\n\nsource\n\n\n\n\ndef get_adjacent_vertex_indices(\n    faces:Int[Array, 'n_faces 3'], n_vertices:int\n)-&gt;list:\n\nFor each vertex, get the indices of the adjacent vertices in correct order. For boundary vertices, this list contains the vertex itself.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\nneighbors = get_adjacent_vertex_indices(mesh.faces, mesh.n_vertices)\n\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.float64'&gt; requested in array is not available, and will be truncated to dtype float32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n/var/folders/vm/1jl6rjln6n9cjt54vsr9n4800000gr/T/ipykernel_46976/2048334256.py:80: UserWarning: Explicitly requested dtype &lt;class 'jax.numpy.int64'&gt; requested in array is not available, and will be truncated to dtype int32. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/jax-ml/jax#current-gotchas for more.\n  mesh = TriMesh(jnp.array(vertices[:,:dim], dtype=jnp.float64), jnp.array(faces, dtype=jnp.int64), face_positions=None)",
    "crumbs": [
      "Loading, processing, and saving triangular meshes"
    ]
  },
  {
    "objectID": "02_coding_in_JAX_notes.html",
    "href": "02_coding_in_JAX_notes.html",
    "title": "Coding in JAX",
    "section": "",
    "text": "triangulax aims to create a triangulation datastructure compatible with the JAX library for automatic differentiation and numerical computing (see JAX- the sharp bits). What does this mean in practice?\nTo provide type signatures for all functions (what are the inputs? what do the array dimensions mean?), we use jaxtyping. Lateron, we will alsop use the equinox library, which adds a few useful tools to JAX.",
    "crumbs": [
      "Coding in JAX"
    ]
  },
  {
    "objectID": "02_coding_in_JAX_notes.html#simulation-loops-with-jax.lax.scan",
    "href": "02_coding_in_JAX_notes.html#simulation-loops-with-jax.lax.scan",
    "title": "Coding in JAX",
    "section": "Simulation loops with jax.lax.scan",
    "text": "Simulation loops with jax.lax.scan\nIn simulations, we generally start with an initial state (call it init), do a series of timesteps (via a function make_step(state)), and record some “measurement” at each timestep (via a measure(state) function). As a result, we get a timeseries of measurements, and the final simulation state. In normal python, you would do that with a for loop. When working with JAX, we need to replace control-flow operations like for with their JAX pendant. For for loops, this is jax.lax.scan(f, init, xs), which is equivalent to the python code\ndef scan(f, init, xs):\n  carry = init\n  ys = []\n  for x in xs:\n    carry, y = f(carry, x)\n    ys.append(y)\n  return carry, np.stack(ys)\nIn our pattern, xs is the vector of time-points timepoints, and the “scanning-function” f is generally comprised of two parts, a time-step and a measurement/logging step (above, we logged energy and T1 count):\ndef f(carry, t):\n    new_state = make_step(carry, t)\n    measurements = measure(new_state)\n    return new_state, measurements\nThe carry variable contains all information about the state of the simulation. Typically, carry is also composed of multiple pieces (the, the physical state physical_state, as well as ancilliary variables like the ODE solver state solver_state). To keep things organized, it can make sense to define dataclasses for the simulation state and the measurements, like this (schematic) example:\n@jax.tree_util.register_dataclass\n@dataclass\nclass SimState:\n    physical_state: jax.Array\n    solver_state: dict  # or another PyTree\n    current_time: jax.Array\n\n@jax.tree_util.register_dataclass\n@dataclass\nclass Log:\n    energy: float\n\ndef scan_function(carry: SimState, next_time: jax.Array) -&gt; tuple[SimState, Log]:\n    physical_state, solver_state = make_step(carry.physical_state, carry.solver_state,\n                                             carry.current_time, next_time)\n    log = Log(energy=compute_energy(physical_state))\n    return SimState(physical_state, solver_state), log\n\ntimepoints = jnp.arange(t0, t1, dt)\ninit = ... # define initial condition\nfinal_state, measurements = jax.lax.scan(scan_function, init, timepoints)",
    "crumbs": [
      "Coding in JAX"
    ]
  },
  {
    "objectID": "03_halfedge_datastructure.html",
    "href": "03_halfedge_datastructure.html",
    "title": "triangulax",
    "section": "",
    "text": "In the TriMesh class, we represent a mesh a list of triangles. However, many common operations are difficult with this data structure. For example, how do you get all the neighbors of a given vertex, or compute the area of a dual cell?\nFor simulation and geometry processing, we need a different representation of the adjacency information. Typically, this is achieved by a half-edge mesh (HE) data structure. We represent the HE data structure by 3 sets of integer index arrays:\n\nVertices: 1 \\((N_V,)\\) matrix, whose entry for vertex \\(i\\) is an arbitrary HE incident on \\(i\\)\nEdges: 6 \\((2N_E,)\\) matrices, [origin, dest, nxt, prv, twin, face] for each half-edge. face can be np.nan for boundary vertices.\nFaces, 1 \\((N_F, 1)\\) matrix, whose entry for face \\(i\\) is an arbitrary HE in \\(i\\). (Not to be confused with the \\((N_F, 3)\\) matrix of vertex IDs used previously).\n\nAdditionally, there are two float arrays for vertex and face positions, as previously. However, we split combinatorial and geometric information - a HeMesh class for the combinatorics, and a couple of regular arrays for the vertex positions, face positions, and vertex/half-edge/face attributes. The latter are packaged into a GeomMesh class. Together, the pair (GeomMesh, HeMesh) describes a mesh (like vertices/faces pair). A named tuple Mesh comines the two.\nThe first task is to create a helper function to plot mesh connectivity, and to create the half-edge connectivity matrices from the more conventional list-of-triangles format. The latter is somewhat involved.\nWe follow the notes in notebook 02 to ensure JAX compatibility.\n\nsource\n\n\n\ndef label_plot(\n    vertices:Float[Array, 'n_vertices 2'], faces:Int[Array, 'n_faces 3'], hemesh:Union=None, vertex_labels:bool=True,\n    face_labels:bool=True, ax:Union=None, fontsize:Union=None\n)-&gt;None:\n\nFor debugging purposes. Plot triangular mesh with face/vertex labels in black/blue. If hemesh is not None, the connectivity info from it is used to plot the half-edge labels.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\nplt.triplot(*mesh.vertices.T, mesh.faces)\nlabel_plot(mesh.vertices, mesh.faces, fontsize=10)\nplt.axis(\"equal\")\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n(np.float64(-1.10003475),\n np.float64(1.09628575),\n np.float64(-1.09934025),\n np.float64(1.09050125))\n\n\n\n\n\n\n\n\n\n\nsource\n\n\n\n\ndef get_half_edge_arrays(\n    n_vertices:int, faces:Int[Array, 'n_faces 3']\n)-&gt;list:\n\nGet half-edge data structure arrays from faces.\nReturns: incident, orig, dest, twin, nxt, prv, heface, face_incident\n\nsource\n\n\n\n\ndef HeMesh(\n    incident:Int[Array, '*batch n_vertices'], orig:Int[Array, '*batch n_hes'], dest:Int[Array, '*batch n_hes'],\n    twin:Int[Array, '*batch n_hes'], nxt:Int[Array, '*batch n_hes'], prv:Int[Array, '*batch n_hes'],\n    heface:Int[Array, '*batch n_hes'], face_incident:Int[Array, '*batch n_faces'], inf_vertices:Union=()\n)-&gt;None:\n\nHalf-edge mesh data structure for triangular meshes.\nA half-edge mesh is described by a set of half-edges and several arrays that specify their connectivity (see markup explanation above). This class serves as a container for multiple arrays. For future compatibility with JAX, after initialization, do not modify these arrays in-place; always return a new HeMesh object. The mesh vertices may live in whatever dimension - this does not affect the connectivity bookkeeping.\nHalf-edge meshes are initialized from a list of triangles and a number of vertices, and can return the original triangles (e.g., to save as a .obj).\nAll information and methods are purely “combinatorial”. The HeMesh class does not contain the vertex or face positions. These are saved in the GeomHeMesh class that combines a HeMesh (combinatorics) with a couple of other arrays (geometry).\n—Conventions—\nFor vertices, the incident half-edge points away from the vertex.\nTo describe the mesh boundary, there are two options: 1. Initialize from a triangulation with a boundary. Half-edges without a face (boundary) are assigned heface=-1. 2. Initialize from a triangulation without boundary, where certain vertices are “at infinity”. They should have coordinates [np.inf, np.inf]. Each infinity vertex corresponds to one boundary. For a single boundary, the vertex at infinity is, by convention, the final one.\nStarting from a set of triangles, the half-edges are initialized as follows: The 1st N_edges half-edges are (origin_vertex, destination_vertex), in lexicographic order, with origin_vertex &lt; destination_vertex. The 2nd N_edges are their twins, in the same order.\nAttributes\nincident : Int[jax.Array, “n_vertices”]\norig : Int[jax.Array, “n_hes”]\ndest : Int[jax.Array, “n_hes”]\nnxt : Int[jax.Array, “n_hes”]\nprv : Int[jax.Array, “n_hes”]\ntwin : Int[jax.Array, “n_hes”]\nheface : Int[jax.Array, “n_hes”]\nface_incident : Int[jax.Array, “n_faces”]\ninf_vertices : tuple[Int]\nProperty methods (use like attributes)\nn_vertices : int\nn_hes : int\nn_faces : int\nn_items : tuple[int, int, int]\nfaces : Int[jax.Array, “n_faces 3”]\nhas_inf_vertex : bool\nis_inf_face : Bool[jax.Array, “n_faces”]\nis_unique : Bool[jax.Array, “n_hes”]\nis_inf_he : Bool[jax.Array, “n_hes”]\nis_bdry_he : Bool[jax.Array, “n_hes”]\nis_bdry_edge : Bool[jax.Array, “n_hes”]\nis_bdry : Bool[jax.Array, “n_vertices”]\nStatic methods\nfrom_triangles : tuple[int, Int[jax.Array, “n_faces 3”], Int[jax.Array, “n_boundaries”] -&gt; HeMesh\nClass methods\niterate_around_vertex : int -&gt; Int[jax.Array, “n_neighbors”]\nsave : str -&gt; None:\nStatic methods\nload : str -&gt; HeMesh\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\n# hemeshes can be compared for equali and are registered as py-trees\n\nleafs, ts = jax.tree_util.tree_flatten(hemesh)\n\nhemesh, hemesh == hemesh\n\n(HeMesh(N_V=131, N_HE=708, N_F=224), True)\n\n\n\n# test iteration around vertex\nhemesh.dest[hemesh.iterate_around_vertex(69)], hemesh.orig[hemesh.iterate_around_vertex(56)]\n\n(Array([80, 68, 56, 46], dtype=int64),\n Array([56, 56, 56, 56, 56, 56, 56], dtype=int64))\n\n\n\n# boundary in cc-wise order\n(hemesh.orig[187], hemesh.dest[187]), hemesh.heface[187], hemesh.is_bdry_he[187],\n\n((Array(58, dtype=int64), Array(70, dtype=int64)),\n Array(-1, dtype=int64),\n Array(True, dtype=bool))\n\n\n\nhemesh.is_bdry_he[187], hemesh.is_bdry_he[541], hemesh.heface[541]\n\n(Array(True, dtype=bool), Array(False, dtype=bool), Array(145, dtype=int64))\n\n\n\n# to model mesh boundaries, we can add an \"infinity\" vertex. Not done here, see below\nhemesh.has_inf_vertex, hemesh.inf_vertices\n\n(False, ())\n\n\n\nfig = plt.figure(figsize=(14,14))\n\nplt.triplot(*mesh.vertices.T, hemesh.faces)\nlabel_plot(mesh.vertices, hemesh.faces, fontsize=10, hemesh=hemesh, face_labels=False)\nplt.axis(\"equal\")\n\n(np.float64(-1.10003475),\n np.float64(1.09628575),\n np.float64(-1.09934025),\n np.float64(1.09050125))\n\n\n\n\n\n\n\n\n\n\n# here is how you would do mesh traversal with jax.lax. The issues is that the output size needs to be fixed\n# ahead of time, so \n\nself = hemesh\nmax_valence = 10\nv = 10\n\ninitial = jnp.hstack([jnp.array([self.incident[v]]), -1*jnp.ones(max_valence-1, dtype=int)])\njax.lax.fori_loop(1, max_valence, lambda i, x: x.at[i].set(self.twin[x[i-1]]), initial)\n\nArray([ 47, 401,  47, 401,  47, 401,  47, 401,  47, 401], dtype=int64)\n\n\n\n\n\nSo far, our mesh representations TriMesh and HeMesh work for triangular meshes with and without boundary. In the HeMesh class, boundary half-edges are assigned to a fictitious -1 face. This convention has a downside. It is not possible to modify the boundary loop of the mesh by edge flips - doing so would result in an invalid state. In a simulation, this artificially limits the mesh’s ability to deform. Instead, we can add “vertices at infinity” and connect al edges in a given boundary to \\(\\infty\\). This turns the mesh into a topological sphere. Now, one can flip boundary edges without the overall number of half-edges changing (so the array shape stays the same). Multiple boundaries are also supported. Each boundary corresponds to a distinct \\(\\infty\\)-vertex (for example, 2 for a cylinder).\nThe coordinates of the fictitious vertices are set to [np.inf, np.inf] by convention. The boundary is found by iterating around \\(\\infty\\). By convention, \\(\\infty\\)-vertices, if they exists, are the final vertices of the mesh (don’t rely on this - implementation detail).\nWe generally assume that the mesh has only a single connected component.\nThe HeMesh class can deal with both the -1-face and the \\(\\infty\\)-vertices conventions. The latter are listed in the inf_vertices attribute of a HeMesh.\n\nsource\n\n\n\n\ndef connect_boundary_to_infinity(\n    vertices:Float[Array, 'n_vertices 2'], # Vertex positions.\n    faces:Int[Array, 'n_faces 3'], # Faces (triangles) as list of vertex indices.\n)-&gt;tuple: # Vertex positions with infinity vertices appended.\nOne infinity vertex per boundary loop.\n\nConnect boundary loop(s) to infinity.\nNew vertices are appeneded to the end of vertex array and have coordinates [np.inf, np.inf].\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\nnew_vertices, new_faces, infinity_vertices = connect_boundary_to_infinity(mesh.vertices, mesh.faces)\nmesh_infty = TriMesh(vertices=new_vertices, faces=new_faces)\nhemesh_infty = HeMesh.from_triangles(mesh_infty.vertices.shape[0], mesh_infty.faces,\n                                     inf_vertices=infinity_vertices)\n\n\nigl.is_edge_manifold(mesh_infty.faces)[0], igl.is_vertex_manifold(mesh_infty.faces)[0]\n\n(True, np.True_)\n\n\n\nhemesh_infty.dest[hemesh_infty.iterate_around_vertex(-1)], igl.boundary_loop(mesh.faces)\n\n(Array([  0,  10,  21,  34,  47,  58,  70,  86,  91, 100, 108, 113, 114,\n        110, 111, 112, 107,  99,  85,  80,  69,  46,  33,  32,  20,   9,\n        130, 121, 120, 119, 118, 117, 116, 115, 123, 122], dtype=int64),\n array([  0, 122, 123, 115, 116, 117, 118, 119, 120, 121, 130,   9,  20,\n         32,  33,  46,  69,  80,  85,  99, 107, 112, 111, 110, 114, 113,\n        108, 100,  91,  86,  70,  58,  47,  34,  21,  10], dtype=int64))\n\n\n\nhemesh_infty.dest[hemesh_infty.iterate_around_vertex(0)], hemesh.dest[hemesh.iterate_around_vertex(0)]\n\n(Array([  1,  11,  10, 131, 122], dtype=int64),\n Array([  1,  11,  10, 122], dtype=int64))\n\n\n\n(hemesh.is_bdry == (hemesh_infty.is_bdry[:-1] &gt;0)).all()\n\nArray(True, dtype=bool)\n\n\n\n# to get back the original faces/vertices, do this:\n\n_ = hemesh_infty.faces[~hemesh_infty.is_inf_face]",
    "crumbs": [
      "Half-edge meshes"
    ]
  },
  {
    "objectID": "03_halfedge_datastructure.html#half-edge-meshes",
    "href": "03_halfedge_datastructure.html#half-edge-meshes",
    "title": "triangulax",
    "section": "",
    "text": "In the TriMesh class, we represent a mesh a list of triangles. However, many common operations are difficult with this data structure. For example, how do you get all the neighbors of a given vertex, or compute the area of a dual cell?\nFor simulation and geometry processing, we need a different representation of the adjacency information. Typically, this is achieved by a half-edge mesh (HE) data structure. We represent the HE data structure by 3 sets of integer index arrays:\n\nVertices: 1 \\((N_V,)\\) matrix, whose entry for vertex \\(i\\) is an arbitrary HE incident on \\(i\\)\nEdges: 6 \\((2N_E,)\\) matrices, [origin, dest, nxt, prv, twin, face] for each half-edge. face can be np.nan for boundary vertices.\nFaces, 1 \\((N_F, 1)\\) matrix, whose entry for face \\(i\\) is an arbitrary HE in \\(i\\). (Not to be confused with the \\((N_F, 3)\\) matrix of vertex IDs used previously).\n\nAdditionally, there are two float arrays for vertex and face positions, as previously. However, we split combinatorial and geometric information - a HeMesh class for the combinatorics, and a couple of regular arrays for the vertex positions, face positions, and vertex/half-edge/face attributes. The latter are packaged into a GeomMesh class. Together, the pair (GeomMesh, HeMesh) describes a mesh (like vertices/faces pair). A named tuple Mesh comines the two.\nThe first task is to create a helper function to plot mesh connectivity, and to create the half-edge connectivity matrices from the more conventional list-of-triangles format. The latter is somewhat involved.\nWe follow the notes in notebook 02 to ensure JAX compatibility.\n\nsource\n\n\n\ndef label_plot(\n    vertices:Float[Array, 'n_vertices 2'], faces:Int[Array, 'n_faces 3'], hemesh:Union=None, vertex_labels:bool=True,\n    face_labels:bool=True, ax:Union=None, fontsize:Union=None\n)-&gt;None:\n\nFor debugging purposes. Plot triangular mesh with face/vertex labels in black/blue. If hemesh is not None, the connectivity info from it is used to plot the half-edge labels.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\nplt.triplot(*mesh.vertices.T, mesh.faces)\nlabel_plot(mesh.vertices, mesh.faces, fontsize=10)\nplt.axis(\"equal\")\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n(np.float64(-1.10003475),\n np.float64(1.09628575),\n np.float64(-1.09934025),\n np.float64(1.09050125))\n\n\n\n\n\n\n\n\n\n\nsource\n\n\n\n\ndef get_half_edge_arrays(\n    n_vertices:int, faces:Int[Array, 'n_faces 3']\n)-&gt;list:\n\nGet half-edge data structure arrays from faces.\nReturns: incident, orig, dest, twin, nxt, prv, heface, face_incident\n\nsource\n\n\n\n\ndef HeMesh(\n    incident:Int[Array, '*batch n_vertices'], orig:Int[Array, '*batch n_hes'], dest:Int[Array, '*batch n_hes'],\n    twin:Int[Array, '*batch n_hes'], nxt:Int[Array, '*batch n_hes'], prv:Int[Array, '*batch n_hes'],\n    heface:Int[Array, '*batch n_hes'], face_incident:Int[Array, '*batch n_faces'], inf_vertices:Union=()\n)-&gt;None:\n\nHalf-edge mesh data structure for triangular meshes.\nA half-edge mesh is described by a set of half-edges and several arrays that specify their connectivity (see markup explanation above). This class serves as a container for multiple arrays. For future compatibility with JAX, after initialization, do not modify these arrays in-place; always return a new HeMesh object. The mesh vertices may live in whatever dimension - this does not affect the connectivity bookkeeping.\nHalf-edge meshes are initialized from a list of triangles and a number of vertices, and can return the original triangles (e.g., to save as a .obj).\nAll information and methods are purely “combinatorial”. The HeMesh class does not contain the vertex or face positions. These are saved in the GeomHeMesh class that combines a HeMesh (combinatorics) with a couple of other arrays (geometry).\n—Conventions—\nFor vertices, the incident half-edge points away from the vertex.\nTo describe the mesh boundary, there are two options: 1. Initialize from a triangulation with a boundary. Half-edges without a face (boundary) are assigned heface=-1. 2. Initialize from a triangulation without boundary, where certain vertices are “at infinity”. They should have coordinates [np.inf, np.inf]. Each infinity vertex corresponds to one boundary. For a single boundary, the vertex at infinity is, by convention, the final one.\nStarting from a set of triangles, the half-edges are initialized as follows: The 1st N_edges half-edges are (origin_vertex, destination_vertex), in lexicographic order, with origin_vertex &lt; destination_vertex. The 2nd N_edges are their twins, in the same order.\nAttributes\nincident : Int[jax.Array, “n_vertices”]\norig : Int[jax.Array, “n_hes”]\ndest : Int[jax.Array, “n_hes”]\nnxt : Int[jax.Array, “n_hes”]\nprv : Int[jax.Array, “n_hes”]\ntwin : Int[jax.Array, “n_hes”]\nheface : Int[jax.Array, “n_hes”]\nface_incident : Int[jax.Array, “n_faces”]\ninf_vertices : tuple[Int]\nProperty methods (use like attributes)\nn_vertices : int\nn_hes : int\nn_faces : int\nn_items : tuple[int, int, int]\nfaces : Int[jax.Array, “n_faces 3”]\nhas_inf_vertex : bool\nis_inf_face : Bool[jax.Array, “n_faces”]\nis_unique : Bool[jax.Array, “n_hes”]\nis_inf_he : Bool[jax.Array, “n_hes”]\nis_bdry_he : Bool[jax.Array, “n_hes”]\nis_bdry_edge : Bool[jax.Array, “n_hes”]\nis_bdry : Bool[jax.Array, “n_vertices”]\nStatic methods\nfrom_triangles : tuple[int, Int[jax.Array, “n_faces 3”], Int[jax.Array, “n_boundaries”] -&gt; HeMesh\nClass methods\niterate_around_vertex : int -&gt; Int[jax.Array, “n_neighbors”]\nsave : str -&gt; None:\nStatic methods\nload : str -&gt; HeMesh\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\n# hemeshes can be compared for equali and are registered as py-trees\n\nleafs, ts = jax.tree_util.tree_flatten(hemesh)\n\nhemesh, hemesh == hemesh\n\n(HeMesh(N_V=131, N_HE=708, N_F=224), True)\n\n\n\n# test iteration around vertex\nhemesh.dest[hemesh.iterate_around_vertex(69)], hemesh.orig[hemesh.iterate_around_vertex(56)]\n\n(Array([80, 68, 56, 46], dtype=int64),\n Array([56, 56, 56, 56, 56, 56, 56], dtype=int64))\n\n\n\n# boundary in cc-wise order\n(hemesh.orig[187], hemesh.dest[187]), hemesh.heface[187], hemesh.is_bdry_he[187],\n\n((Array(58, dtype=int64), Array(70, dtype=int64)),\n Array(-1, dtype=int64),\n Array(True, dtype=bool))\n\n\n\nhemesh.is_bdry_he[187], hemesh.is_bdry_he[541], hemesh.heface[541]\n\n(Array(True, dtype=bool), Array(False, dtype=bool), Array(145, dtype=int64))\n\n\n\n# to model mesh boundaries, we can add an \"infinity\" vertex. Not done here, see below\nhemesh.has_inf_vertex, hemesh.inf_vertices\n\n(False, ())\n\n\n\nfig = plt.figure(figsize=(14,14))\n\nplt.triplot(*mesh.vertices.T, hemesh.faces)\nlabel_plot(mesh.vertices, hemesh.faces, fontsize=10, hemesh=hemesh, face_labels=False)\nplt.axis(\"equal\")\n\n(np.float64(-1.10003475),\n np.float64(1.09628575),\n np.float64(-1.09934025),\n np.float64(1.09050125))\n\n\n\n\n\n\n\n\n\n\n# here is how you would do mesh traversal with jax.lax. The issues is that the output size needs to be fixed\n# ahead of time, so \n\nself = hemesh\nmax_valence = 10\nv = 10\n\ninitial = jnp.hstack([jnp.array([self.incident[v]]), -1*jnp.ones(max_valence-1, dtype=int)])\njax.lax.fori_loop(1, max_valence, lambda i, x: x.at[i].set(self.twin[x[i-1]]), initial)\n\nArray([ 47, 401,  47, 401,  47, 401,  47, 401,  47, 401], dtype=int64)\n\n\n\n\n\nSo far, our mesh representations TriMesh and HeMesh work for triangular meshes with and without boundary. In the HeMesh class, boundary half-edges are assigned to a fictitious -1 face. This convention has a downside. It is not possible to modify the boundary loop of the mesh by edge flips - doing so would result in an invalid state. In a simulation, this artificially limits the mesh’s ability to deform. Instead, we can add “vertices at infinity” and connect al edges in a given boundary to \\(\\infty\\). This turns the mesh into a topological sphere. Now, one can flip boundary edges without the overall number of half-edges changing (so the array shape stays the same). Multiple boundaries are also supported. Each boundary corresponds to a distinct \\(\\infty\\)-vertex (for example, 2 for a cylinder).\nThe coordinates of the fictitious vertices are set to [np.inf, np.inf] by convention. The boundary is found by iterating around \\(\\infty\\). By convention, \\(\\infty\\)-vertices, if they exists, are the final vertices of the mesh (don’t rely on this - implementation detail).\nWe generally assume that the mesh has only a single connected component.\nThe HeMesh class can deal with both the -1-face and the \\(\\infty\\)-vertices conventions. The latter are listed in the inf_vertices attribute of a HeMesh.\n\nsource\n\n\n\n\ndef connect_boundary_to_infinity(\n    vertices:Float[Array, 'n_vertices 2'], # Vertex positions.\n    faces:Int[Array, 'n_faces 3'], # Faces (triangles) as list of vertex indices.\n)-&gt;tuple: # Vertex positions with infinity vertices appended.\nOne infinity vertex per boundary loop.\n\nConnect boundary loop(s) to infinity.\nNew vertices are appeneded to the end of vertex array and have coordinates [np.inf, np.inf].\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\nnew_vertices, new_faces, infinity_vertices = connect_boundary_to_infinity(mesh.vertices, mesh.faces)\nmesh_infty = TriMesh(vertices=new_vertices, faces=new_faces)\nhemesh_infty = HeMesh.from_triangles(mesh_infty.vertices.shape[0], mesh_infty.faces,\n                                     inf_vertices=infinity_vertices)\n\n\nigl.is_edge_manifold(mesh_infty.faces)[0], igl.is_vertex_manifold(mesh_infty.faces)[0]\n\n(True, np.True_)\n\n\n\nhemesh_infty.dest[hemesh_infty.iterate_around_vertex(-1)], igl.boundary_loop(mesh.faces)\n\n(Array([  0,  10,  21,  34,  47,  58,  70,  86,  91, 100, 108, 113, 114,\n        110, 111, 112, 107,  99,  85,  80,  69,  46,  33,  32,  20,   9,\n        130, 121, 120, 119, 118, 117, 116, 115, 123, 122], dtype=int64),\n array([  0, 122, 123, 115, 116, 117, 118, 119, 120, 121, 130,   9,  20,\n         32,  33,  46,  69,  80,  85,  99, 107, 112, 111, 110, 114, 113,\n        108, 100,  91,  86,  70,  58,  47,  34,  21,  10], dtype=int64))\n\n\n\nhemesh_infty.dest[hemesh_infty.iterate_around_vertex(0)], hemesh.dest[hemesh.iterate_around_vertex(0)]\n\n(Array([  1,  11,  10, 131, 122], dtype=int64),\n Array([  1,  11,  10, 122], dtype=int64))\n\n\n\n(hemesh.is_bdry == (hemesh_infty.is_bdry[:-1] &gt;0)).all()\n\nArray(True, dtype=bool)\n\n\n\n# to get back the original faces/vertices, do this:\n\n_ = hemesh_infty.faces[~hemesh_infty.is_inf_face]",
    "crumbs": [
      "Half-edge meshes"
    ]
  },
  {
    "objectID": "03_halfedge_datastructure.html#mesh-geometry-and-per-mesh-variables",
    "href": "03_halfedge_datastructure.html#mesh-geometry-and-per-mesh-variables",
    "title": "triangulax",
    "section": "Mesh geometry and per-mesh variables",
    "text": "Mesh geometry and per-mesh variables\nMesh geometry (vertex and face positions) and per-mesh-item (per-face, per-half-edge, per-vertex) variables are combined into a second data class, the GeomMesh.\n\nsource\n\nGeomMesh\n\ndef GeomMesh(\n    n_vertices:int, n_hes:int, n_faces:int, vertices:Float[Array, '*batch n_vertices dim'],\n    face_positions:Float[Array, '*batch n_faces 2']=&lt;factory&gt;, vertex_attribs:dict=&lt;factory&gt;,\n    he_attribs:dict=&lt;factory&gt;, face_attribs:dict=&lt;factory&gt;\n)-&gt;None:\n\nData class for holding mesh geometry and mesh-associated variables. To be combined with a HeMesh to specify the connectivity.\nOne array (for vertex positions) must always be present. A second, but optional, standard entry is a set of positions for each face. The mesh coordinates can live in 2d or 3d.\nOptionally, vertices, half-edges, and faces can have attributes (stored as dictionaries). The keys of the dictionary should be taken from a suitable ‘enum’. The values are ndarrays, whose 0th axis is (vertices/edges/faces). These attribute dicts are initialized empty and can be set afterwards.\nSee documentation on HeMesh\nAttributes\nvertices : Float[jax.Array, “n_vertices 2”]\nface_positions : Float[jax.Array, “n_faces 2”]\nvertex_attribs : dict[IntEnum, Float[jax.Array, “n_vertices *”]]\nhe_attribs : dict[IntEnum, Float[jax.Array, “n_hes *”]]\nface_attribs : dict[IntEnum, Float[jax.Array, “n_faces *”]]\nProperty methods (use like attributes)\nn_items : tuple[int, int, int]\ndim : int\nClass methods\nvalidate_dimensions : bool\nStatic methods\nload : str -&gt; GeomHeMesh\n\nsource\n\n\nset_voronoi_face_positions\n\ndef set_voronoi_face_positions(\n    geommesh:GeomMesh, hemesh:HeMesh\n)-&gt;GeomMesh:\n\nSet face positions of geommesh to the circumcenters of the faces defined by hemesh.\n\nsource\n\n\nget_voronoi_face_positions\n\ndef get_voronoi_face_positions(\n    vertices:Float[Array, 'n_vertices 2'], hemesh:HeMesh\n)-&gt;Float[Array, 'n_faces 2']:\n\nGet face positions of geommesh to the circumcenters of the faces defined by hemesh.\n\nsource\n\n\nMesh\n\ndef Mesh(\n    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD\n):\n\nCombine geometric and connectivity info into a single object.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)\ncombined_mesh = Mesh(geommesh, hemesh)\ncombined_mesh\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\nMesh(geommesh=GeomMesh(D=2,N_V=131, N_HE=708, N_F=224), hemesh=HeMesh(N_V=131, N_HE=708, N_F=224))\n\n\n\nleafs, ts = jax.tree_util.tree_flatten(geommesh) # also a pytree\nts\n\nPyTreeDef(CustomNode(GeomMesh[(131, 708, 224)], [*, *, {}, {}, {}]))\n\n\n\ngeommesh, geommesh.n_vertices, geommesh.vertices.shape, geommesh.check_compatibility(hemesh), geommesh == geommesh\n\n(GeomMesh(D=2,N_V=131, N_HE=708, N_F=224), 131, (131, 2), True, True)\n\n\n\nsource\n\n\ncellplot\n\ndef cellplot(\n    hemesh:HeMesh, face_positions:Float[Array, 'n_faces 2'], cell_colors:Union=None, mpl_polygon_kwargs:Union=None\n)-&gt;PatchCollection:\n\nPlot a cell tesselation.\ncell_colors can be either a single color (for all cells) or a vector of rgba values. Only interior cells are plotted.\n\nplt.triplot(*geommesh.vertices.T, hemesh.faces)\npolygons = cellplot(hemesh, geommesh.face_positions,\n                    cell_colors=np.array([0,0,1,0.5]), mpl_polygon_kwargs={\"lw\": 1, \"ec\": \"k\"})\nax = plt.gca()\nax.add_collection(polygons)\n\nplt.axis(\"equal\")\n\n(np.float64(-1.10003475),\n np.float64(1.09628575),\n np.float64(-1.09934025),\n np.float64(1.09050125))\n\n\n\n\n\n\n\n\n\n\n\nVertex, half-edge, and face properties\nIn simulations, we will often want to attach extra information to a mesh’s vertices/edges/faces. In the GeomMesh class, these are saved in three dictionaries, vertex_attribs, he_attribs, face_attribs. Each key/value pair represents one property (for example, the cell target area). All values are arrays, and the first axis corresponds to the number of vertices/half-edges/faces, respectively. To keep track of the possible attributes, we use IntEnum’s as keys (this also ensures keys are hashable, as required by JAX)\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommmesh = GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\n# this is how you set up an enum. It is important to use IntEnum, so we can _order_ the enums.\n# The precise Enum you will use depends on your application.\n\nclass VertexAttribs(IntEnum):\n    TARGET_AREA = 1\n    TARGET_PERIMETER = 2\n\nclass HeAttribs(IntEnum):\n    EDGE_TENSION = 1\n\nclass FaceAttribs(IntEnum):\n    FACE_AREA = 1\n\n\n# you can iterate over enums, and they are hashable. The latter is essential for JAX!\nprint([a for a in VertexAttribs])\n# there are multiple ways to access enum entries:\nhash(VertexAttribs.TARGET_PERIMETER), HeAttribs.EDGE_TENSION, HeAttribs['EDGE_TENSION'], HeAttribs.EDGE_TENSION.name\n\n[&lt;VertexAttribs.TARGET_AREA: 1&gt;, &lt;VertexAttribs.TARGET_PERIMETER: 2&gt;]\n\n\n(2, &lt;HeAttribs.EDGE_TENSION: 1&gt;, &lt;HeAttribs.EDGE_TENSION: 1&gt;, 'EDGE_TENSION')\n\n\n\n# at initialization, a HeMesh's attribute dictionaries are empty\ngeommmesh.vertex_attribs\n\n{}\n\n\n\n# set some attributes\n\nkey1 = jax.random.key(0)\n_, key2 = jax.random.split(key1)\n_, key3 = jax.random.split(key2)\n\ngeommmesh = dataclasses.replace(geommmesh, vertex_attribs={VertexAttribs.TARGET_AREA: jax.random.normal(key=key1, shape=geommmesh.n_vertices),\n                                                           VertexAttribs.TARGET_PERIMETER: jax.random.normal(key=key2, shape=geommmesh.n_vertices)})\ngeommmesh = dataclasses.replace(geommmesh, he_attribs={HeAttribs.EDGE_TENSION: jax.random.normal(key=key3, shape=geommmesh.n_hes)})\n\n\ngeommmesh.he_attribs.keys()\n\ndict_keys([&lt;HeAttribs.EDGE_TENSION: 1&gt;])",
    "crumbs": [
      "Half-edge meshes"
    ]
  },
  {
    "objectID": "03_halfedge_datastructure.html#batching",
    "href": "03_halfedge_datastructure.html#batching",
    "title": "triangulax",
    "section": "Batching",
    "text": "Batching\nIn our simulations, we may want to “batch” over several initial conditions/random seeds/etc (analogous to batching over training data in normal ML). In JAX, we can efficiently and concisely vectorize operations over such “batch axes” with jax.vmap.\nTo batch over our custom data structures, we need to pull a small trick - convert a list of HeMesh/GeomMeshe instances into a single mesh with a batch axis for the various arrays. Luckily, this can be done using JAX’s pytree tools. The resulting meshes have an extra “batch” axis in all their array.\n\nsource\n\ntree_unstack\n\ndef tree_unstack(\n    xb:PyTree, axis:int=0\n)-&gt;list:\n\nUnstack a batched pytree along axis into a list of pytrees.\n\nsource\n\n\ntree_stack\n\ndef tree_stack(\n    xs:list, axis:int=0\n)-&gt;PyTree:\n\nStack a sequence of identical-structure pytrees along a new axis.\n\n## Let us create a bunch of meshes with different initial positions and see if we can batch over them using vmap\n\nkey = jax.random.key(0)\nsigma = 0.02\n\nbatch_geom = []\nbatch_he = []\nfor i in range(3):\n    key, subkey = jax.random.split(key)\n    random_noise = jax.random.normal(subkey, shape=geommmesh.vertices.shape)\n    batch_geom.append(dataclasses.replace(geommmesh, vertices=geommmesh.vertices+sigma*random_noise))\n    batch_he.append(copy.copy(hemesh))\n\n\n# define a test function to appy over the batch\n\ndef test_function(geommesh: GeomMesh, hemesh: HeMesh) -&gt; Float[jax.Array, \" n_vertices\"]:\n    \"\"\"Dummy test function.\"\"\"\n    return jnp.ones(geommesh.n_vertices)\n\n\n# naive batching does not work. JAX needs a \"struct-of-arrays\", but a list of HeMeshes is an \"array-of-structs\"\n# see https://stackoverflow.com/questions/79123001/storing-and-jax-vmap-over-pytrees\n\ntry:\n    jax.vmap(test_function)(batch_geom, batch_he)\nexcept ValueError as e:\n    print(\"Expected error:\", e)\n\nExpected error: vmap got inconsistent sizes for array axes to be mapped:\n  * most axes (21 of them) had size 708, e.g. axis 0 of argument geommesh[0].he_attribs[&lt;HeAttribs.EDGE_TENSION: 1&gt;] of type float64[708];\n  * some axes (12 of them) had size 131, e.g. axis 0 of argument geommesh[0].vertices of type float64[131,2];\n  * some axes (6 of them) had size 224, e.g. axis 0 of argument geommesh[0].face_positions of type float64[224,2]\n\n\n\n# instead, we use a jax.tree.map to \"push\" the list axis into the underlying arrays.\n# the resulting meshes have an extra batch dimension in all of their arrays.\n\nbatch_he_array = tree_stack(batch_he)\nbatch_geom_array = tree_stack(batch_geom)\nbatch_he_array, batch_geom_array, batch_geom_array.vertices.shape\n\n(HeMesh(N_V=131, N_HE=708, N_F=224),\n GeomMesh(D=2,N_V=131, N_HE=708, N_F=224),\n (3, 131, 2))\n\n\n\n# now it works! The result is a single object with batch axis\n\nbatch_out =jax.vmap(test_function)(batch_geom_array, batch_he_array)\nbatch_out.shape\n\n(3, 131)\n\n\n\n# we can unpack things again into a list of meshes\n\nisinstance(tree_unstack(batch_out), list)\n\nTrue",
    "crumbs": [
      "Half-edge meshes"
    ]
  },
  {
    "objectID": "03_halfedge_datastructure.html#edge-flips-t1s",
    "href": "03_halfedge_datastructure.html#edge-flips-t1s",
    "title": "triangulax",
    "section": "Edge flips / T1s",
    "text": "Edge flips / T1s\nIn our simulations, cells will exchange neighbors (T1-event). In the triangulation, this corresponds to an edge flip. We now implement the edge flip algorithm for HeMeshes. We basically edit the various connectivity arrays (in a JAX-compatible way).\nThe algorithm (and the naming conventions in flip_edge) are from here.\nBefore\n\n\n\nimage.png\n\n\nAfter\n\n\n\nimage.png\n\n\n\nsource\n\nflip_edge\n\ndef flip_edge(\n    hemesh:HeMesh, e:Int[Array, ''], check_boundary:bool=False\n)-&gt;HeMesh:\n\nFlip half-edge e in a half-edge mesh.\nSee https://jerryyin.info/geometry-processing-algorithms/half-edge/. The algorithm is slightly modified since we keep track of the origin and destination of a half-edge, and use arrays instead of pointers. Returns a new HeMesh, does not modify in-place.\n\nsource\n\n\nget_signed_dual_he_length\n\ndef get_signed_dual_he_length(\n    vertices:Float[Array, 'n_vertices 2'], face_positions:Float[Array, 'n_faces 2'], hemesh:HeMesh\n)-&gt;Float[Array, 'n_hes']:\n\nCompute lengths of dual edges. Boundary dual edges get length 1. Negative sign = flipped edge.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\nplt.triplot(*geommesh.vertices.T, hemesh.faces)\nax = plt.gca()\np = cellplot(hemesh, geommesh.face_positions,\n             cell_colors=np.array([0,0,0,0.1]), mpl_polygon_kwargs={\"lw\": 1, \"ec\": \"k\"})\nplt.gca().add_collection(p)\n\nplt.axis(\"equal\")\n\n(np.float64(-1.10003475),\n np.float64(1.09628575),\n np.float64(-1.09934025),\n np.float64(1.09050125))\n\n\n\n\n\n\n\n\n\n\n# edges and dual edges should be orthogonal since we are using circumcenters\n\nedges = geommesh.vertices[hemesh.orig]-geommesh.vertices[hemesh.dest]\ndual_edges = (geommesh.face_positions[hemesh.heface]\n              -geommesh.face_positions[hemesh.heface[hemesh.twin]])\n\njnp.allclose(jnp.einsum('vi,vi-&gt;v', edges[~hemesh.is_bdry_edge], dual_edges[~hemesh.is_bdry_edge]), 0)\n\nArray(True, dtype=bool)\n\n\n\n# computing the signed edge length shows that there are some \"flipped\" edges.\n\nsigned_squared_length = jnp.einsum('vi,vi-&gt;v', edges, dual_edges @ trig.get_rot_mat(np.pi/2))\njnp.where((signed_squared_length &lt; -0.0) & ~hemesh.is_bdry_edge )[0]\n\nArray([  9, 185, 191, 335, 363, 539, 545, 689], dtype=int64)\n\n\n\nset_voronoi_face_positions\n\n&lt;function __main__.set_voronoi_face_positions(geommesh: __main__.GeomMesh, hemesh: __main__.HeMesh) -&gt; __main__.GeomMesh&gt;\n\n\n\n# flip edge and recompute face positions\n\nflipped_hemesh = flip_edge(hemesh, e=335)\nflipped_geommesh = set_voronoi_face_positions(geommesh, flipped_hemesh)\n\n\n# connectivity is still valid\n\nigl.is_edge_manifold(hemesh.faces)[0], igl.is_edge_manifold(flipped_hemesh.faces)[0], flipped_hemesh.iterate_around_vertex(100)\n\n(True, True, Array([298, 299, 630, 632], dtype=int64))\n\n\n\n# you can see the flipped edge between vertices 126-117 in the plot below (middle right)\n\nfig = plt.figure(figsize=(8,8))\n\nplt.triplot(*geommesh.vertices.T, hemesh.faces)\nplt.triplot(*flipped_geommesh.vertices.T, flipped_hemesh.faces)\n\nax = plt.gca()\np1 = cellplot(hemesh, geommesh.face_positions,\n         cell_colors=np.array([0.,0.,0.,0.]), mpl_polygon_kwargs={\"lw\": 1, \"ec\": \"k\"})\np2 = cellplot(flipped_hemesh, flipped_geommesh.face_positions,\n              cell_colors=np.array([0.,0.,0.,0.]), mpl_polygon_kwargs={\"lw\": 1, \"ec\": \"tab:orange\"})\nax.add_collection(p1)\nax.add_collection(p2)\nplt.axis(\"equal\")\n\nlabel_plot(geommesh.vertices, hemesh.faces, fontsize=10, face_labels=False)\n\n\n\n\n\n\n\n\n\nRepeated flips\nIn a simulation, we need to carry out edge flips at every timestep. The function flip_edge(hemesh: HeMesh, e: int) -&gt; HeMesh does a single edge flip by modifying the connectivity arrays. Luckily, it is already JAX-compatible (we can JIT-compile it).\nTo carry out multiple flips, we must do the flips in sequence (otherwise, you risk leaving the mesh in an invalid state). To make things JAX-compatible, we do a jax.lax.scan scan over all half-edges.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\ndual_lengths = get_signed_dual_he_length(geommesh.vertices, geommesh.face_positions, hemesh)\nedges = jnp.where((dual_lengths &lt; -0.05) & ~hemesh.is_bdry_edge & hemesh.is_unique)[0]\n# we only want to flip unique hes!\nedges, edges.size\n\n(Array([  9, 185, 191, 335], dtype=int64), 4)\n\n\n\nsource\n\n\n\nflip_all\n\ndef flip_all(\n    hemesh:HeMesh, to_flip:Bool[Array, 'n_hes']\n)-&gt;HeMesh:\n\nFlip all (unique) half-edges where to_flip is True in a half-edge mesh. Wraps flip_edge.\n\nto_flip = (dual_lengths &lt; 0) & ~jnp.isnan(dual_lengths)\n\nflipped_hemesh = flip_all(hemesh, to_flip=to_flip)\n\n\nflipped_hemesh = flip_all(hemesh, to_flip=(dual_lengths&lt;0.02)) # no extra recompile\n\n\nflipped_geommesh = set_voronoi_face_positions(geommesh, flipped_hemesh)\n\n\nfig = plt.figure(figsize=(8,8))\n\nplt.triplot(*geommesh.vertices.T, hemesh.faces)\nplt.triplot(*flipped_geommesh.vertices.T, flipped_hemesh.faces)\n\nax = plt.gca()\nax = plt.gca()\np1 = cellplot(hemesh, geommesh.face_positions,\n         cell_colors=np.array([0.,0.,0.,0.]), mpl_polygon_kwargs={\"lw\": 1, \"ec\": \"k\"})\np2 = cellplot(flipped_hemesh, flipped_geommesh.face_positions,\n              cell_colors=np.array([0.,0.,0.,0.]), mpl_polygon_kwargs={\"lw\": 1, \"ec\": \"tab:orange\"})\nax.add_collection(p1)\nax.add_collection(p2)\nplt.axis(\"equal\")\n\nlabel_plot(geommesh.vertices, hemesh.faces, fontsize=10, face_labels=False)",
    "crumbs": [
      "Half-edge meshes"
    ]
  },
  {
    "objectID": "03_halfedge_datastructure.html#saving-to-disk",
    "href": "03_halfedge_datastructure.html#saving-to-disk",
    "title": "triangulax",
    "section": "Saving to disk",
    "text": "Saving to disk\nWe save and load TriMesh meshes as standard .obj files (with the hack of using vn lines for the face positions). The HeMesh class is basically a collection of arrays, which we can save to disk using numpy.\n\nfrom tempfile import TemporaryFile\n\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\noutfile = TemporaryFile()\n\nhemesh.save(outfile)\n_ = outfile.seek(0) # simulates closing & reopening file\nnpzfile = np.load(outfile)\nnpzfile.files\n\n['incident',\n 'orig',\n 'dest',\n 'twin',\n 'nxt',\n 'prv',\n 'heface',\n 'face_incident',\n 'inf_vertices']\n\n\n\noutfile = TemporaryFile()\n\nhemesh.save(outfile)\n_ = outfile.seek(0) # simulates closing & reopening file\nreloaded = HeMesh.load(outfile)\n\nnp.allclose(reloaded.faces, hemesh.faces)\n\nTrue\n\n\n\nNext steps\nLooks good - the JAX-compatible triangular-mesh data structures seem to work. In particular, the tricky T1/edge-flip function. Next steps: toy simulation, notebook 01.",
    "crumbs": [
      "Half-edge meshes"
    ]
  },
  {
    "objectID": "04_linear_operators_on_meshes.html",
    "href": "04_linear_operators_on_meshes.html",
    "title": "triangulax",
    "section": "",
    "text": "# load test data\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = msh.HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = msh.GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)\n\nmesh_3d = TriMesh.read_obj(\"test_meshes/disk.obj\", dim=3)\ngeommesh_3d = msh.GeomMesh(*hemesh.n_items, mesh_3d.vertices, mesh_3d.face_positions)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc",
    "crumbs": [
      "Adjacency-like operators on half-edge meshes"
    ]
  },
  {
    "objectID": "04_linear_operators_on_meshes.html#adjacency-like-operators-on-half-edge-meshes",
    "href": "04_linear_operators_on_meshes.html#adjacency-like-operators-on-half-edge-meshes",
    "title": "triangulax",
    "section": "Adjacency-like operators on half-edge meshes",
    "text": "Adjacency-like operators on half-edge meshes\nUsing the HeMesh data structure, we can efficiently “traverse” our mesh. Using such traversals, one can express many of the key linear operators defined by the mesh adjacency structure, for example - Sum over all half-edges “incoming” to a vertex (special case: count the incoming edges, i.e., compute the coordination number) - Compute the finite-element gradient of a function defined on vertices\nThese operations can be done efficiently using a “gather/scatter” approach, see jax.numpy.ndarray.at. There is no need to explicitly instantiate a matrix for the operators.\n\nsource\n\naverage_faces_to_vertices\n\ndef average_faces_to_vertices(\n    hemesh:HeMesh, vertices:Float[Array, 'n_vertices dim'], face_field:Float[Array, 'n_faces ...']\n)-&gt;Float[Array, 'n_vertices ...']:\n\nAverage per-face field onto vertices, weighted by triangle area.\n\nsource\n\n\naverage_vertices_to_faces\n\ndef average_vertices_to_faces(\n    hemesh:HeMesh, vertex_field:Float[Array, 'n_vertices ...']\n)-&gt;Float[Array, 'n_faces ...']:\n\nAverage per-vertex field onto faces (uniform weights).\n\n# tests vs libigl\nkey = jax.random.PRNGKey(123)\n\nu_v = jax.random.normal(key, (hemesh.n_vertices,))\nfaces_avg_jax = average_vertices_to_faces(hemesh, u_v)\nfaces_avg_igl = igl.average_onto_faces(np.asarray(hemesh.faces), np.asarray(u_v))\n\nrel_err_faces = np.linalg.norm(np.asarray(faces_avg_jax) - faces_avg_igl) / np.linalg.norm(faces_avg_igl)\nprint(\"vertex-&gt;face rel. error:\", rel_err_faces)\n\nu_f = jax.random.normal(key, (hemesh.n_faces,))\nverts_avg_jax = average_faces_to_vertices(hemesh, geommesh.vertices, u_f)\n\n# libigl reference using area-weighted averaging\nV = np.asarray(geommesh.vertices)\nF = np.asarray(hemesh.faces)\nareas_np = 0.5 * igl.doublearea(V, F)\naccum = np.zeros(hemesh.n_vertices)\narea_accum = np.zeros(hemesh.n_vertices)\nuf_np = np.asarray(u_f)\nfor i, f in enumerate(F):\n    accum[f] += areas_np[i] * uf_np[i]\n    area_accum[f] += areas_np[i]\nverts_avg_ref = accum / np.maximum(area_accum, 1e-12)\n\nrel_err_verts = np.linalg.norm(np.asarray(verts_avg_jax) - verts_avg_ref) / np.linalg.norm(verts_avg_ref)\nprint(\"face-&gt;vertex rel. error:\", rel_err_verts)\n\nvertex-&gt;face rel. error: 1.0413393664022524e-16\nface-&gt;vertex rel. error: 1.3698911362107636e-16\n\n\n\n\nComputing cell areas, perimeters, etc via corners\nTo compute, for instance, the cell area using the shoelace formula, you need to iterate around the faces adjacent to a vertex. This is not straightforward to vectorize because the number of adjacent faces per vertex can vary (there can be 5-, 6-, 7-sided cells etc.). One way to solve this is a scheme in which the lists of adjacent faces are “padded” in some manner, so that they are all the same length. This is cumbersome. Instead, let us split all “cell-based” quantities into contributions from “corners”, i.e., half-edges, like this:\n Source: CGAL\nTo compute the total area, we can sum over all half-edges \\((r,p)\\) opposite to a vertex \\(q\\). Numerically, this can be achieved efficiently using gather/scatter operations.\n\nsource\n\n\nsum_he_to_vertex_opposite\n\ndef sum_he_to_vertex_opposite(\n    hemesh:HeMesh, he_field:Float[Array, 'n_hes ...']\n)-&gt;Float[Array, 'n_vertices ...']:\n\nSum a half-edge field onto opposite vertices.\nAttention: can include boundary half-edges!\nhemesh: connectivity information he_field: (n_hes,) or (n_hes, d) array\n\nsource\n\n\nsum_he_to_vertex_incoming\n\ndef sum_he_to_vertex_incoming(\n    hemesh:HeMesh, he_field:Float[Array, 'n_hes ...']\n)-&gt;Float[Array, 'n_vertices ...']:\n\nSum a half-edge field onto destination vertices.\nhemesh: connectivity information he_field: (n_hes,) or (n_hes, d) array\n\nsource\n\n\nget_cell_areas\n\ndef get_cell_areas(\n    geommesh:GeomMesh, hemesh:HeMesh\n)-&gt;Float[Array, 'n_vertices']:\n\nCompute areas of cells by mesh traversal (don’t use for simulation, inefficient).\nBoundary vertices get area 0.\n\n## Let's use the adjacency matrix to compute the area of all cells. First, compute all corner areas\n\na, b, c = (hemesh.dest[hemesh.nxt], hemesh.dest[hemesh.prv], hemesh.dest)\n\ncorner_areas = jax.vmap(trig.get_voronoi_corner_area)(geommesh.vertices[a], geommesh.vertices[b], geommesh.vertices[c])\ncell_areas_corner = sum_he_to_vertex_opposite(hemesh, corner_areas)\ncell_areas_corner = cell_areas_corner.at[hemesh.is_bdry].set(0)\n\n\n# for comparison, compute the areas by mesh traversal\n\ncell_areas_iterative = -1*get_cell_areas(geommesh, hemesh)\nnp.abs(cell_areas_iterative-cell_areas_corner).max() # works!\n\nnp.float64(0.42505900310931344)\n\n\n\nsource\n\n\nget_coordination_number\n\ndef get_coordination_number(\n    hemesh:HeMesh\n)-&gt;Float[Array, 'n_vertices']:\n\n\n# using the gather/scatter trick, we can also compute the coordination number of each vertex\n\nget_coordination_number(hemesh)\n\nArray([4., 6., 6., 7., 6., 6., 6., 6., 6., 4., 4., 6., 6., 5., 6., 6., 6.,\n       5., 5., 6., 3., 4., 6., 6., 6., 7., 5., 6., 6., 7., 7., 6., 4., 4.,\n       3., 7., 6., 6., 5., 7., 6., 6., 6., 6., 7., 5., 4., 5., 5., 6., 6.,\n       7., 7., 5., 6., 6., 7., 5., 3., 5., 7., 6., 5., 6., 5., 6., 7., 6.,\n       5., 4., 5., 5., 6., 6., 6., 6., 6., 7., 6., 6., 4., 6., 6., 5., 6.,\n       4., 4., 6., 6., 6., 7., 4., 6., 6., 6., 5., 6., 6., 6., 4., 4., 6.,\n       6., 6., 6., 7., 6., 4., 4., 5., 4., 4., 3., 4., 4., 3., 4., 3., 5.,\n       4., 3., 4., 3., 5., 6., 6., 6., 6., 6., 6., 4.], dtype=float64)\n\n\n\n\nFinite-element gradient and cotan-Laplacian\nNext, we implement gradient (per-vertex scalar field -&gt; per-face vector field) and the cotan-Laplacian (vertex -&gt; vertex) using gather/scatter ops like above. The cotan-Laplacian is the discretization of the Laplace Beltrami operator on a triangular mesh.\nIn both cases, we start with a scalar field \\(u_i\\) defined per vertex \\(i\\) of the triangulation. The finite-element gradient is defined for each face \\(ijk\\), like so: \\[\n(\\nabla u)_{ijk} = \\sum_{l\\in \\{i,j,k\\}} u_l \\nabla\\phi_l\n\\] where \\(\\nabla\\phi_\\alpha\\) is the gradient of a linear finite element test function and takes the value \\[\n    \\nabla\\phi_i = \\tfrac{1}{2a_{ijk}} (\\mathbf{v}_k-\\mathbf{v}_j)^\\perp\n\\] plus cyclic permutations. Here, \\(a_{ijk}\\) is the triangle area, \\(\\mathbf{v}_i\\) are the vertex positions, and \\(()^\\perp\\) denotes rotation by 90 degrees (in 3D, you rotate about the triangle normal).\nThe cota-Laplacian computes the following per-vertex field: \\[\n(\\Delta u)_i = \\frac{1}{2} \\sum_{j} (\\cot\\alpha_j +\\cot\\beta_j) (u_j-u_i)\n\\] where the sum is over adjacent vertices, and \\(\\alpha_j, \\beta_j\\) are the two triangle angles “opposite” to the edge \\(ij\\).\nTo check for correctness, we can compare with this libgigl tutorial, using the test mesh and some random test fields.\n\nsource\n\n\ncompute_cotan_laplace\n\ndef compute_cotan_laplace(\n    hemesh:HeMesh, vertices:Float[Array, 'n_vertices dim'], vertex_field:Float[Array, 'n_vertices ...']\n)-&gt;Float[Array, 'n_vertices ...']:\n\nCompute cotangent laplacian of a per-vertex field (natural boundary conditions).\n\n# Test against libigl cotmatrix (natural boundary conditions)\nkey = jax.random.PRNGKey(0)\nu = jax.random.normal(key, (hemesh.n_vertices,))\nu_vec = jax.random.normal(key, (hemesh.n_vertices, 3))\n\nL = igl.cotmatrix(np.asarray(geommesh.vertices), np.asarray(hemesh.faces))\n\nlap_jax = compute_cotan_laplace(hemesh, geommesh.vertices, u)\nlap_igl = L @ np.asarray(u)\n\nrel_err = np.linalg.norm(np.asarray(lap_jax) - lap_igl) / np.linalg.norm(lap_igl)\nprint(\"scalar field rel. error:\", rel_err)\n\nlap_jax_vec = compute_cotan_laplace(hemesh, geommesh.vertices, u_vec)\nlap_igl_vec = L @ np.asarray(u_vec)\n\nrel_err_vec = np.linalg.norm(np.asarray(lap_jax_vec) - lap_igl_vec) / np.linalg.norm(lap_igl_vec)\nprint(\"vector field rel. error:\", rel_err_vec)\n\nscalar field rel. error: 1.8132090493215958e-16\nvector field rel. error: 2.0011748826180605e-16\n\n\n\nsource\n\n\ncompute_gradient_3d\n\ndef compute_gradient_3d(\n    hemesh:HeMesh, vertices:Float[Array, 'n_vertices 3'], vertex_field:Float[Array, 'n_vertices ...']\n)-&gt;Float[Array, 'n_faces 3 ...']:\n\nCompute the linear finite-element gradient (constant per face).\n\nsource\n\n\ncompute_gradient_2d\n\ndef compute_gradient_2d(\n    hemesh:HeMesh, vertices:Float[Array, 'n_vertices 2'], vertex_field:Float[Array, 'n_vertices ...']\n)-&gt;Float[Array, 'n_faces 2 ...']:\n\nCompute the linear finite-element gradient (constant per face).\n\n# here's how to compute the gradient in libigl\n\ngrad_matrix = igl.grad(np.asarray(geommesh.vertices), np.asarray(hemesh.faces))\n# calculate the gradient of field by matrix multiplication\ngrad_igl = grad_matrix @ np.asarray(u)\n# order='F' copied from igl tutorial\ngrad_igl = grad_igl.reshape((hemesh.n_faces, geommesh.dim), order='F')\n\n\ngrad_jax = compute_gradient_2d(hemesh, geommesh.vertices, u)\n\nrel_err_grad = np.linalg.norm(np.asarray(grad_jax) - grad_igl) / np.linalg.norm(grad_igl)\nprint(\"gradient rel. error:\", rel_err_grad)\n\ngradient rel. error: 1.413315746703021e-16\n\n\n\n# same test, in 3d\n\ngrad_matrix_3d = igl.grad(np.asarray(geommesh_3d.vertices), np.asarray(hemesh.faces))\ngrad_igl_3d = grad_matrix_3d @ np.asarray(u)\ngrad_igl_3d = grad_igl_3d.reshape((hemesh.n_faces, geommesh_3d.dim), order='F')\n\ngrad_jax_3d = compute_gradient_3d(hemesh, geommesh_3d.vertices, u)\n\nrel_err_grad_3d = np.linalg.norm(np.asarray(grad_jax_3d) - grad_igl_3d) / np.linalg.norm(grad_igl_3d)\nprint(\"gradient rel. error:\", rel_err_grad_3d)\n\ngradient rel. error: 1.5657863888820882e-16\n\n\n\n\nWrapping as linear operators\nIt’s often useful to think of functions like compute_cotan_laplace() as a linear operator on fields on meshes. For example, imagine you want to solve the Laplace equation on a mesh with fixed vertex positions and connectivity. You will want to use a linear solver. Luckily, most such solvers only need to be able to compute the action of a linear operator on an input vector, and don’t need an explicit matrix representation.\nIn the JAX ecosystem, the lineax library defines linear solvers. We can wrap compute_cotan_laplace() as a linear operator, which allows us to pass it into iterative linear algebra algorithms.\n\n# \"bake in\" the connectivity and vertex positions\n\nlaplace_op = functools.partial(compute_cotan_laplace, hemesh, geommesh.vertices)\n_ = laplace_op(u)\n\n\n# define the linear operator\n\nlaplace_op_lx = lineax.FunctionLinearOperator(laplace_op,\n                                              input_structure=jax.eval_shape(laplace_op, u))",
    "crumbs": [
      "Adjacency-like operators on half-edge meshes"
    ]
  },
  {
    "objectID": "06_self-propelled_Voronoi_model.html",
    "href": "06_self-propelled_Voronoi_model.html",
    "title": "Area-perimeter self-propelled Voronoi model",
    "section": "",
    "text": "After the toy example of notebook 02, let’s try to implement a slightly more complicated model, the self-propelled Voronoi area-perimeter Voronoi (VAP) model of Bi et al., 2016. This 2D model comprises most of the ingredients we will see in more general simulations, from a coding perspective.\nIn brief, in the VAP, cells are modeled as the Voronoi tesselation for a series of centroids \\(\\mathbf{v}_i\\) (our triangulation vertices). Their overdamped dynamics comprises two terms: self-propulsion and relaxation of an elastic energy: \\[\\partial_t \\mathbf{v}_i = -\\nabla_{\\mathbf{v}_i} E_{AP} + v_0 \\hat{\\mathbf{n}}_i\\] For each cell \\(i\\), \\(\\hat{\\mathbf{n}}_i\\) is a unit vector (so we will represent it by an angle \\(\\theta_i\\)) that determines the direction of motion. Units of time are chosen so that the coefficient of \\(\\nabla E_{AP}\\) is \\(1\\). The energy is defined in terms of the Voronoi area \\(a_i\\) and Voronoi perimeter \\(p_i\\) of each cell: \\[E_{AP} = \\sum_i k_a(a_i-a_0)^2 + k_p(p_i-p_0)^2 \\] where \\(k_a, k_p\\) are elastic constants, and \\(a_0, p_0\\) are the target area and perimeter. They define the “shape index” \\(s_0= p_0/\\sqrt{a_0}\\). The key physics is that above a critical shape index \\(s_0^*\\), the model has a degenerate set of ground states, since for a large \\(p_0\\), there are many polygons with the given target area and perimeter (think floppy balloon).\nThe orientation \\(\\theta_i\\) of each cell is also dynamic. It undergoes rotational diffusion: \\[d\\theta_i = D_\\theta dW_{t, i} \\] where \\(dW_{t,i}\\) is Brownian motion, independent for each cell \\(i\\), and \\(D_\\theta\\) is the diffusion constant.",
    "crumbs": [
      "Area-perimeter self-propelled Voronoi model"
    ]
  },
  {
    "objectID": "06_self-propelled_Voronoi_model.html#voronoi-cell-geometry-area-perimeter",
    "href": "06_self-propelled_Voronoi_model.html#voronoi-cell-geometry-area-perimeter",
    "title": "Area-perimeter self-propelled Voronoi model",
    "section": "Voronoi cell geometry (area & perimeter)",
    "text": "Voronoi cell geometry (area & perimeter)\nWe compute areas from corner contributions and perimeters from dual-edge lengths, using gather/scatter operations on the half-edge mesh. Boundary cells are handled by mirroring (doubling the area/perimeter).\n\n@jax.jit\ndef get_triangle_area(geommesh: GeomMesh, hemesh: HeMesh) -&gt;Float[jax.Array, \" n_faces\"]:\n    \"\"\"Compute triangle areas.\"\"\"\n    a = hemesh.dest[hemesh.nxt]\n    b = hemesh.dest[hemesh.prv]\n    c = hemesh.dest\n    return jax.vmap(trig.get_triangle_area)(\n        geommesh.vertices[a], geommesh.vertices[b], geommesh.vertices[c])\n\n@jax.jit\ndef get_cell_area(geommesh: GeomMesh, hemesh: HeMesh) -&gt;Float[jax.Array, \" n_vertices\"]:\n    \"\"\"Compute Voronoi area for each cell.\"\"\"\n    a = hemesh.dest[hemesh.nxt]\n    b = hemesh.dest[hemesh.prv]\n    c = hemesh.dest\n    corner_areas = jax.vmap(trig.get_voronoi_corner_area)(\n        geommesh.vertices[a], geommesh.vertices[b], geommesh.vertices[c])\n    corner_areas = jnp.where(hemesh.is_bdry_he, 0, corner_areas)\n    cell_areas = msh.sum_he_to_vertex_opposite(hemesh, corner_areas)\n    cell_areas = jnp.where(hemesh.is_bdry, 2.0 * cell_areas, cell_areas)\n    return cell_areas\n\n@jax.jit\ndef get_cell_perimeter(geommesh: GeomMesh, hemesh: HeMesh) -&gt; Float[jax.Array, \" n_vertices\"]:\n    \"\"\"Compute Voronoi perimeters for each cell.\"\"\"\n    a = hemesh.dest[hemesh.nxt]\n    b = hemesh.dest[hemesh.prv]\n    c = hemesh.dest\n    corner_perims = jax.vmap(trig.get_voronoi_corner_perimeter)(\n        geommesh.vertices[a], geommesh.vertices[b], geommesh.vertices[c])\n    corner_perims = jnp.where(hemesh.is_bdry_he, 0, corner_perims)\n    cell_perims = msh.sum_he_to_vertex_opposite(hemesh, corner_perims)\n    cell_perims = jnp.where(hemesh.is_bdry, 2.0 * cell_perims, cell_perims)\n    return cell_perims\n\n@jax.jit\ndef energy_ap(geommesh: GeomMesh, hemesh: HeMesh, a0: float, p0: float,\n              k_a: float = 1.0, k_p: float = 1.0, k_penalty: float=10) -&gt; Float[jax.Array, \"\"]:\n    \"\"\"Area-perimeter energy for Voronoi cells.\n    Adds small penalty for triangles with negative area.\n    \"\"\"\n    cell_areas = get_cell_area(geommesh, hemesh)    \n    cell_perimeters = get_cell_perimeter(geommesh, hemesh)\n    tri_areas = get_triangle_area(geommesh, hemesh)\n    a_min = 0.25*(a0/2)\n    penality = k_penalty*jnp.where(tri_areas &lt; a_min, k_a * (tri_areas-a_min)**2, 0.0).mean()\n\n    return jnp.mean(k_a * (cell_areas-a0)**2 + k_p * (cell_perimeters-p0)**2) + penality\n\n\ncell_areas, cell_perimeters = (get_cell_area(geommesh, hemesh), get_cell_perimeter(geommesh, hemesh))\n\na_mean, p_mean = (cell_areas[~hemesh.is_bdry].mean(), cell_perimeters[~hemesh.is_bdry].mean())\na_mean, p_mean, p_mean/np.sqrt(a_mean)\n\n(Array(0.02756258, dtype=float64),\n Array(0.63463959, dtype=float64),\n Array(3.82267399, dtype=float64))\n\n\n\nget_triangle_area(geommesh, hemesh).mean()*2, a_mean\n\n(Array(0.02669562, dtype=float64), Array(0.02756258, dtype=float64))\n\n\n\n# double check against \"manual\" area and \"perimeter\" computation using mesh traversal",
    "crumbs": [
      "Area-perimeter self-propelled Voronoi model"
    ]
  },
  {
    "objectID": "06_self-propelled_Voronoi_model.html#energy-relaxation-no-self-propulsion",
    "href": "06_self-propelled_Voronoi_model.html#energy-relaxation-no-self-propulsion",
    "title": "Area-perimeter self-propelled Voronoi model",
    "section": "Energy relaxation (no self-propulsion)",
    "text": "Energy relaxation (no self-propulsion)\nWe first relax the area–perimeter energy to verify that the constraints are satisfied.\n\n@jax.jit\ndef relax_energy_step(geommesh: GeomMesh, hemesh: HeMesh,\n              a0: float, p0: float,\n              step_size: float = 0.01,\n              k_a: float = 1.0, k_p: float = 1.0) -&gt; Tuple[GeomMesh, Float[jax.Array, \"\"]]:\n    loss, grad = jax.value_and_grad(energy_ap)(geommesh, hemesh, a0, p0, k_a, k_p)\n    updated_vertices = geommesh.vertices - step_size * grad.vertices\n    geommesh_updated = dataclasses.replace(geommesh, vertices=updated_vertices)\n    return geommesh_updated, loss\n\n\n# energy parameters\na0 = a_mean\ns0 = 3\np0 = s0*jnp.sqrt(a0)\n\n# relaxation parameters\nstep_size = 0.02\nn_steps = 10000\n\ngeommesh_relaxed = copy.copy(geommesh)\nlosses = []\n\nfor _ in range(n_steps):\n    geommesh_relaxed, loss = relax_energy_step(geommesh_relaxed, hemesh, a0, p0, step_size=step_size)\n    losses.append(loss)\n\nlosses = jnp.array(losses)\n\n\nfig = plt.figure(figsize=(4, 3))\nplt.plot(np.asarray(losses))\nplt.xlabel(\"step\")\nplt.ylabel(\"energy\");\n\n\n\n\n\n\n\n\n\ngeommesh_relaxed = msh.set_voronoi_face_positions(geommesh_relaxed, hemesh)\n\nfig, ax = plt.subplots(figsize=(4, 4))\nax.add_collection(msh.cellplot(hemesh, geommesh.face_positions,\n                               cell_colors=np.array([0.7, 0.7, 0.9, 0.2]),\n                               mpl_polygon_kwargs={\"lw\": 0.5, \"ec\": \"tab:blue\"}))\nax.add_collection(msh.cellplot(hemesh, geommesh_relaxed.face_positions,\n                               cell_colors=np.array([0.9, 0.6, 0.6, 0.2]),\n                               mpl_polygon_kwargs={\"lw\": 0.5, \"ec\": \"tab:red\"}))\nax.set_aspect(\"equal\")\nax.autoscale_view();\n\n\n\n\n\n\n\n\n\nareas_relaxed, perim_relaxed = (get_cell_area(geommesh, hemesh), get_cell_perimeter(geommesh, hemesh))\njnp.abs(areas_relaxed - a0)[hemesh.is_bdry].mean(), jnp.abs(perim_relaxed - p0)[hemesh.is_bdry].mean()\n\n(Array(0.00400013, dtype=float64), Array(0.12046733, dtype=float64))\n\n\n\nRelaxation with T1s\nNext, let’s allow T1s. To ensure we don’t flip the same edge multiple times, let’s use a cooldown period.\n\ncooldown_steps = 5\nl_min_T1 = 0.0\n\nn_steps = 10000\ncooldown_counter = jnp.zeros(hemesh.n_hes)\nsim_steps = jnp.arange(n_steps)",
    "crumbs": [
      "Area-perimeter self-propelled Voronoi model"
    ]
  },
  {
    "objectID": "06_self-propelled_Voronoi_model.html#overdamped-dynamics-with-self-propulsion-deterministic",
    "href": "06_self-propelled_Voronoi_model.html#overdamped-dynamics-with-self-propulsion-deterministic",
    "title": "Area-perimeter self-propelled Voronoi model",
    "section": "Overdamped dynamics with self-propulsion (deterministic)",
    "text": "Overdamped dynamics with self-propulsion (deterministic)\nNext, let’s add the self-propulsion term. We initialize the angles \\(\\theta_i\\) at random. We can store the angles as an extra vertex_attrib in our geommesh, using the functionality of the GeomMesh dataclass. We already have an IntEnum which we can use as keys to the vertex_attrib dictionary, like described in notebook 01.\nAs a first step, we can keep the orientations fixed and just integrate \\(\\partial_t \\mathbf{v}_i = -\\nabla_{\\mathbf{v}_i} E_{AP} + v_0\\hat{\\mathbf{n}}_i\\), like in the above example. We only simulate for a couple of steps.\n\nclass VertexAttribs(IntEnum):\n    SELF_PROPULSION_ORIENTATION = 1\n\n\njax.config.update(\"jax_disable_jit\", False)\n\n\n# initialize orientations and store as a vertex attribute\nkey = jax.random.key(0)\ntheta0 = jax.random.uniform(key, shape=(hemesh.n_vertices,), minval=0.0, maxval=2*jnp.pi)\n#theta0 = theta0 + 0.3 * 2*jnp.pi*jnp.ones(hemesh.n_vertices)\n\ngeommesh_sp = copy.copy(geommesh)\ngeommesh_sp = dataclasses.replace(\n    geommesh_sp,\n    vertex_attribs={VertexAttribs.SELF_PROPULSION_ORIENTATION: theta0},\n)\n\n@jax.jit\ndef ap_selfprop_vector_field(\n    t: Float[jax.Array, \"\"],\n    y: GeomMesh,\n    args: Tuple[HeMesh, float, float, float, float, float],\n) -&gt; GeomMesh:\n    \"\"\"RHS for overdamped area-perimeter dynamics with self-propulsion.\"\"\"\n    hemesh, a0, p0, v0, k_a, k_p = args\n    theta = y.vertex_attribs[VertexAttribs.SELF_PROPULSION_ORIENTATION]\n    grad = jax.grad(energy_ap)(y, hemesh, a0, p0, k_a, k_p)\n    n_hat = jnp.stack([jnp.cos(theta), jnp.sin(theta)], axis=-1)\n    velocity = -grad.vertices + jnp.where(hemesh.is_bdry[:,None], 0, v0 * n_hat)\n    zero_vertex_attribs = {key: jnp.zeros_like(val) for key, val in y.vertex_attribs.items()}\n    return dataclasses.replace(\n        y,\n        vertices=velocity,\n        vertex_attribs=zero_vertex_attribs,\n    )\n\nterm_sp = diffrax.ODETerm(ap_selfprop_vector_field)\nsolver_sp = diffrax.Euler() #Tsit5\n\ndt_sp = 0.01\nn_steps_sp = 20000 # begins to fail at some point\nv0_sp = 0.001\nstep_times_sp = dt_sp * jnp.arange(n_steps_sp + 1)\n\ncooldown_steps = 2\n\n\n# check magnitude of the gradient forces vs the self-propulsion \n\ngrad0 = jax.grad(energy_ap)(geommesh_sp, hemesh, a0, p0, 1, 1).vertices\nsp0 = v0_sp*jnp.stack([jnp.cos(theta0), jnp.sin(theta0)], axis=-1)\n\njnp.linalg.norm(sp0, axis=-1).mean() / jnp.linalg.norm(grad0, axis=-1).mean()\n\nArray(0.31473995, dtype=float64)\n\n\n\n@jax.jit\ndef scan_fun_selfprop(\n    carry: Tuple[GeomMesh,\n                 HeMesh,\n                 Float[jax.Array, \" n_hes\"],\n                 Float[jax.Array, \"\"],\n                 object,],\n    tnext: Float[jax.Array, \"\"],\n) -&gt; Tuple[\n    Tuple[GeomMesh,\n          HeMesh,\n          Float[jax.Array, \" n_hes\"],\n          Float[jax.Array, \"\"],\n          object,],\n    GeomMesh]:\n    geommesh_curr, hemesh_curr, cooldown_counter, tprev, solver_state = carry\n    args = (hemesh_curr, a0, p0, v0_sp, 1.0, 1.0)\n    geommesh_next, _, _, solver_state, _ = solver_sp.step(\n        term_sp, tprev, tnext, geommesh_curr, args, solver_state, made_jump=False\n    )\n    face_positions = msh.get_voronoi_face_positions(geommesh_next.vertices, hemesh_curr)\n    edge_lengths = msh.get_signed_dual_he_length(geommesh_next.vertices, face_positions, hemesh_curr)\n    to_flip = (edge_lengths &lt; l_min_T1) & (cooldown_counter == 0)\n    hemesh_next = msh.flip_all(hemesh_curr, to_flip)\n    cooldown_counter = jnp.where(to_flip, cooldown_steps, jnp.clip(cooldown_counter - 1, 0))\n    return (geommesh_next, hemesh_next, cooldown_counter, tnext, solver_state), geommesh_next\n\n\ncooldown_counter_sp = jnp.zeros(hemesh.n_hes)\ninit_solver_state_sp = solver_sp.init(\n    term_sp, step_times_sp[0], step_times_sp[1], geommesh_sp, (hemesh, a0, p0, v0_sp, 1.0, 1.0))\ninit = (geommesh_sp, hemesh, cooldown_counter_sp, step_times_sp[0], init_solver_state_sp)\n\n\n(geommesh_final, hemesh_final, cooldown, _, _), traj = jax.lax.scan(scan_fun_selfprop, init, step_times_sp[1:])\n\n\n# unpack the trajectory\ntraj = msh.tree_unstack(traj)\nlen(traj)\n\n20000\n\n\n\ngeommesh_sp = msh.set_voronoi_face_positions(geommesh_sp, hemesh)\ngeommesh_final = msh.set_voronoi_face_positions(geommesh_final, hemesh_final)\n\nareas = get_cell_area(geommesh_final, hemesh_final)\nedge_lengths = msh.get_signed_dual_he_length(geommesh_final.vertices, geommesh_final.face_positions, hemesh_final)\n\n\nedge_lengths.min(), areas.min()\n\n(Array(0.01135076, dtype=float64), Array(0.01023393, dtype=float64))\n\n\n\nfig, ax = plt.subplots(figsize=(4, 4))\n\n# plt.triplot(*geommesh_sp.vertices.T, hemesh.faces)\n\nplt.triplot(*geommesh_final.vertices.T, hemesh_final.faces)\n#plt.scatter(*geommesh_final.vertices.T, c=areas, cmap=\"viridis\", s=20, vmin=0)\n\n#ax.add_collection(msh.cellplot(hemesh, geommesh_sp.face_positions,\n#                               cell_colors=np.array([0.7, 0.7, 0.9, 0.2]),\n#                               mpl_polygon_kwargs={\"lw\": 0.5, \"ec\": \"tab:blue\"}))\nax.add_collection(msh.cellplot(hemesh_final, geommesh_final.face_positions,\n                               cell_colors=np.array([0.9, 0.6, 0.6, 0.2]),\n                               mpl_polygon_kwargs={\"lw\": 0.5, \"ec\": \"tab:red\"}))\n\n\n\nax.set_aspect(\"equal\")\nax.autoscale_view();\n\n\n\n\n\n\n\n\n\nStochastic orientation + T1 flips (step-by-step)\nWe now include rotational diffusion for \\(\\theta_i\\) and perform edge flips when Voronoi dual edges fall below a threshold. Like before, a short cooldown avoids immediate re-flips. We can use diffrax to solve the stochastic differential equation for the orientations, like in this tutorial. Let’s also implement the “pattern” for simulation loops with jax.lax.scan. We need to make sure that the timestepping for the SDE and the relaxational dynamics for the vertices is consistent.\nNote that the simulation generally diverges if the self-propulsion term is too strong, due to effects at the boundaries. A more carefull handling of the boundaries (adding T1s on the boundaries, or using periodic BCs) is beyond the scope of this notebook.\n\n# minimal example for solving an SDE, from diffrax tutorial\n\nt0, t1 = 0, 3\ndt = 0.05\ny0 = 1.0\n\nargs = None\ndrift = lambda t, y, args: -y\ndiffusion = lambda t, y, args: 0.1 * t\n\n\nbrownian_motion =  diffrax.VirtualBrownianTree(t0, t1, tol=1e-3, shape=(), key=jax.random.PRNGKey(0))\nterms = diffrax.MultiTerm(diffrax.ODETerm(drift),  diffrax.ControlTerm(diffusion, brownian_motion))\nsolver = diffrax.Euler()\nsaveat = diffrax.SaveAt(dense=True)\n\n\nsol = diffrax.diffeqsolve(terms, solver, t0, t1, dt0=dt, y0=y0, saveat=saveat)\nprint(sol.evaluate(1.1))  # DeviceArray(0.89436394)\n\n0.27087012958157025\n\n\n\n# stepping thru the solve one-by-one\nstate = solver.init(terms, t0, t0+dt, y0, args)\n@jax.jit\ndef sde_step():\n    return solver.step(terms, t0, t0+dt, y0, args, state, made_jump=False)\n_ = sde_step()\n\n\n# handling of theta_term is not ideal yet, should be passed somehow as a argument.\n# maybe we should use equinox for this, so we can still JIT-compile.\n\n@jax.jit\ndef apply_t1_flips(\n    geommesh: GeomMesh,\n    hemesh: HeMesh,\n    cooldown_counter: Int[jax.Array, \" n_hes\"],\n    l_min_T1: float,\n    cooldown_steps: int,) -&gt; Tuple[HeMesh, Int[jax.Array, \" n_hes\"], Bool[jax.Array, \" n_hes\"],]:\n    \"\"\"Apply T1 flips with a per-edge cooldown.\"\"\"\n    face_positions = msh.get_voronoi_face_positions(geommesh.vertices, hemesh)\n    edge_lengths = msh.get_signed_dual_he_length(geommesh.vertices, face_positions, hemesh)\n    to_flip = (edge_lengths &lt; l_min_T1) & (cooldown_counter == 0)\n    hemesh_next = msh.flip_all(hemesh, to_flip)\n    cooldown_counter = jnp.where(\n        to_flip,\n        cooldown_steps,\n        jnp.clip(cooldown_counter - 1, 0),)\n    return hemesh_next, cooldown_counter, to_flip\n\n\n@jax.jit\ndef theta_drift(\n    t: Float[jax.Array, \"\"],\n    theta: Float[jax.Array, \" n_vertices\"],\n    args: Float[jax.Array, \"\"],) -&gt; Float[jax.Array, \" n_vertices\"]:\n    \"\"\"Drift for orientation angles (zero drift).\"\"\"\n    return jnp.zeros_like(theta)\n\n\n@jax.jit\ndef theta_diffusion(\n    t: Float[jax.Array, \"\"],\n    theta: Float[jax.Array, \" n_vertices\"],\n    args: Float[jax.Array, \"\"],) -&gt; lineax.AbstractLinearOperator:\n    \"\"\"Diffusion operator for orientations (diagonal noise).\"\"\"\n    d_theta = args\n    diagonal = d_theta * jnp.ones_like(theta)\n    return lineax.DiagonalLinearOperator(diagonal)\n\n\ntheta_solver = diffrax.EulerHeun()\nd_theta: Float[jax.Array, \"\"] = jnp.asarray(0.5)\n\n\ndef step_theta_sde(\n    theta: Float[jax.Array, \" n_vertices\"],\n    tprev: Float[jax.Array, \"\"],\n    tnext: Float[jax.Array, \"\"],\n    d_theta: Float[jax.Array, \"\"],\n    theta_solver_state: object,) -&gt; Tuple[Float[jax.Array, \" n_vertices\"], object,]:\n    \"\"\"Single SDE step for orientations using diffrax (step-based).\"\"\"\n    theta_next, _, _, theta_solver_state, _ = theta_solver.step(\n        theta_term,\n        tprev,\n        tnext,\n        theta,\n        d_theta,\n        theta_solver_state,\n        made_jump=False,)\n    return theta_next, theta_solver_state\n\n\n@jax.tree_util.register_dataclass\n@dataclasses.dataclass\nclass SDEState:\n    geommesh: GeomMesh\n    hemesh: HeMesh\n    cooldown_counter: Int[jax.Array, \" n_hes\"]\n    tprev: Float[jax.Array, \"\"]\n    solver_state: object\n    theta: Float[jax.Array, \" n_vertices\"]\n    theta_solver_state: object\n\n\n@jax.tree_util.register_dataclass\n@dataclasses.dataclass\nclass SDELog:\n    geommesh: GeomMesh\n    hemesh: HeMesh\n    energy: Float[jax.Array, \"\"]\n    t1_count: Int[jax.Array, \"\"]\n\nv0_sp = 0.005\n\n@jax.jit\ndef scan_fun_selfprop_sde(\n    state: SDEState,\n    tnext: Float[jax.Array, \"\"],) -&gt; tuple[SDEState, SDELog]:\n    # time-step SDE for self-propulsion orientation\n    theta_next, theta_solver_state = step_theta_sde(\n        state.theta,\n        state.tprev,\n        tnext,\n        d_theta,\n        state.theta_solver_state,)\n    geommesh_curr = dataclasses.replace(\n        state.geommesh,\n        vertex_attribs={VertexAttribs.SELF_PROPULSION_ORIENTATION: theta_next,},)\n    args = (state.hemesh, a0, p0, v0_sp, 1.0, 1.0,)\n    # relaxational dynamics for vertices\n    geommesh_next, _, _, solver_state, _ = solver_sp.step(\n        term_sp,\n        state.tprev,\n        tnext,\n        geommesh_curr,\n        args,\n        state.solver_state,\n        made_jump=False,)\n    # T1 transitions for connectivity\n    hemesh_next, cooldown_counter, to_flip = apply_t1_flips(\n        geommesh_next,\n        state.hemesh,\n        state.cooldown_counter,\n        l_min_T1,\n        cooldown_steps,)\n    # make measurements for log\n    energy = energy_ap(geommesh_next, hemesh_next, a0, p0)\n    log = SDELog(\n        geommesh=geommesh_next,\n        hemesh=hemesh_next,\n        energy=energy,\n        t1_count=to_flip.sum(),)\n    next_state = SDEState(\n        geommesh=geommesh_next,\n        hemesh=hemesh_next,\n        cooldown_counter=cooldown_counter,\n        tprev=tnext,\n        solver_state=solver_state,\n        theta=theta_next,\n        theta_solver_state=theta_solver_state,)\n    return next_state, log\n\n\nbrownian.t0, brownian.t1\n\n(Array(0., dtype=float64, weak_type=True),\n Array(150.01, dtype=float64, weak_type=True))\n\n\n\ndt_sde = 0.01\nn_steps_sde = 8000\nstep_times_sde = dt_sde * jnp.arange(n_steps_sde + 1)\n\ncooldown_counter_sde = jnp.zeros(hemesh.n_hes, dtype=jnp.int32)\ntheta_init = geommesh_sp.vertex_attribs[VertexAttribs.SELF_PROPULSION_ORIENTATION]\nkey_sde = jax.random.key(1)\n\ninit_solver_state_sde = solver_sp.init(\n    term_sp,\n    step_times_sde[0],\n    step_times_sde[1],\n    geommesh_sp,\n    (hemesh, a0, p0, v0_sp, 1.0, 1.0,),)\nbrownian = diffrax.VirtualBrownianTree(\n    step_times_sde[0],\n    step_times_sde[-1] + dt_sde,\n    tol=1e-3,\n    shape=theta_init.shape,\n    key=key_sde,)\ntheta_term = diffrax.MultiTerm(\n    diffrax.ODETerm(theta_drift),\n    diffrax.ControlTerm(theta_diffusion, brownian),)\ntheta_solver_state = theta_solver.init(\n    theta_term,\n    step_times_sde[0],\n    step_times_sde[1],\n    theta_init,\n    d_theta,)\ninit_sde = SDEState(\n    geommesh=geommesh_sp,\n    hemesh=hemesh,\n    cooldown_counter=cooldown_counter_sde,\n    tprev=step_times_sde[0],\n    solver_state=init_solver_state_sde,\n    theta=theta_init,\n    theta_solver_state=theta_solver_state,)\n\n# Time stepping: scan advances (tprev -&gt; tnext) for both theta and vertex dynamics.\nfinal_state_sde, logs_sde = jax.lax.scan(\n    scan_fun_selfprop_sde,\n    init_sde,\n    step_times_sde[1:],)\ngeommesh_final_sde = final_state_sde.geommesh\nhemesh_final_sde = final_state_sde.hemesh\ntheta_final_sde = final_state_sde.theta\n\n# Measurements logged at each step: geometry, energy, and T1 flip counts.\ngeommesh_traj_sde = msh.tree_unstack(logs_sde.geommesh)\nhemesh_traj_sde = msh.tree_unstack(logs_sde.hemesh)\nflip_counts_sde = logs_sde.t1_count\nenergies_sde = logs_sde.energy\n\ntraj_sde = list(zip(geommesh_traj_sde, hemesh_traj_sde,))\n\n\n\nVisualize trajectory\nLet’s add an ipywidget-based slider plot that allows us to visualize the trajectory of the mesh’s time evolution.\n\nnp.linalg.norm(geommesh_traj_sde[0].vertices-geommesh_traj_sde[-1].vertices, axis=-1).mean() # avg displacement\n\nnp.float64(0.10620549370268782)\n\n\n\nplt.plot(jnp.cumsum(flip_counts_sde))\n\n\n\n\n\n\n\n\n\ncell_id = 50\n\nplt.plot(logs_sde.geommesh.vertex_attribs[VertexAttribs.SELF_PROPULSION_ORIENTATION][:, cell_id])\n\n\n\n\n\n\n\n\n\nplt.plot(energies_sde)\n\n\n\n\n\n\n\n\n\nmsh.set_voronoi_face_positions(geommesh_traj_sde[-1], hemesh_traj_sde[-1])\n\nGeomMesh(D=2,N_V=131, N_HE=708, N_F=224)\n\n\n\nfig, ax = plt.subplots(figsize=(4, 4))\n\n#plt.triplot(*geommesh_traj_sde[0].vertices.T, hemesh_traj_sde[0].faces)\n\n#plt.triplot(*geommesh_traj_sde[-1].vertices.T, hemesh_traj_sde[-1].faces)\n#plt.scatter(*geommesh_final.vertices.T, c=areas, cmap=\"viridis\", s=20, vmin=0)\n\n\ngeommesh_traj_sde[-1] = msh.set_voronoi_face_positions(geommesh_traj_sde[-1], hemesh_traj_sde[-1])\n\nax.add_collection(msh.cellplot(hemesh_traj_sde[0], geommesh_traj_sde[0].face_positions,\n                               cell_colors=np.array([0.7, 0.7, 0.9, 0.2]),\n                               mpl_polygon_kwargs={\"lw\": 0.5, \"ec\": \"tab:blue\"}))\nax.add_collection(msh.cellplot(hemesh_traj_sde[-1], geommesh_traj_sde[-1].face_positions,\n                               cell_colors=np.array([0.9, 0.6, 0.6, 0.2]),\n                               mpl_polygon_kwargs={\"lw\": 0.5, \"ec\": \"tab:red\"}))\n\n\n\nax.set_aspect(\"equal\")\nax.autoscale_view();\n\n\n\n\n\n\n\n\n\ndef plot_traj_step(step_idx: int) -&gt; None:\n    geommesh_i, hemesh_i = traj_sde[step_idx]\n    face_positions = msh.get_voronoi_face_positions(geommesh_i.vertices, hemesh_i)\n    fig, ax = plt.subplots(figsize=(4, 4))\n    ax.add_collection(\n        msh.cellplot(\n            hemesh_i,\n            face_positions,\n            cell_colors=np.array([0.7, 0.7, 0.9, 0.25]),\n            mpl_polygon_kwargs={\"lw\": 0.5, \"ec\": \"k\"},\n        ),\n    )\n    ax.set_aspect(\"equal\")\n    ax.autoscale_view();\n\n\nwidgets.interact(\n    plot_traj_step,\n    step_idx=widgets.IntSlider(\n        value=0,\n        min=0,\n        max=len(traj_sde) - 1,\n        step=1,\n        description=\"step\",\n        continuous_update=False,\n    ),\n    )\n\n\n\n\n&lt;function __main__.plot_traj_step(step_idx: int) -&gt; None&gt;",
    "crumbs": [
      "Area-perimeter self-propelled Voronoi model"
    ]
  },
  {
    "objectID": "05_example_simulation.html",
    "href": "05_example_simulation.html",
    "title": "Simulation test case - optimize mesh to make triangles equilateral",
    "section": "",
    "text": "Let’s start with a simple test case to see whether the technology developed so far actually works. The goal is to move the vertices \\(\\mathbf{v}_i\\) of triangulation so all triangle edge lengths are as close to some \\(\\ell_0\\) as possible. We specify a pseudo-energy \\(E=\\sum_{ij} (|\\mathbf{v}_i-\\mathbf{v}_j| - \\ell_0)^2\\), and then minimize it using the JAX-provided gradients w.r.t the vertex positions.\nThis defines the “forward pass” of our “dynamical” model. In a second step, we can optimize over the model parameters, like \\(\\ell_0\\), to make the dynamics return some desired shape, for examlpe.\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport copy\n\nfrom tqdm.notebook import tqdm\n\n\nimport jax\nimport jax.numpy as jnp\n\n\njax.config.update(\"jax_enable_x64\", True)\njax.config.update(\"jax_debug_nans\", False)\njax.config.update('jax_log_compiles', False)\n\n\nfrom typing import Tuple\n\nimport dataclasses\n\nimport functools\n\n\n# import previously defined modules\nfrom triangulax import mesh as msh\nfrom triangulax.mesh import TriMesh, HeMesh, GeomMesh\n\nfrom triangulax import trigonometry as trg\n\n\nJAX-compatible scientific computing libraries - useful in future steps\nimport diffrax # ODE solvers\nimport lineax # linear solvers\nimport optimistix # optimisation (scientific-computing style, e.g. conjugate gradient)\nimport optax # optimisation (ML-style, e.g. ADAM)\n\n\nForward pass - minimize energy\n\nimport equinox as eqx\n\n# equinox has automated \"filtering\" of JAX-transforms. So we can work with objects which are not just pytrees of arrays\n# (like neural networks) and appy jit, vmap etc\n\n\n# load example mesh\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = GeomMesh(*hemesh.n_items, vertices=mesh.vertices)\n\nhemesh\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\nHeMesh(N_V=131, N_HE=708, N_F=224)\n\n\n\nfig = plt.figure(figsize=(4, 4))\nplt.triplot(*geommesh.vertices.T, mesh.faces)\nplt.axis(\"equal\");\n\n\n\n\n\n\n\n\n\nlengths = jnp.linalg.norm(geommesh.vertices[hemesh.orig]-geommesh.vertices[hemesh.dest], axis=1)\ntri_areas = -jax.vmap(trg.get_polygon_area)(geommesh.vertices[hemesh.faces])\n\nlengths.mean(), tri_areas.mean()\n\n(Array(0.18296366, dtype=float64), Array(0.01391806, dtype=float64))\n\n\nWe write the energy_function using a geommesh as an argument. This is overkill for present purposes ince only the vertex positions matter, but is useful to test the machinery. For more complicated simulations, we will want to use GeomMesh as a wrapper for the various arrays.\n\n@jax.jit\ndef energy_function(geommesh: GeomMesh, hemesh: HeMesh, ell_0: float=1):\n    edge_lengths = jnp.linalg.norm(geommesh.vertices[hemesh.orig]-geommesh.vertices[hemesh.dest], axis=1)\n    edge_energy = jnp.mean((edge_lengths/ell_0-1)**2) # this way, term is \"auto-normalized\"\n    # let's add a term for the triangle areas\n    a_0 = (np.sqrt(3)/4) * ell_0**2 # area of equilateral triangle\n    tri_area = -jax.vmap(trg.get_polygon_area)(geommesh.vertices[hemesh.faces])\n    area_energy = jnp.mean((tri_area/a_0-1)**2)\n    #jax.debug.print(\"E_l: {E_l}, E_a: {E_a}\",  E_l=edge_energy, E_a=area_energy)\n    # this is how you can print inside a JITed-function\n    return edge_energy + area_energy\n\n\nenergy_function(geommesh, hemesh)\n\nArray(1.60519339, dtype=float64)\n\n\n\n# using functools.partial, we can fill in some of our function's args, like so:\n\nfunctools.partial(energy_function, hemesh=hemesh, ell_0=1)(geommesh)\n\nArray(1.60519339, dtype=float64)\n\n\n\nval, grad = jax.value_and_grad(energy_function)(geommesh, hemesh) # computing value and grad works\n\nval, grad, grad.vertices.shape # the gradient is another GeomMesh with the same structure\n\n(Array(1.60519339, dtype=float64),\n GeomMesh(D=2,N_V=131, N_HE=708, N_F=224),\n (131, 2))\n\n\n\nconnectivity_grad = jax.grad(energy_function, argnums=1, allow_int=True)(geommesh, hemesh)\n# we can even compute the gradient w.r.t to the connectivity matrix. It is also a HeMesh\nconnectivity_grad, connectivity_grad.dest[0] # whatever that means\n\n(HeMesh(N_V=131, N_HE=708, N_F=224), np.void((b'',), dtype=[('float0', 'V')]))\n\n\n\nOptimization run\n\n# parameters of the energy\nell_0 = 0.5\n\n# parameters of the \"optimizer\"\nstep_size = 0.05\nN_steps = 10000\n\n@jax.jit\ndef make_step(geommesh: GeomMesh, hemesh: HeMesh, ell_0: float = 1, step_size: float = 0.01):\n    loss, grad = jax.value_and_grad(energy_function)(geommesh, hemesh, ell_0=ell_0)\n\n    # update - can be streamlined with equinox\n    updated_vertices = geommesh.vertices - step_size*grad.vertices\n    geommesh_updated = dataclasses.replace(geommesh, vertices=updated_vertices)\n    return geommesh_updated, hemesh, loss # explicitly return the hemesh - may need to be updated by flips!\n\n# define inital condition\ngeommesh_optimized = copy.copy(geommesh)\nhemesh_optimized = copy.copy(hemesh)\n\nlosses = []\n\nfor step in range(N_steps):\n    geommesh_optimized, hemesh_optimized, loss = make_step(geommesh_optimized, hemesh_optimized,\n                                                           ell_0=ell_0, step_size=step_size)\n    losses.append(loss)\n\nlosses = np.array(losses)\n\n\nfig = plt.figure(figsize=(4, 3))\nplt.plot(losses)\n\n\n\n\n\n\n\n\n\nfig = plt.figure(figsize=(4, 4))\nplt.triplot(*geommesh.vertices.T, hemesh.faces)\nplt.triplot(*geommesh_optimized.vertices.T, hemesh_optimized.faces)\nplt.axis(\"equal\");\n\n\n\n\n\n\n\n\n\nlengths_optimized = jnp.linalg.norm(geommesh_optimized.vertices[hemesh_optimized.orig]\n                                   -geommesh_optimized.vertices[hemesh_optimized.dest], axis=1)\njnp.abs(lengths_optimized-ell_0).mean(), lengths_optimized.mean()\n\n(Array(0.03342644, dtype=float64), Array(0.50208086, dtype=float64))\n\n\n\n\nUsing an ODE solver - diffrax\nAbove, we implemented “gradient descent” for the pseudo-energy, or, equivalently, a basic forward-Euler scheme for the ODE \\(\\partial_t \\mathbf{v}_i = - \\nabla_{\\mathbf{v}_i} E\\). For more complicated models, and to minimize coding effort, it makes sense to use a pre-made ODE solver instead. The diffrax library implements ODE and SDE solvers in JAX and is compatible with autodiff (you can differentiate through the solver), since it was designed for neural differential equations.\nFor “adiabatic” dynamics, which involve mimizing an energy at every timestep, we can use the “optimistix” library.\nThe below is based on the Stepping through a solver tutorial in diffrax. The reason we want to step through the solver one-by-one is to carry out T1s (in future simulations).\n\nimport diffrax\n\n\n# load example mesh\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = GeomMesh(*hemesh.n_items, vertices=mesh.vertices)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\n# define the RHS for the ODE solver\n@jax.jit\ndef vector_field(t, y, args):\n    return jax.tree_util.tree_map(lambda x: -1*x, jax.grad(energy_function)(y, *args))\nterm = diffrax.ODETerm(vector_field)\n\n# define time parameters and initial condition\ndt = 0.05\nt0 = 0.0\nt1 = 1000.0\nstep_times = jnp.arange(t0, t1, dt)\n\ny0 = geommesh\nargs = (hemesh, 0.5)\n\n\n# initialize the solver\n\nsolver = diffrax.Tsit5()\ny = y0\nstate = solver.init(term, t0, t0+dt, y0, args)\n\n\nstate\n\n(Array(True, dtype=bool), GeomMesh(D=2,N_V=131, N_HE=708, N_F=224))\n\n\n\n# go step by step\n\ndef scan_fun(carry, t):\n    state, y, tprev = carry \n    y, _, _, state, _ = solver.step(term, tprev, t, y, args, state, made_jump=False)\n    return (state, y, t), None\n\ninit = (state, y0, t0)\n(state, y, t), _ = jax.lax.scan(scan_fun, init, step_times[1:])\n\n# equivalent to:\n\n#for tprev, tnext in tqdm(zip(step_times[:-1], step_times[1:])):\n#    y, _, _, state, _ = solver.step(term, tprev, tnext, y, args, state, made_jump=False)\n#    tprev = tnext\n#    tnext = min(tprev + dt0, t1)\n\n\nfig = plt.figure(figsize=(4, 4))\nplt.triplot(*y0.vertices.T, hemesh.faces)\nplt.triplot(*y.vertices.T, hemesh.faces)\nplt.axis(\"equal\");\n\n\n\n\n\n\n\n\n\n\n\nMeta-training\nEventually, we aim to learn some dynamical rules for a tissue mechanics model that make the tissue carry out some desired behavior, like making a target shape.\nAs a toy example, let’s take the above “dynamics” which minimizes the pseudo-energy to make all triangles equilateral. It depends on the parameter \\(\\ell_0\\). Relaxation of the pseudo-energy for some number of steps defines our “forward pass”. Let’s try to optimize \\(\\ell_0\\) so that the tissue, at the end of the energy relaxation, has some target size (of course, a contrived problem, since we know the solution from the start).\n\n# package the whole training process into a JITed function\n\n@functools.partial(jax.jit, static_argnames=['N_steps'])\ndef relax_energy(initial_geommesh: GeomMesh, initial_hemesh: HeMesh, ell_0: float = 1,\n                 step_size: float = 0.01, N_steps: int = 1):\n\n    # define initial condition\n    geommesh_optimized = copy.copy(initial_geommesh)\n    hemesh_optimized = copy.copy(initial_hemesh)\n\n    # use a jax.lax.fori_loop loop for training. Much faster JIT-compilation than a Python for loop.\n    loss = 0\n    init = (initial_geommesh, initial_hemesh, loss)\n    def loop_fun(i, carry): return make_step(carry[0], carry[1], ell_0=ell_0, step_size=step_size) \n    geommesh_optimized, hemesh_optimized, loss = jax.lax.fori_loop(0, N_steps, loop_fun, init, unroll=None)\n    \n    return (geommesh_optimized, hemesh_optimized), loss\n\n\n(geommesh_optimized, hemesh_optimized), losses = relax_energy(geommesh, hemesh, ell_0=0.5, step_size=0.05, N_steps=5000)\nlosses\n\nArray(0.04463656, dtype=float64)\n\n\n\nfig = plt.figure(figsize=(4, 4))\nplt.triplot(*geommesh.vertices.T, hemesh.faces)\nplt.triplot(*geommesh_optimized.vertices.T, hemesh_optimized.faces)\nplt.axis(\"equal\");\n\n\n\n\n\n\n\n\n\n\n\nUsageError: Line magic function `%%timeit` not found.\n\n\n\nDefine Meta-training loss\nNow we need to define our meta-training loss. In this case, it’s just the deviation of the average edge length from the total. Note how the meta-loss is distinct from the pseudo-energy we minimize during the forward pass.\nLet’s use the equinox library to handle our problem, in anticipation of more complex ones down the line.\n\nclass RelaxationDynamics(eqx.Module): # we create a model wrapping our relaxational dynamics \n    ell_0: jax.Array\n    step_size : float = eqx.field(static=True)\n    N_steps : int = eqx.field(static=True)\n\n    def __call__(self, initial_geommesh: GeomMesh, initial_hemesh: HeMesh) -&gt; Tuple[GeomMesh, HeMesh]:\n        init = (initial_geommesh, initial_hemesh, 0)\n        def loop_fun(i, carry): return make_step(carry[0], carry[1], ell_0=self.ell_0, step_size=self.step_size)\n        geommesh_optimized, hemesh_optimized, loss = jax.lax.fori_loop(0, N_steps, loop_fun, init, unroll=None)\n        return geommesh_optimized, hemesh_optimized\n\n\n# define the meta-loss\n\ndef meta_loss(model: RelaxationDynamics, initial_geommesh: GeomMesh, initial_hemesh: HeMesh,  meta_ell0: float) -&gt; float:\n    geommesh_optimized, hemesh_optimized = model(initial_geommesh, initial_hemesh)\n    lengths = jnp.linalg.norm(geommesh_optimized.vertices[hemesh_optimized.orig]\n                              -geommesh_optimized.vertices[hemesh_optimized.dest], axis=-1)\n    return jnp.mean((lengths/meta_ell0-1)**2)\n\n\n# initialize the model, and test evaluating it\n\nstep_size = 0.01\nN_steps = 20000\n\ninitial_ell0 = 0.4\n\nmeta_ell0 = 0.3\n\nmodel_initial = RelaxationDynamics(ell_0=jnp.array([initial_ell0]), step_size=step_size, N_steps=N_steps)\nmodel_initial(geommesh, hemesh), meta_loss(model_initial, geommesh, hemesh, meta_ell0=meta_ell0)\n\n((GeomMesh(D=2,N_V=131, N_HE=708, N_F=224),\n  HeMesh(N_V=131, N_HE=708, N_F=224)),\n Array(0.11642016, dtype=float64))\n\n\n\n# let's check that the model still does what we want - looks good!\ngeommesh_trained, hemesh_trained = model_initial(geommesh, hemesh)\n\nfig = plt.figure(figsize=(4, 4))\nplt.triplot(*geommesh.vertices.T, hemesh.faces)\nplt.triplot(*geommesh_trained.vertices.T, hemesh_trained.faces)\nplt.axis(\"equal\");\n\n\n\n\n\n\n\n\n\n\nBatching\nTo evaluate the loss, we want to average over a bunch of initial conditions. These are analogous to batches in a normal ML problem.\n\n## Let us create a bunch of meshes with different initial positions and see if we can batch over them using vmap\n\nkey = jax.random.key(0)\nsigma = 0.02\n\nbatch_geom = []\nbatch_he = []\nfor i in range(3):\n    key, subkey = jax.random.split(key)\n    random_noise = jax.random.normal(subkey, shape=geommesh.vertices.shape)\n    batch_geom.append(dataclasses.replace(geommesh, vertices=geommesh.vertices+sigma*random_noise))\n    batch_he.append(copy.copy(hemesh))\n\n# we use a jax.tree.map to \"push\" the list axis into the underlying arrays.\nbatch_he_array = msh.tree_stack(batch_he)\nbatch_geom_array = msh.tree_stack(batch_geom)\nbatch_geom_array, batch_geom_array.vertices.shape\n\n(GeomMesh(D=2,N_V=131, N_HE=708, N_F=224), (3, 131, 2))\n\n\n\n# The result is a single mesh object with batch axes\n\nbatch_geom_array_out, batch_he_array_out = jax.vmap(model_initial)(batch_geom_array, batch_he_array) \nbatch_geom_array_out, batch_geom_array_out.vertices.shape, batch_he_array_out.orig.shape\n\n(GeomMesh(D=2,N_V=131, N_HE=708, N_F=224), (3, 131, 2), (3, 708))\n\n\n\n# we can unpack things again into a list of meshes\n\nbatch_geom_out = msh.tree_unstack(batch_geom_array_out)\nbatch_he_out = msh.tree_unstack(batch_he_array_out)\n\n\n# still works\n\ni = 2\nfig = plt.figure(figsize=(4, 4))\nplt.triplot(*batch_geom[i].vertices.T, batch_he[i].faces)\nplt.triplot(*batch_geom_out[i].vertices.T, batch_he_out[i].faces)\nplt.axis(\"equal\");\n\n\n\n\n\n\n\n\n\n# the batches are not identical, which is good.\nnot np.allclose(batch_geom_out[0].vertices, batch_geom_out[1].vertices)\n\nTrue\n\n\n\nCompute the batched loss\n\n# This is the right way to vmap the loss\njax.vmap(meta_loss, in_axes=(None, 0,0, None))(model_initial, batch_geom_array, batch_he_array, 0.8)\n\nArray([0.25692552, 0.25749475, 0.25687504], dtype=float64)\n\n\n\n# check against non-vmapped version. pretty similar, floating point errors likely at origin of differences\n[meta_loss(model_initial, batch_geom_out[i], batch_he_out[i], 0.8) for i in range(3)]\n\n[Array(0.24862364, dtype=float64),\n Array(0.24863551, dtype=float64),\n Array(0.24863234, dtype=float64)]\n\n\n\n\n\n\nOuter optimization\nNow we are in a position to “optiomize” our model parameter ell_0. Based on equinox CNN tutorial.\n\ndef batched_meta_loss(model, batch_geom_array, batch_he_array, meta_ell0):\n    return jnp.mean(jax.vmap(meta_loss, in_axes=(None, 0,0, None))(model, batch_geom_array, batch_he_array, meta_ell0))\n\nbatched_meta_loss_jit = jax.jit(batched_meta_loss)\n\n\n## Let's do a short profiling run - how much does JIT-compilation save? I guess a little!\n\n372 ms ± 3.23 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\n\n\n\n\n474 ms ± 4.09 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\n\n\n# hyper-parameters for the outer learning step.\n\nBATCH_SIZE = 3\nLEARNING_RATE = 1e-2\nLEARNING_STEPS = 20\nprint_every = 2\n\nstep_size = 0.01\nN_steps = 20000\n\nMETA_ELL0 = 0.4\ninitial_ell0 = 0.2\n\nmodel_initial = RelaxationDynamics(ell_0=jnp.array([initial_ell0]), step_size=step_size, N_steps=N_steps)\n\n\nloss, grads = eqx.filter_jit(eqx.filter_value_and_grad(batched_meta_loss))(model_initial,\n                                                                           batch_geom_array, batch_he_array, META_ELL0)\n\n\nloss, grads, grads.ell_0\n\n(Array(0.24848878, dtype=float64),\n RelaxationDynamics(ell_0=f64[1], step_size=0.01, N_steps=20000),\n Array([-2.48070057], dtype=float64))\n\n\n\nForward and reverse mode autodiff\nSince we are differentiation w.r.t. a small number of parameters (justy 1: \\(\\ell_0\\)), we can use forward mode automatic differentiation for increased efficiency. This may be the case more generally: if we want to learn “translationally invariant” models, where the parameters for all cells are equal, the parameter count we want to differentiate by may be small. Forward mode autodiff is also somewhat more “forgiving” when it comes to control flow.\nSee: https://docs.jax.dev/en/latest/notebooks/autodiff_cookbook.html\n\n@eqx.filter_jit\ndef outer_optimizer_step(model: RelaxationDynamics,\n                         batch_geom: GeomMesh, batch_he: HeMesh) -&gt; Tuple[RelaxationDynamics, float]:\n    \n    # compute loss and grad on batch\n    \n    #loss, grads = eqx.filter_value_and_grad(batched_meta_loss)(model, batch_geom_array, batch_he_array, META_ELL0)\n    #updates = jax.tree.map(lambda g: None if g is None else -LEARNING_RATE * g, grads)\n    #model = eqx.apply_updates(model, updates)\n    # grads is a PyTree with the same leaves as the trainable arrays of the model\n\n    # same story, but using forward mode autodiff\n    loss, grads = eqx.filter_jvp(lambda model: batched_meta_loss(model, batch_geom_array, batch_he_array, META_ELL0),\n                                 primals=[model,], tangents=[model,])\n    grads = grads/model.ell_0 # we used the current model values as a tangent vector, so we need to normalize\n    model = dataclasses.replace(model, ell_0=model.ell_0-LEARNING_RATE*grads)\n    \n    return model, loss\n\n\nmodel_stepped, loss = outer_optimizer_step(model_initial, batch_geom_array, batch_he_array)\n\n\nloss, model_initial.ell_0, model_stepped.ell_0\n\n(Array(0.24848878, dtype=float64),\n Array([0.2], dtype=float64),\n Array([0.22480701], dtype=float64))\n\n\n\nmodel = model_initial\n\nfor step in tqdm(range(LEARNING_STEPS)): # in the future, could also iterate over the initial conditions/batches\n    model, loss = outer_optimizer_step(model, batch_geom_array, batch_he_array)\n    if (step % print_every) == 0:\n        print(f\"Step: {step}, loss: {loss}, param: {model.ell_0}\")\n\n# 19s with forward mode vs 32s with reverse mode.\n\n\n\n\nStep: 0, loss: 0.24848877513396528, param: [0.22480701]\nStep: 2, loss: 0.14704976288187782, param: [0.26531774]\nStep: 4, loss: 0.08837946252729874, param: [0.29610925]\nStep: 6, loss: 0.05458715535792681, param: [0.31944763]\nStep: 8, loss: 0.03524215346058198, param: [0.33709312]\nStep: 10, loss: 0.024176542728598434, param: [0.35045283]\nStep: 12, loss: 0.017795094517620076, param: [0.36062556]\nStep: 14, loss: 0.01405819184500635, param: [0.36843856]\nStep: 16, loss: 0.0118282405357572, param: [0.37449757]\nStep: 18, loss: 0.0104714494134906, param: [0.37924151]\n\n\nLooks good - the optimizer converges to the correct value of \\(\\ell_0\\).\n\n\n\nNext steps\nSuccess: we can solve this (stupid) toy problem. Our JAX-compatible infrastructure for vertex models seems to work, and we can autodiff through a simulation. Next steps:\n\nToy simulations with T1s\nMore complex models - say, the area-perimeter vertex model\nPlay around with neural ODEs and neural optimizers more generally.",
    "crumbs": [
      "Simulation test case - optimize mesh to make triangles equilateral"
    ]
  },
  {
    "objectID": "00_trigonometry.html",
    "href": "00_trigonometry.html",
    "title": "triangulax",
    "section": "",
    "text": "For example, the circumcenter of a triangle, which is the position of the dual Voronoi vertex.\n\n\nThroughout, we will (attempt to) provide a type signature for all functions. To do so for array-based functions, we use jaxtyping.\n\n\n\nThe aim is to create a triangulation datastructure compatible with the JAX library for automatic differentiation and numerical computing. In practice, this means that we use jnp (=jax.numpy) instead of numpy, and make sure our code follows JAX’s functional programming paradigm (see JAX- the sharp bits). There is also some extra legwork to register any new classes with JAX.\n\nsource\n\n\n\n\ndef get_perp_2d(\n    x:Float[Array, '... 2']\n)-&gt;Float[Array, '... 2']:\n\nGet perpendicular vector.\n\nsource\n\n\n\n\ndef get_rot_mat(\n    theta:float\n)-&gt;Float[Array, '2 2']:\n\nGet 2D rotation matrix from angle in radians.\n\nsource\n\n\n\n\ndef get_cot_between_vectors(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim']\n)-&gt;Float[Array, '']:\n\nCotangent of angle between two vectors\n\nsource\n\n\n\n\ndef get_angle_between_vectors(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim']\n)-&gt;Float[Array, '']:\n\nAngle between two vectors\n\nsource\n\n\n\n\ndef get_voronoi_corner_perimeter(\n    a:Float[Array, '2'], b:Float[Array, '2'], c:Float[Array, '2'], zero_clip:float=1e-10\n)-&gt;Float[Array, '']:\n\nCompute contribution to Voronoi perimeter at corner a of triangle abc. Can be negative! 2d only atm.\n\nsource\n\n\n\n\ndef get_voronoi_corner_area(\n    a:Float[Array, '2'], b:Float[Array, '2'], c:Float[Array, '2'], zero_clip:float=1e-10\n)-&gt;Float[Array, '']:\n\nCompute Voronoi area at corner a of triangle abc. Returns zero for a degenerate triangle. 2d only atm.\nTO DO: does this yield correct results for self-intersecting corner slices (circumcenter outside of triangle)?\n\nsource\n\n\n\n\ndef get_polygon_area(\n    pts:Float[Array, 'n_vertices 2']\n)-&gt;Float[Array, '']:\n\nArea of 2D polygon assuming no self-intersection.\n\nsource\n\n\n\n\ndef get_triangle_area(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim'], c:Float[Array, 'dim']\n)-&gt;Float[Array, '']:\n\nArea of triangle with vertices a, b, c. Works in any dimension &gt;=2.\n\nsource\n\n\n\n\ndef get_circumcenter(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim'], c:Float[Array, 'dim'], zero_clip:float=1e-10\n)-&gt;Float[Array, 'dim']:\n\nReturn circumcenter coordinates of triangle with vertices a, b, c\n\na = jnp.array([1., 0])\nb = jnp.array([1., 0.5])\nangle = get_angle_between_vectors(a, b)\n1/jnp.tan(angle), get_cot_between_vectors(a, b)\n\n(Array(2., dtype=float64), Array(2., dtype=float64))\n\n\n\nget_polygon_area(jnp.array([[0.,0.], [0.,1.], [1.,0.]]) ), get_triangle_area(*jnp.array([[0.,0.], [0.,1.], [1.,0.]]) )\n\n(Array(0.5, dtype=float64), Array(0.5, dtype=float64))\n\n\n\nget_circumcenter(jnp.array([0.,0.]), jnp.array([0.,1.]),  jnp.array([1.,0.]))\n\nArray([0.5, 0.5], dtype=float64)\n\n\n\nget_circumcenter(jnp.array([1.,0.]), jnp.array([1.,0.]),  jnp.array([0.,1.]))\n\nArray([0., 0.], dtype=float64)\n\n\n\nget_circumcenter(jnp.array([1.,0.]), jnp.array([2.,0.]),  jnp.array([1.,0.]))\n\nArray([0., 0.], dtype=float64)\n\n\n\nget_voronoi_corner_area(jnp.array([0.,0.]), jnp.array([0.,1.]),  jnp.array([1.,0.]))\n\nArray(0.25, dtype=float64)\n\n\n\nget_voronoi_corner_perimeter(jnp.array([0., 0.]), jnp.array([1., 0.]), jnp.array([0., 1.]))\n\nArray(1., dtype=float64)\n\n\n\njnp.cross(jnp.array([1,0]), jnp.array([0, 1]) )\n\nArray(1, dtype=int64)\n\n\n\njnp.cross(jnp.array([1,0,0]), jnp.array([0, 1, 0]) )\n\nArray([0, 0, 1], dtype=int64)\n\n\n\n\n\n\nsource\n\n\n\n\ndef get_triangle_normal(\n    a:Float[Array, '3'], b:Float[Array, '3'], c:Float[Array, '3']\n)-&gt;Float[Array, '3']:\n\nCompute unit normal vector of triangle abc.\n\nsource\n\n\n\n\ndef quaternion_to_rot_max(\n    q:Float[Array, '4']\n)-&gt;Float[Array, '3 3']:\n\nConvert unit quaternion into a 3d rotation matrix.\nSee https://fr.wikipedia.org/wiki/Quaternions_et_rotation_dans_l%27espace\n\n\n\n\nsource\n\n\n\n\ndef get_barycentric_coordinates(\n    point:Float[Array, 'dim'], a:Float[Array, 'dim'], b:Float[Array, 'dim'], c:Float[Array, 'dim'],\n    zero_clip:float=1e-10, normalize:bool=True\n)-&gt;Float[Array, '3']:\n\nCompute barycentric coordinates of point with respect to triangle abc.\n\nvertices = jnp.array([[0., 0 ], [0., 1.], [1., 0.]])\npoint1 = jnp.array([0.5, 0.2])\n\nget_barycentric_coordinates(point1, *vertices, normalize=False)\n\nArray([0. , 0.2, 0.5], dtype=float64)\n\n\n\nvertices2 = jnp.array([[0., 0, 0], [0., 1., 0], [1., 0., 0]])\npoint2 = jnp.array([0.5, 0.2, 0.])\n\nget_barycentric_coordinates(point2, *vertices2, normalize=False)\n\nArray([0. , 0.2, 0.5], dtype=float64)\n\n\n\npoint3 = jnp.array([0.5, 0.2, 1.])\n\nget_barycentric_coordinates(point3, *vertices2, normalize=False)\n\nArray([0. , 0.2, 0.5], dtype=float64)",
    "crumbs": [
      "Basic trigonometry"
    ]
  },
  {
    "objectID": "00_trigonometry.html#basic-trigonometry",
    "href": "00_trigonometry.html#basic-trigonometry",
    "title": "triangulax",
    "section": "",
    "text": "For example, the circumcenter of a triangle, which is the position of the dual Voronoi vertex.\n\n\nThroughout, we will (attempt to) provide a type signature for all functions. To do so for array-based functions, we use jaxtyping.\n\n\n\nThe aim is to create a triangulation datastructure compatible with the JAX library for automatic differentiation and numerical computing. In practice, this means that we use jnp (=jax.numpy) instead of numpy, and make sure our code follows JAX’s functional programming paradigm (see JAX- the sharp bits). There is also some extra legwork to register any new classes with JAX.\n\nsource\n\n\n\n\ndef get_perp_2d(\n    x:Float[Array, '... 2']\n)-&gt;Float[Array, '... 2']:\n\nGet perpendicular vector.\n\nsource\n\n\n\n\ndef get_rot_mat(\n    theta:float\n)-&gt;Float[Array, '2 2']:\n\nGet 2D rotation matrix from angle in radians.\n\nsource\n\n\n\n\ndef get_cot_between_vectors(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim']\n)-&gt;Float[Array, '']:\n\nCotangent of angle between two vectors\n\nsource\n\n\n\n\ndef get_angle_between_vectors(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim']\n)-&gt;Float[Array, '']:\n\nAngle between two vectors\n\nsource\n\n\n\n\ndef get_voronoi_corner_perimeter(\n    a:Float[Array, '2'], b:Float[Array, '2'], c:Float[Array, '2'], zero_clip:float=1e-10\n)-&gt;Float[Array, '']:\n\nCompute contribution to Voronoi perimeter at corner a of triangle abc. Can be negative! 2d only atm.\n\nsource\n\n\n\n\ndef get_voronoi_corner_area(\n    a:Float[Array, '2'], b:Float[Array, '2'], c:Float[Array, '2'], zero_clip:float=1e-10\n)-&gt;Float[Array, '']:\n\nCompute Voronoi area at corner a of triangle abc. Returns zero for a degenerate triangle. 2d only atm.\nTO DO: does this yield correct results for self-intersecting corner slices (circumcenter outside of triangle)?\n\nsource\n\n\n\n\ndef get_polygon_area(\n    pts:Float[Array, 'n_vertices 2']\n)-&gt;Float[Array, '']:\n\nArea of 2D polygon assuming no self-intersection.\n\nsource\n\n\n\n\ndef get_triangle_area(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim'], c:Float[Array, 'dim']\n)-&gt;Float[Array, '']:\n\nArea of triangle with vertices a, b, c. Works in any dimension &gt;=2.\n\nsource\n\n\n\n\ndef get_circumcenter(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim'], c:Float[Array, 'dim'], zero_clip:float=1e-10\n)-&gt;Float[Array, 'dim']:\n\nReturn circumcenter coordinates of triangle with vertices a, b, c\n\na = jnp.array([1., 0])\nb = jnp.array([1., 0.5])\nangle = get_angle_between_vectors(a, b)\n1/jnp.tan(angle), get_cot_between_vectors(a, b)\n\n(Array(2., dtype=float64), Array(2., dtype=float64))\n\n\n\nget_polygon_area(jnp.array([[0.,0.], [0.,1.], [1.,0.]]) ), get_triangle_area(*jnp.array([[0.,0.], [0.,1.], [1.,0.]]) )\n\n(Array(0.5, dtype=float64), Array(0.5, dtype=float64))\n\n\n\nget_circumcenter(jnp.array([0.,0.]), jnp.array([0.,1.]),  jnp.array([1.,0.]))\n\nArray([0.5, 0.5], dtype=float64)\n\n\n\nget_circumcenter(jnp.array([1.,0.]), jnp.array([1.,0.]),  jnp.array([0.,1.]))\n\nArray([0., 0.], dtype=float64)\n\n\n\nget_circumcenter(jnp.array([1.,0.]), jnp.array([2.,0.]),  jnp.array([1.,0.]))\n\nArray([0., 0.], dtype=float64)\n\n\n\nget_voronoi_corner_area(jnp.array([0.,0.]), jnp.array([0.,1.]),  jnp.array([1.,0.]))\n\nArray(0.25, dtype=float64)\n\n\n\nget_voronoi_corner_perimeter(jnp.array([0., 0.]), jnp.array([1., 0.]), jnp.array([0., 1.]))\n\nArray(1., dtype=float64)\n\n\n\njnp.cross(jnp.array([1,0]), jnp.array([0, 1]) )\n\nArray(1, dtype=int64)\n\n\n\njnp.cross(jnp.array([1,0,0]), jnp.array([0, 1, 0]) )\n\nArray([0, 0, 1], dtype=int64)\n\n\n\n\n\n\nsource\n\n\n\n\ndef get_triangle_normal(\n    a:Float[Array, '3'], b:Float[Array, '3'], c:Float[Array, '3']\n)-&gt;Float[Array, '3']:\n\nCompute unit normal vector of triangle abc.\n\nsource\n\n\n\n\ndef quaternion_to_rot_max(\n    q:Float[Array, '4']\n)-&gt;Float[Array, '3 3']:\n\nConvert unit quaternion into a 3d rotation matrix.\nSee https://fr.wikipedia.org/wiki/Quaternions_et_rotation_dans_l%27espace\n\n\n\n\nsource\n\n\n\n\ndef get_barycentric_coordinates(\n    point:Float[Array, 'dim'], a:Float[Array, 'dim'], b:Float[Array, 'dim'], c:Float[Array, 'dim'],\n    zero_clip:float=1e-10, normalize:bool=True\n)-&gt;Float[Array, '3']:\n\nCompute barycentric coordinates of point with respect to triangle abc.\n\nvertices = jnp.array([[0., 0 ], [0., 1.], [1., 0.]])\npoint1 = jnp.array([0.5, 0.2])\n\nget_barycentric_coordinates(point1, *vertices, normalize=False)\n\nArray([0. , 0.2, 0.5], dtype=float64)\n\n\n\nvertices2 = jnp.array([[0., 0, 0], [0., 1., 0], [1., 0., 0]])\npoint2 = jnp.array([0.5, 0.2, 0.])\n\nget_barycentric_coordinates(point2, *vertices2, normalize=False)\n\nArray([0. , 0.2, 0.5], dtype=float64)\n\n\n\npoint3 = jnp.array([0.5, 0.2, 1.])\n\nget_barycentric_coordinates(point3, *vertices2, normalize=False)\n\nArray([0. , 0.2, 0.5], dtype=float64)",
    "crumbs": [
      "Basic trigonometry"
    ]
  }
]