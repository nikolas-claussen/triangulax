[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "triangulax",
    "section": "",
    "text": "This package provides data-structures for triangular meshes and functions for geometry processing based on JAX and fully compatible with JAX’s just-in-time compilation and automatic differentiation.\nThe current use case is to create a simulation framework for the mechanics of 2D tissues (Active tension networks, area-perimeter vertex model, non-confluent tissues like in Kim, 2021) compatible with automatic differentiation/JAX. The ultimate goal is to use gradient-based optimization to identify models for tissue dynamics that produce certain behaviors of interest.",
    "crumbs": [
      "triangulax"
    ]
  },
  {
    "objectID": "index.html#developer-guide",
    "href": "index.html#developer-guide",
    "title": "triangulax",
    "section": "Developer Guide",
    "text": "Developer Guide\nThis package is developed based on jupyter notebooks, which are converted into python modules using nbdev.\n\nInstall triangulax in Development mode\n\nClone the github repository\n\n$ git clone https://github.com/nikolas-claussen/triangulax.git\n\nCreate a conda environment with all Python dependencies\n\n$ conda env create -n triangulax -f triangulax.yml\n$ conda activate triangulax\n\nInstall the triangulax package\n\n# make sure triangulax package is installed in development mode\n$ pip install -e .\n\nIf necessary, edit the package notebooks and export\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to triangulax\n$ nbdev_prepare",
    "crumbs": [
      "triangulax"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "triangulax",
    "section": "Usage",
    "text": "Usage\n\nDocumentation\nDocumentation can be found hosted on this GitHub repository’s pages.",
    "crumbs": [
      "triangulax"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "triangulax",
    "section": "How to use",
    "text": "How to use\nCurrently, only the mesh module is complete. It contains a half-edge data structure for triangular meshes compatible with JAX.\n\nimport igl\nimport jax.numpy as jnp\nfrom triangulax import mesh as msh\n\n\n# load example mesh and convert to half-edge mesh\nvertices, _, _, faces, _, _ = igl.readOBJ(\"test_meshes/disk.obj\")\nhemesh = msh.HeMesh.from_triangles(vertices.shape[0], faces)\n\n# with the half-edge mesh, you can carry out various operations, like computing the coordination number by summing incoming half-edges per vertex\n\ncoord_number = jnp.zeros(hemesh.n_vertices)\ncoord_number.at[hemesh.dest].add(jnp.ones(hemesh.n_hes))\n\n2",
    "crumbs": [
      "triangulax"
    ]
  },
  {
    "objectID": "03_area_perimeter_model.html",
    "href": "03_area_perimeter_model.html",
    "title": "Area-perimeter self-propelled Voronoi model",
    "section": "",
    "text": "After the toy example of notebook 02, let’s try to implement a slightly more complicated model, the self-propelled Voronoi area-perimeter Voronoi (VAP) model of Bi et al., 2016. This 2D model comprises most of the ingredients we will see in more general simulations, from a coding perspective.\nIn brief, in the VAP, cells are modeled as the Voronoi tesselation for a series of centroids \\(\\mathbf{v}_i\\) (our triangulation vertices). Their overdamped dynamics comprises two terms: self-propulsion and relaxation of an elastic energy: \\[\\partial_t \\mathbf{v}_i = -\\nabla_{\\mathbf{v}_i} E_{AP} + v_0 \\hat{\\mathbf{n}}_i\\] For each cell \\(i\\), \\(\\hat{\\mathbf{n}}_i\\) is a unit vector (so we will represent it by an angle \\(\\theta_i\\)) that determines the direction of motion. Units of time are chosen so that the coefficient of \\(\\nabla E_{AP}\\) is \\(1\\). The energy is defined in terms of the Voronoi area \\(a_i\\) and Voronoi perimeter \\(p_i\\) of each cell: \\[E_{AP} = \\sum_i k_a(a_i-a_0)^2 + k_p(p_i-p_0)^2 \\] where \\(k_a, k_p\\) are elastic constants, and \\(a_0, p_0\\) are the target area and perimeter. They define the “shape index” \\(s_0= p_0/\\sqrt{a_0}\\). The key physics is that above a critical shape index \\(s_0^*\\), the model has a degenerate set of ground states, since for a large \\(p_0\\), there are many polygons with the given target area and perimeter (think floppy balloon).\nThe orientation \\(\\theta_i\\) of each cell is also dynamic. It undergoes rotational diffusion: \\[d\\theta_i = D_\\theta dW_{t, i} \\] where \\(dW_{t,i}\\) is Brownian motion, independent for each cell \\(i\\), and \\(D_\\theta\\) is the diffusion constant.",
    "crumbs": [
      "Area-perimeter self-propelled Voronoi model"
    ]
  },
  {
    "objectID": "03_area_perimeter_model.html#voronoi-cell-geometry-area-perimeter",
    "href": "03_area_perimeter_model.html#voronoi-cell-geometry-area-perimeter",
    "title": "Area-perimeter self-propelled Voronoi model",
    "section": "Voronoi cell geometry (area & perimeter)",
    "text": "Voronoi cell geometry (area & perimeter)\nWe compute areas from corner contributions and perimeters from dual-edge lengths, using gather/scatter operations on the half-edge mesh. Boundary cells are handled by mirroring (doubling the area/perimeter).\n\n@jax.jit\ndef compute_cell_geometry(geommesh: GeomMesh, hemesh: HeMesh\n                          ) -&gt; Tuple[Float[jax.Array, \" n_vertices\"],\n                                     Float[jax.Array, \" n_vertices\"]]:\n    \"\"\"Compute Voronoi areas and perimeters for each cell.\"\"\"\n\n    a = hemesh.dest[hemesh.nxt]\n    b = hemesh.dest[hemesh.prv]\n    c = hemesh.dest\n    corner_areas = jax.vmap(trig.get_voronoi_corner_area)(\n        geommesh.vertices[a], geommesh.vertices[b], geommesh.vertices[c])\n    cell_areas = msh.sum_he_to_vertex_opposite(hemesh, corner_areas)\n    cell_areas = jnp.where(hemesh.is_bdry, 2.0 * cell_areas, cell_areas)\n\n    #face_positions = msh.get_voronoi_face_positions(geommesh.vertices, hemesh)\n    #dual_lengths = msh.get_signed_dual_he_length(face_positions, hemesh)\n    #dual_lengths = jnp.nan_to_num(dual_lengths, nan=0.0)\n    #cell_perimeters = msh.sum_he_to_vertex_incoming(hemesh, dual_lengths)\n    \n    corner_perims = jax.vmap(trig.get_voronoi_corner_perimeter)(\n        geommesh.vertices[a], geommesh.vertices[b], geommesh.vertices[c])\n    corner_perims = jnp.clip(corner_perims, 0)\n    cell_perims = msh.sum_he_to_vertex_opposite(hemesh, corner_perims)\n    cell_perims = jnp.where(hemesh.is_bdry, 2.0 * cell_perims, cell_perims)\n\n    return cell_areas, cell_perims\n\n@jax.jit\ndef energy_ap(geommesh: GeomMesh, hemesh: HeMesh, a0: float, p0: float,\n              k_a: float = 1.0, k_p: float = 1.0) -&gt; Float[jax.Array, \"\"]:\n    \"\"\"Area-perimeter energy for Voronoi cells.\"\"\"\n    cell_areas, cell_perimeters = compute_cell_geometry(geommesh, hemesh)\n    return jnp.mean(k_a * (cell_areas - a0) ** 2 + k_p * (cell_perimeters - p0) ** 2)\n\n\ncell_areas, cell_perimeters = compute_cell_geometry(geommesh, hemesh)\n\na_mean, p_mean = (cell_areas[~hemesh.is_bdry].mean(), cell_perimeters[~hemesh.is_bdry].mean())\na_mean, p_mean, p_mean/np.sqrt(a_mean)\n\n(Array(0.02756258, dtype=float64),\n Array(0.63463959, dtype=float64),\n Array(3.82267399, dtype=float64))\n\n\n\n# double check against \"manual\" area and \"perimeter\" computation using mesh traversal",
    "crumbs": [
      "Area-perimeter self-propelled Voronoi model"
    ]
  },
  {
    "objectID": "03_area_perimeter_model.html#energy-relaxation-no-self-propulsion",
    "href": "03_area_perimeter_model.html#energy-relaxation-no-self-propulsion",
    "title": "Area-perimeter self-propelled Voronoi model",
    "section": "Energy relaxation (no self-propulsion)",
    "text": "Energy relaxation (no self-propulsion)\nWe first relax the area–perimeter energy to verify that the constraints are satisfied.\n\n@jax.jit\ndef relax_energy_step(geommesh: GeomMesh, hemesh: HeMesh,\n              a0: float, p0: float,\n              step_size: float = 0.01,\n              k_a: float = 1.0, k_p: float = 1.0) -&gt; Tuple[GeomMesh, Float[jax.Array, \"\"]]:\n    loss, grad = jax.value_and_grad(energy_ap)(geommesh, hemesh, a0, p0, k_a, k_p)\n    updated_vertices = geommesh.vertices - step_size * grad.vertices\n    geommesh_updated = dataclasses.replace(geommesh, vertices=updated_vertices)\n    return geommesh_updated, loss\n\n\n# energy parameters\na0 = a_mean\ns0 = 3.5\np0 = s0*jnp.sqrt(a0)\n\n# relaxation parameters\nstep_size = 0.02\nn_steps = 10000\n\ngeommesh_relaxed = copy.copy(geommesh)\nlosses = []\n\nfor _ in range(n_steps):\n    geommesh_relaxed, loss = relax_energy_step(geommesh_relaxed, hemesh, a0, p0, step_size=step_size)\n    losses.append(loss)\n\nlosses = jnp.array(losses)\n\n\nfig = plt.figure(figsize=(4, 3))\nplt.plot(np.asarray(losses))\nplt.xlabel(\"step\")\nplt.ylabel(\"energy\");\n\n\n\n\n\n\n\n\n\ngeommesh_relaxed = msh.set_voronoi_face_positions(geommesh_relaxed, hemesh)\n\nfig, ax = plt.subplots(figsize=(4, 4))\nax.add_collection(msh.cellplot(hemesh, geommesh.face_positions,\n                               cell_colors=np.array([0.7, 0.7, 0.9, 0.2]),\n                               mpl_polygon_kwargs={\"lw\": 0.5, \"ec\": \"tab:blue\"}))\nax.add_collection(msh.cellplot(hemesh, geommesh_relaxed.face_positions,\n                               cell_colors=np.array([0.9, 0.6, 0.6, 0.2]),\n                               mpl_polygon_kwargs={\"lw\": 0.5, \"ec\": \"tab:red\"}))\nax.set_aspect(\"equal\")\nax.autoscale_view();\n\n\n\n\n\n\n\n\n\nareas_relaxed, perim_relaxed = compute_cell_geometry(geommesh_relaxed, hemesh)\njnp.abs(areas_relaxed - a0)[hemesh.is_bdry].mean(), jnp.abs(perim_relaxed - p0)[hemesh.is_bdry].mean()\n\n(Array(0.06599055, dtype=float64), Array(0.00919191, dtype=float64))\n\n\n\nRelaxation with T1s\nNext, let’s allow T1s. To ensure we don’t flip the same edge multiple times, let’s use a cooldown period.\n\ncooldown_steps = 5\nl_min_T1 = 0.0\n\nn_steps = 10000\ncooldown_counter = jnp.zeros(hemesh.n_hes)\nsim_steps = jnp.arange(n_steps)",
    "crumbs": [
      "Area-perimeter self-propelled Voronoi model"
    ]
  },
  {
    "objectID": "03_area_perimeter_model.html#overdamped-dynamics-with-self-propulsion-deterministic",
    "href": "03_area_perimeter_model.html#overdamped-dynamics-with-self-propulsion-deterministic",
    "title": "Area-perimeter self-propelled Voronoi model",
    "section": "Overdamped dynamics with self-propulsion (deterministic)",
    "text": "Overdamped dynamics with self-propulsion (deterministic)\nWe integrate \\(\\partial_t \\mathbf{v}_i = -\\nabla_{\\mathbf{v}_i} E_{AP} + v_0\\hat{\\mathbf{n}}_i\\) with fixed orientations.\n\n@jax.tree_util.register_dataclass\n@dataclasses.dataclass\nclass VAPState:\n    \"\"\"State for VAP dynamics.\"\"\"\n    geommesh: GeomMesh\n    theta: Float[jax.Array, \" n_vertices\"]\n\n\n@jax.jit\ndef vap_vector_field(t: float, state: VAPState, args: Tuple) -&gt; VAPState:\n    hemesh, a0, p0, v0, k_a, k_p = args\n    grad_geom = jax.grad(energy_ap)(state.geommesh, hemesh, a0, p0, k_a, k_p)\n    n_hat = jnp.stack([jnp.cos(state.theta), jnp.sin(state.theta)], axis=-1)\n    velocity = -grad_geom.vertices + v0 * n_hat\n    dgeom = dataclasses.replace(\n        state.geommesh,\n        vertices=velocity,\n        face_positions=jnp.zeros_like(state.geommesh.face_positions),\n    )\n    dtheta = jnp.zeros_like(state.theta)\n    return VAPState(geommesh=dgeom, theta=dtheta)\n\n\nkey = jax.random.key(0)\ntheta0 = jax.random.uniform(key, shape=(hemesh.n_vertices,), minval=0.0, maxval=2 * np.pi)\n\nstate0 = VAPState(geommesh=geommesh_relaxed, theta=theta0)\nargs = (hemesh, a0, p0, 0.02, 1.0, 1.0)\n\nterm = diffrax.ODETerm(vap_vector_field)\nsolver = diffrax.Tsit5()\n\ndt = 0.05\nt0 = 0.0\nt1 = 1.0\nstep_times = jnp.arange(t0, t1 + dt, dt)\n\nstate = state0\nsolver_state = solver.init(term, t0, t0 + dt, state0, args)\n\ndef scan_fun(carry, t):\n    solver_state, state, tprev = carry\n    state, _, _, solver_state, _ = solver.step(term, tprev, t, state, args, solver_state, made_jump=False)\n    return (solver_state, state, t), state\n\ninit = (solver_state, state0, t0)\n(_, state_final, _), traj = jax.lax.scan(scan_fun, init, step_times[1:])\n\nstate_final\n\nVAPState(geommesh=GeomMesh(D=2,N_V=131, N_HE=708, N_F=224), theta=Array([2.62924358, 1.35902442, 6.06529362, 3.60969331, 3.34407765,\n       2.22993501, 5.54810903, 3.97449415, 3.3539648 , 1.20419685,\n       5.36695019, 0.37346808, 4.04254935, 6.24593336, 3.78256938,\n       2.43986234, 1.86427401, 4.04350545, 2.65350913, 5.86673077,\n       3.28952069, 3.49530224, 3.61134731, 3.25868309, 0.49483695,\n       2.65597033, 5.44847081, 0.0815077 , 1.80236259, 3.88571405,\n       0.78212587, 3.1742906 , 5.65305943, 0.03552294, 1.03057226,\n       0.49984771, 0.75858611, 5.28357365, 2.11062344, 4.08461608,\n       1.90394486, 3.08182229, 4.11747439, 0.32242419, 2.87977266,\n       1.64838549, 3.99764578, 3.02082432, 3.96065204, 0.80522438,\n       0.14948794, 4.84820085, 1.01252678, 3.03934314, 6.23419932,\n       1.30784405, 0.92344992, 0.65224909, 1.43848565, 1.87620624,\n       3.94727408, 3.32947945, 6.09053058, 4.85059338, 0.60390009,\n       3.62798414, 5.91464415, 6.20134698, 0.90452161, 5.37227617,\n       4.70125311, 0.24225895, 3.14981522, 5.74799062, 3.75328237,\n       1.98555718, 3.83604906, 6.08376748, 1.12812114, 3.94329588,\n       5.96146155, 3.15743965, 5.36572252, 1.38305247, 4.21158314,\n       0.62448226, 6.25140285, 0.33132314, 3.30349371, 3.39250697,\n       1.7903447 , 4.70071342, 1.13107472, 4.34020999, 4.681111  ,\n       4.28852299, 2.95713743, 4.17502547, 1.74408207, 0.86079415,\n       0.03538471, 5.83681193, 3.85763446, 4.26437849, 3.3072995 ,\n       1.56063907, 3.22774219, 4.08125906, 0.64092348, 2.81884839,\n       4.07437153, 2.24100076, 2.23559404, 0.50889602, 4.35402081,\n       2.82450091, 4.864591  , 4.59168174, 4.33505167, 0.25874837,\n       0.19473722, 3.43090963, 0.91323554, 3.28793035, 1.75618521,\n       1.60907037, 2.34992684, 0.07139381, 5.80785391, 0.42435074,\n       4.72387567], dtype=float64))\n\n\n\ngeommesh_final = msh.set_voronoi_face_positions(state_final.geommesh, hemesh)\n\nfig, ax = plt.subplots(figsize=(4, 4))\nax.add_collection(msh.cellplot(hemesh, geommesh_relaxed.face_positions,\n                               cell_colors=np.array([0.7, 0.7, 0.9, 0.2]),\n                               mpl_polygon_kwargs={\"lw\": 0.5, \"ec\": \"tab:blue\"}))\nax.add_collection(msh.cellplot(hemesh, geommesh_final.face_positions,\n                               cell_colors=np.array([0.9, 0.6, 0.6, 0.2]),\n                               mpl_polygon_kwargs={\"lw\": 0.5, \"ec\": \"tab:red\"}))\nax.set_aspect(\"equal\")\nax.autoscale_view();\n\n\n\n\n\n\n\n\n\nStochastic orientation + T1 flips (step-by-step)\nWe now include rotational diffusion for \\(\\theta_i\\) and perform edge flips when Voronoi dual edges fall below a threshold. A short cooldown avoids immediate re-flips.\n\n@jax.jit\ndef compute_velocity(geommesh: GeomMesh, hemesh: HeMesh, theta: Float[jax.Array, \" n_vertices\"],\n                     a0: float, p0: float, v0: float, k_a: float = 1.0, k_p: float = 1.0\n                     ) -&gt; Float[jax.Array, \"n_vertices 2\"]:\n    \"\"\"Overdamped velocity with self-propulsion.\"\"\"\n    grad_geom = jax.grad(energy_ap)(geommesh, hemesh, a0, p0, k_a, k_p)\n    n_hat = jnp.stack([jnp.cos(theta), jnp.sin(theta)], axis=-1)\n    return -grad_geom.vertices + v0 * n_hat\n\n\ndef step_with_diffrax(state: VAPState, solver_state: diffrax.AbstractSolverState,\n                      tprev: float, tnext: float, args: Tuple, key: jax.Array,\n                      d_theta: float) -&gt; Tuple[VAPState, diffrax.AbstractSolverState, jax.Array]:\n    \"\"\"One ODE step with diffrax + Euler-Maruyama update for angles.\"\"\"\n    term = diffrax.ODETerm(vap_vector_field)\n    solver = diffrax.Tsit5()\n    state, _, _, solver_state, _ = solver.step(term, tprev, tnext, state, args, solver_state, made_jump=False)\n    key, subkey = jax.random.split(key)\n    dt = tnext - tprev\n    noise = jax.random.normal(subkey, shape=state.theta.shape)\n    theta = state.theta + jnp.sqrt(2.0 * d_theta * dt) * noise\n    state = VAPState(geommesh=state.geommesh, theta=theta)\n    return state, solver_state, key\n\n\ndef apply_t1_flips(geommesh: GeomMesh, hemesh: HeMesh, cooldown: jax.Array,\n                   l_min: float, cooldown_steps: int\n                   ) -&gt; Tuple[GeomMesh, HeMesh, jax.Array, Bool[jax.Array, \"n_hes\"]]:\n    \"\"\"Flip short edges with a cooldown to avoid immediate re-flips.\"\"\"\n    geommesh = msh.set_voronoi_face_positions(geommesh, hemesh)\n    dual_lengths = jnp.abs(msh.get_signed_dual_he_length(geommesh, hemesh))\n    dual_lengths = jnp.nan_to_num(dual_lengths, nan=jnp.inf)\n    eligible = (dual_lengths &lt; l_min) & hemesh.is_unique & (~hemesh.is_bdry_edge)\n    eligible = eligible & (cooldown == 0)\n    hemesh_new = msh.flip_all(hemesh, eligible)\n    cooldown = jnp.maximum(cooldown - 1, 0)\n    flipped = eligible | eligible[hemesh.twin]\n    cooldown = cooldown.at[flipped].set(cooldown_steps)\n    geommesh_new = msh.set_voronoi_face_positions(geommesh, hemesh_new)\n    return geommesh_new, hemesh_new, cooldown, flipped\n\n\n# simulation parameters\ndt = 0.02\nn_steps = 200\nsave_every = 5\n\nv0 = 0.03\nd_theta = 0.1\n\nl_min = 0.02\ncooldown_steps = 5\n\ngeommesh_sim = copy.copy(geommesh_relaxed)\nhemesh_sim = copy.copy(hemesh)\ntheta = jax.random.uniform(jax.random.key(1), shape=(hemesh_sim.n_vertices,), minval=0.0, maxval=2 * np.pi)\nstate = VAPState(geommesh=geommesh_sim, theta=theta)\ncooldown = jnp.zeros(hemesh_sim.n_hes, dtype=int)\nkey = jax.random.key(2)\n\nterm = diffrax.ODETerm(vap_vector_field)\nsolver = diffrax.Tsit5()\n\ntraj = []\ntprev = 0.0\nfor step in range(n_steps):\n    tnext = tprev + dt\n    args = (hemesh_sim, a0, p0, v0, 1.0, 1.0)\n    solver_state = solver.init(term, tprev, tnext, state, args)\n    state, solver_state, key = step_with_diffrax(state, solver_state, tprev, tnext, args, key, d_theta)\n    geommesh_sim, hemesh_sim, cooldown, flipped = apply_t1_flips(\n        state.geommesh, hemesh_sim, cooldown, l_min, cooldown_steps\n    )\n    state = VAPState(geommesh=geommesh_sim, theta=state.theta)\n    if (step % save_every) == 0:\n        traj.append((dataclasses.replace(geommesh_sim), copy.copy(hemesh_sim)))\n    tprev = tnext\n\nlen(traj)\n\n40\n\n\n\ndef plot_state(idx: int) -&gt; None:\n    geom, hem = traj[idx]\n    fig, ax = plt.subplots(figsize=(4, 4))\n    ax.add_collection(msh.cellplot(hem, geom.face_positions,\n                                   cell_colors=np.array([0.7, 0.7, 0.9, 0.4]),\n                                   mpl_polygon_kwargs={\"lw\": 0.5, \"ec\": \"k\"}))\n    ax.set_aspect(\"equal\")\n    ax.autoscale_view()\n    ax.set_title(f\"frame {idx}\")\n\n\nplot_state(0)\n\n\ntry:\n    import ipywidgets as widgets\n    from IPython.display import display\n\n    slider = widgets.IntSlider(value=0, min=0, max=len(traj) - 1, step=1, description=\"frame\")\n    widgets.interact(plot_state, idx=slider)\nexcept Exception as exc:\n    print(f\"ipywidgets unavailable ({exc}). Showing last frame instead.\")\n    plot_state(len(traj) - 1)",
    "crumbs": [
      "Area-perimeter self-propelled Voronoi model"
    ]
  },
  {
    "objectID": "02_test_simulations.html",
    "href": "02_test_simulations.html",
    "title": "Simulation test case - optimize mesh to make triangles equilateral",
    "section": "",
    "text": "Let’s start with a simple test case to see whether the technology developed so far actually works. The goal is to move the vertices \\(\\mathbf{v}_i\\) of triangulation so all triangle edge lengths are as close to some \\(\\ell_0\\) as possible. We specify a pseudo-energy \\(E=\\sum_{ij} (|\\mathbf{v}_i-\\mathbf{v}_j| - \\ell_0)^2\\), and then minimize it using the JAX-provided gradients w.r.t the vertex positions.\nThis defines the “forward pass” of our “dynamical” model. In a second step, we can optimize over the model parameters, like \\(\\ell_0\\), to make the dynamics return some desired shape, for examlpe.\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport copy\n\nfrom tqdm.notebook import tqdm\n\n\nimport jax\nimport jax.numpy as jnp\n\n\njax.config.update(\"jax_enable_x64\", True)\njax.config.update(\"jax_debug_nans\", False)\njax.config.update('jax_log_compiles', False)\n\n\nfrom typing import Tuple\n\nimport dataclasses\n\nimport functools\n\n\n# import previously defined modules\nfrom triangulax import mesh as msh\nfrom triangulax.mesh import TriMesh, HeMesh, GeomMesh\n\n\nJAX-compatible scientific computing libraries - useful in future steps\nimport diffrax # ODE solvers\nimport lineax # linear solvers\nimport optimistix # optimisation (scientific-computing style, e.g. conjugate gradient)\nimport optax # optimisation (ML-style, e.g. ADAM)\n\n\nForward pass - minimize energy\n\nimport equinox as eqx\n\n# equinox has automated \"filtering\" of JAX-transforms. So we can work with objects which are not just pytrees of arrays\n# (like neural networks) and appy jit, vmap etc\n\n\n# load example mesh\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = GeomMesh(*hemesh.n_items, vertices=mesh.vertices)\n\nhemesh\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\nHeMesh(N_V=131, N_HE=708, N_F=224)\n\n\n\nfig = plt.figure(figsize=(4, 4))\nplt.triplot(*geommesh.vertices.T, mesh.faces)\nplt.axis(\"equal\");\n\n\n\n\n\n\n\n\n\nlengths = jnp.linalg.norm(geommesh.vertices[hemesh.orig]-geommesh.vertices[hemesh.dest], axis=1)\ntri_areas = -jax.vmap(msh.get_polygon_area)(geommesh.vertices[hemesh.faces])\n\nlengths.mean(), tri_areas.mean()\n\n(Array(0.18296366, dtype=float64), Array(0.01391806, dtype=float64))\n\n\nWe write the energy_function using a geommesh as an argument. This is overkill for present purposes ince only the vertex positions matter, but is useful to test the machinery. For more complicated simulations, we will want to use GeomMesh as a wrapper for the various arrays.\n\n@jax.jit\ndef energy_function(geommesh: GeomMesh, hemesh: HeMesh, ell_0: float=1):\n    edge_lengths = jnp.linalg.norm(geommesh.vertices[hemesh.orig]-geommesh.vertices[hemesh.dest], axis=1)\n    edge_energy = jnp.mean((edge_lengths/ell_0-1)**2) # this way, term is \"auto-normalized\"\n    # let's add a term for the triangle areas\n    a_0 = (np.sqrt(3)/4) * ell_0**2 # area of equilateral triangle\n    tri_area = -jax.vmap(msh.get_polygon_area)(geommesh.vertices[hemesh.faces])\n    area_energy = jnp.mean((tri_area/a_0-1)**2)\n    #jax.debug.print(\"E_l: {E_l}, E_a: {E_a}\",  E_l=edge_energy, E_a=area_energy)\n    # this is how you can print inside a JITed-function\n    return edge_energy + area_energy\n\n\nenergy_function(geommesh, hemesh)\n\nArray(1.60519339, dtype=float64)\n\n\n\n# using functools.partial, we can fill in some of our function's args, like so:\n\nfunctools.partial(energy_function, hemesh=hemesh, ell_0=1)(geommesh)\n\nArray(1.60519339, dtype=float64)\n\n\n\nval, grad = jax.value_and_grad(energy_function)(geommesh, hemesh) # computing value and grad works\n\nval, grad, grad.vertices.shape # the gradient is another GeomMesh with the same structure\n\n(Array(1.60519339, dtype=float64),\n GeomMesh(D=2,N_V=131, N_HE=708, N_F=224),\n (131, 2))\n\n\n\nconnectivity_grad = jax.grad(energy_function, argnums=1, allow_int=True)(geommesh, hemesh)\n# we can even compute the gradient w.r.t to the connectivity matrix. It is also a HeMesh\nconnectivity_grad, connectivity_grad.dest[0] # whatever that means\n\n(HeMesh(N_V=131, N_HE=708, N_F=224), np.void((b'',), dtype=[('float0', 'V')]))\n\n\n\nOptimization run\n\n# parameters of the energy\nell_0 = 0.5\n\n# parameters of the \"optimizer\"\nstep_size = 0.05\nN_steps = 10000\n\n@jax.jit\ndef make_step(geommesh: GeomMesh, hemesh: HeMesh, ell_0: float = 1, step_size: float = 0.01):\n    loss, grad = jax.value_and_grad(energy_function)(geommesh, hemesh, ell_0=ell_0)\n\n    # update - can be streamlined with equinox\n    updated_vertices = geommesh.vertices - step_size*grad.vertices\n    geommesh_updated = dataclasses.replace(geommesh, vertices=updated_vertices)\n    return geommesh_updated, hemesh, loss # explicitly return the hemesh - may need to be updated by flips!\n\n# define inital condition\ngeommesh_optimized = copy.copy(geommesh)\nhemesh_optimized = copy.copy(hemesh)\n\nlosses = []\n\nfor step in range(N_steps):\n    geommesh_optimized, hemesh_optimized, loss = make_step(geommesh_optimized, hemesh_optimized,\n                                                           ell_0=ell_0, step_size=step_size)\n    losses.append(loss)\n\nlosses = np.array(losses)\n\n\nfig = plt.figure(figsize=(4, 3))\nplt.plot(losses)\n\n\n\n\n\n\n\n\n\nfig = plt.figure(figsize=(4, 4))\nplt.triplot(*geommesh.vertices.T, hemesh.faces)\nplt.triplot(*geommesh_optimized.vertices.T, hemesh_optimized.faces)\nplt.axis(\"equal\");\n\n\n\n\n\n\n\n\n\nlengths_optimized = jnp.linalg.norm(geommesh_optimized.vertices[hemesh_optimized.orig]\n                                   -geommesh_optimized.vertices[hemesh_optimized.dest], axis=1)\njnp.abs(lengths_optimized-ell_0).mean(), lengths_optimized.mean()\n\n(Array(0.03342644, dtype=float64), Array(0.50208086, dtype=float64))\n\n\n\n\nUsing an ODE solver - diffrax\nAbove, we implemented “gradient descent” for the pseudo-energy, or, equivalently, a basic forward-Euler scheme for the ODE \\(\\partial_t \\mathbf{v}_i = - \\nabla_{\\mathbf{v}_i} E\\). For more complicated models, and to minimize coding effort, it makes sense to use a pre-made ODE solver instead. The diffrax library implements ODE and SDE solvers in JAX and is compatible with autodiff (you can differentiate through the solver), since it was designed for neural differential equations.\nFor “adiabatic” dynamics, which involve mimizing an energy at every timestep, we can use the “optimistix” library.\nThe below is based on the Stepping through a solver tutorial in diffrax. The reason we want to step through the solver one-by-one is to carry out T1s (in future simulations).\n\nimport diffrax\n\n\n# load example mesh\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = GeomMesh(*hemesh.n_items, vertices=mesh.vertices)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\n# define the RHS for the ODE solver\n@jax.jit\ndef vector_field(t, y, args):\n    return jax.tree_util.tree_map(lambda x: -1*x, jax.grad(energy_function)(y, *args))\nterm = diffrax.ODETerm(vector_field)\n\n# define time parameters and initial condition\ndt = 0.05\nt0 = 0.0\nt1 = 1000.0\nstep_times = jnp.arange(t0, t1, dt)\n\ny0 = geommesh\nargs = (hemesh, 0.5)\n\n\n# go step by step\n\nsolver = diffrax.Tsit5()\ny = y0\nstate = solver.init(term, t0, t0+dt, y0, args)\n\ndef scan_fun(carry, t):\n    state, y, tprev = carry \n    y, _, _, state, _ = solver.step(term, tprev, t, y, args, state, made_jump=False)\n    return (state, y, t), None\n\ninit = (state, y0, t0)\n(state, y, t), _ = jax.lax.scan(scan_fun, init, step_times[1:])\n\n# equivalent to:\n\n#for tprev, tnext in tqdm(zip(step_times[:-1], step_times[1:])):\n#    y, _, _, state, _ = solver.step(term, tprev, tnext, y, args, state, made_jump=False)\n#    tprev = tnext\n#    tnext = min(tprev + dt0, t1)\n\n\nfig = plt.figure(figsize=(4, 4))\nplt.triplot(*y0.vertices.T, hemesh.faces)\nplt.triplot(*y.vertices.T, hemesh.faces)\nplt.axis(\"equal\");\n\n\n\n\n\n\n\n\n\n\n\nMeta-training\nEventually, we aim to learn some dynamical rules for a tissue mechanics model that make the tissue carry out some desired behavior, like making a target shape.\nAs a toy example, let’s take the above “dynamics” which minimizes the pseudo-energy to make all triangles equilateral. It depends on the parameter \\(\\ell_0\\). Relaxation of the pseudo-energy for some number of steps defines our “forward pass”. Let’s try to optimize \\(\\ell_0\\) so that the tissue, at the end of the energy relaxation, has some target size (of course, a contrived problem, since we know the solution from the start).\n\n# package the whole training process into a JITed function\n\n@functools.partial(jax.jit, static_argnames=['N_steps'])\ndef relax_energy(initial_geommesh: GeomMesh, initial_hemesh: HeMesh, ell_0: float = 1,\n                 step_size: float = 0.01, N_steps: int = 1):\n\n    # define initial condition\n    geommesh_optimized = copy.copy(initial_geommesh)\n    hemesh_optimized = copy.copy(initial_hemesh)\n\n    # use a jax.lax.fori_loop loop for training. Much faster JIT-compilation than a Python for loop.\n    loss = 0\n    init = (initial_geommesh, initial_hemesh, loss)\n    def loop_fun(i, carry): return make_step(carry[0], carry[1], ell_0=ell_0, step_size=step_size) \n    geommesh_optimized, hemesh_optimized, loss = jax.lax.fori_loop(0, N_steps, loop_fun, init, unroll=None)\n    \n    return (geommesh_optimized, hemesh_optimized), loss\n\n\n(geommesh_optimized, hemesh_optimized), losses = relax_energy(geommesh, hemesh, ell_0=0.5, step_size=0.05, N_steps=5000)\nlosses\n\nArray(0.04463656, dtype=float64)\n\n\n\nfig = plt.figure(figsize=(4, 4))\nplt.triplot(*geommesh.vertices.T, hemesh.faces)\nplt.triplot(*geommesh_optimized.vertices.T, hemesh_optimized.faces)\nplt.axis(\"equal\");\n\n\n\n\n\n\n\n\n\n\n\nUsageError: Line magic function `%%timeit` not found.\n\n\n\nDefine Meta-training loss\nNow we need to define our meta-training loss. In this case, it’s just the deviation of the average edge length from the total. Note how the meta-loss is distinct from the pseudo-energy we minimize during the forward pass.\nLet’s use the equinox library to handle our problem, in anticipation of more complex ones down the line.\n\nclass RelaxationDynamics(eqx.Module): # we create a model wrapping our relaxational dynamics \n    ell_0: jax.Array\n    step_size : float = eqx.field(static=True)\n    N_steps : int = eqx.field(static=True)\n\n    def __call__(self, initial_geommesh: GeomMesh, initial_hemesh: HeMesh) -&gt; Tuple[GeomMesh, HeMesh]:\n        init = (initial_geommesh, initial_hemesh, 0)\n        def loop_fun(i, carry): return make_step(carry[0], carry[1], ell_0=self.ell_0, step_size=self.step_size)\n        geommesh_optimized, hemesh_optimized, loss = jax.lax.fori_loop(0, N_steps, loop_fun, init, unroll=None)\n        return geommesh_optimized, hemesh_optimized\n\n\n# define the meta-loss\n\ndef meta_loss(model: RelaxationDynamics, initial_geommesh: GeomMesh, initial_hemesh: HeMesh,  meta_ell0: float) -&gt; float:\n    geommesh_optimized, hemesh_optimized = model(initial_geommesh, initial_hemesh)\n    lengths = jnp.linalg.norm(geommesh_optimized.vertices[hemesh_optimized.orig]\n                              -geommesh_optimized.vertices[hemesh_optimized.dest], axis=-1)\n    return jnp.mean((lengths/meta_ell0-1)**2)\n\n\n# initialize the model, and test evaluating it\n\nstep_size = 0.01\nN_steps = 20000\n\ninitial_ell0 = 0.4\n\nmeta_ell0 = 0.3\n\nmodel_initial = RelaxationDynamics(ell_0=jnp.array([initial_ell0]), step_size=step_size, N_steps=N_steps)\nmodel_initial(geommesh, hemesh), meta_loss(model_initial, geommesh, hemesh, meta_ell0=meta_ell0)\n\n((GeomMesh(D=2,N_V=131, N_HE=708, N_F=224),\n  HeMesh(N_V=131, N_HE=708, N_F=224)),\n Array(0.11642016, dtype=float64))\n\n\n\n# let's check that the model still does what we want - looks good!\ngeommesh_trained, hemesh_trained = model_initial(geommesh, hemesh)\n\nfig = plt.figure(figsize=(4, 4))\nplt.triplot(*geommesh.vertices.T, hemesh.faces)\nplt.triplot(*geommesh_trained.vertices.T, hemesh_trained.faces)\nplt.axis(\"equal\");\n\n\n\n\n\n\n\n\n\n\nBatching\nTo evaluate the loss, we want to average over a bunch of initial conditions. These are analogous to batches in a normal ML problem.\n\n## Let us create a bunch of meshes with different initial positions and see if we can batch over them using vmap\n\nkey = jax.random.key(0)\nsigma = 0.02\n\nbatch_geom = []\nbatch_he = []\nfor i in range(3):\n    key, subkey = jax.random.split(key)\n    random_noise = jax.random.normal(subkey, shape=geommesh.vertices.shape)\n    batch_geom.append(dataclasses.replace(geommesh, vertices=geommesh.vertices+sigma*random_noise))\n    batch_he.append(copy.copy(hemesh))\n\n# we use a jax.tree.map to \"push\" the list axis into the underlying arrays.\nbatch_he_array = msh.tree_stack(batch_he)\nbatch_geom_array = msh.tree_stack(batch_geom)\nbatch_geom_array, batch_geom_array.vertices.shape\n\n(GeomMesh(D=2,N_V=131, N_HE=708, N_F=224), (3, 131, 2))\n\n\n\n# The result is a single mesh object with batch axes\n\nbatch_geom_array_out, batch_he_array_out = jax.vmap(model_initial)(batch_geom_array, batch_he_array) \nbatch_geom_array_out, batch_geom_array_out.vertices.shape, batch_he_array_out.orig.shape\n\n(GeomMesh(D=2,N_V=131, N_HE=708, N_F=224), (3, 131, 2), (3, 708))\n\n\n\n# we can unpack things again into a list of meshes\n\nbatch_geom_out = msh.tree_unstack(batch_geom_array_out)\nbatch_he_out = msh.tree_unstack(batch_he_array_out)\n\n\n# still works\n\ni = 2\nfig = plt.figure(figsize=(4, 4))\nplt.triplot(*batch_geom[i].vertices.T, batch_he[i].faces)\nplt.triplot(*batch_geom_out[i].vertices.T, batch_he_out[i].faces)\nplt.axis(\"equal\");\n\n\n\n\n\n\n\n\n\n# the batches are not identical, which is good.\nnot np.allclose(batch_geom_out[0].vertices, batch_geom_out[1].vertices)\n\nTrue\n\n\n\nCompute the batched loss\n\n# This is the right way to vmap the loss\njax.vmap(meta_loss, in_axes=(None, 0,0, None))(model_initial, batch_geom_array, batch_he_array, 0.8)\n\nArray([0.25692552, 0.25749475, 0.25687504], dtype=float64)\n\n\n\n# check against non-vmapped version. pretty similar, floating point errors likely at origin of differences\n[meta_loss(model_initial, batch_geom_out[i], batch_he_out[i], 0.8) for i in range(3)]\n\n[Array(0.24862364, dtype=float64),\n Array(0.24863551, dtype=float64),\n Array(0.24863234, dtype=float64)]\n\n\n\n\n\n\nOuter optimization\nNow we are in a position to “optiomize” our model parameter ell_0. Based on equinox CNN tutorial.\n\ndef batched_meta_loss(model, batch_geom_array, batch_he_array, meta_ell0):\n    return jnp.mean(jax.vmap(meta_loss, in_axes=(None, 0,0, None))(model, batch_geom_array, batch_he_array, meta_ell0))\n\nbatched_meta_loss_jit = jax.jit(batched_meta_loss)\n\n\n## Let's do a short profiling run - how much does JIT-compilation save? I guess a little!\n\n372 ms ± 3.23 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\n\n\n\n\n474 ms ± 4.09 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\n\n\n# hyper-parameters for the outer learning step.\n\nBATCH_SIZE = 3\nLEARNING_RATE = 1e-2\nLEARNING_STEPS = 20\nprint_every = 2\n\nstep_size = 0.01\nN_steps = 20000\n\nMETA_ELL0 = 0.4\ninitial_ell0 = 0.2\n\nmodel_initial = RelaxationDynamics(ell_0=jnp.array([initial_ell0]), step_size=step_size, N_steps=N_steps)\n\n\nloss, grads = eqx.filter_jit(eqx.filter_value_and_grad(batched_meta_loss))(model_initial,\n                                                                           batch_geom_array, batch_he_array, META_ELL0)\n\n\nloss, grads, grads.ell_0\n\n(Array(0.24848878, dtype=float64),\n RelaxationDynamics(ell_0=f64[1], step_size=0.01, N_steps=20000),\n Array([-2.48070057], dtype=float64))\n\n\n\nForward and reverse mode autodiff\nSince we are differentiation w.r.t. a small number of parameters (justy 1: \\(\\ell_0\\)), we can use forward mode automatic differentiation for increased efficiency. This may be the case more generally: if we want to learn “translationally invariant” models, where the parameters for all cells are equal, the parameter count we want to differentiate by may be small. Forward mode autodiff is also somewhat more “forgiving” when it comes to control flow.\nSee: https://docs.jax.dev/en/latest/notebooks/autodiff_cookbook.html\n\n@eqx.filter_jit\ndef outer_optimizer_step(model: RelaxationDynamics,\n                         batch_geom: GeomMesh, batch_he: HeMesh) -&gt; Tuple[RelaxationDynamics, float]:\n    \n    # compute loss and grad on batch\n    \n    #loss, grads = eqx.filter_value_and_grad(batched_meta_loss)(model, batch_geom_array, batch_he_array, META_ELL0)\n    #updates = jax.tree.map(lambda g: None if g is None else -LEARNING_RATE * g, grads)\n    #model = eqx.apply_updates(model, updates)\n    # grads is a PyTree with the same leaves as the trainable arrays of the model\n\n    # same story, but using forward mode autodiff\n    loss, grads = eqx.filter_jvp(lambda model: batched_meta_loss(model, batch_geom_array, batch_he_array, META_ELL0),\n                                 primals=[model,], tangents=[model,])\n    grads = grads/model.ell_0 # we used the current model values as a tangent vector, so we need to normalize\n    model = dataclasses.replace(model, ell_0=model.ell_0-LEARNING_RATE*grads)\n    \n    return model, loss\n\n\nmodel_stepped, loss = outer_optimizer_step(model_initial, batch_geom_array, batch_he_array)\n\n\nloss, model_initial.ell_0, model_stepped.ell_0\n\n(Array(0.24848878, dtype=float64),\n Array([0.2], dtype=float64),\n Array([0.22480701], dtype=float64))\n\n\n\nmodel = model_initial\n\nfor step in tqdm(range(LEARNING_STEPS)): # in the future, could also iterate over the initial conditions/batches\n    model, loss = outer_optimizer_step(model, batch_geom_array, batch_he_array)\n    if (step % print_every) == 0:\n        print(f\"Step: {step}, loss: {loss}, param: {model.ell_0}\")\n\n# 19s with forward mode vs 32s with reverse mode.\n\n\n\n\nStep: 0, loss: 0.24848877513396528, param: [0.22480701]\nStep: 2, loss: 0.14704976288187782, param: [0.26531774]\nStep: 4, loss: 0.08837946252729874, param: [0.29610925]\nStep: 6, loss: 0.05458715535792681, param: [0.31944763]\nStep: 8, loss: 0.03524215346058198, param: [0.33709312]\nStep: 10, loss: 0.024176542728598434, param: [0.35045283]\nStep: 12, loss: 0.017795094517620076, param: [0.36062556]\nStep: 14, loss: 0.01405819184500635, param: [0.36843856]\nStep: 16, loss: 0.0118282405357572, param: [0.37449757]\nStep: 18, loss: 0.0104714494134906, param: [0.37924151]\n\n\nLooks good - the optimizer converges to the correct value of \\(\\ell_0\\).\n\n\n\nNext steps\nSuccess: we can solve this (stupid) toy problem. Our JAX-compatible infrastructure for vertex models seems to work, and we can autodiff through a simulation. Next steps:\n\nToy simulations with T1s\nMore complex models - say, the area-perimeter vertex model\nPlay around with neural ODEs and neural optimizers more generally.",
    "crumbs": [
      "Simulation test case - optimize mesh to make triangles equilateral"
    ]
  },
  {
    "objectID": "01_triangulation_datastructure.html",
    "href": "01_triangulation_datastructure.html",
    "title": "triangulax",
    "section": "",
    "text": "First, we need to create a suitable data structure to describe cell arrays. We will represent cell tilings by 2D Voronoi tessellations and variants thereof (like power diagrams). Cells are denoted by Latin indices \\(i,j,k, \\dots\\). Voronoi tessellations are dual to Delaunay triangulations (each Voronoi vertex is a Delaunay triangle). This means that we can represent the cell network as a 2D triangulation with vertices \\(V\\) and faces \\(F\\). Each face is an (ordered) triple of vertices \\((i,j,k)\\). Vertex positions are denoted \\(\\mathbf{v}_i\\).\nWe will first consider the case where the number of vertices does not change. Cells can, however, rearrange (T1-transitions/edge flips in the triangulation). Such flips also conserve the number of faces and edges. In addition to the vertices and faces, we will need to store various attributes for vertices, faces, and edges (for example, the edge lengths, or the Voronoi position of a face).\n\n\nThroughout, we will (attempt to) provide a type signature for all functions. To do so for array-based functions, we use jaxtyping.\n\n\n\nThe aim is to create a triangulation datastructure compatible with the JAX library for automatic differentiation and numerical computing. In practice, this means that we use jnp (=jax.numpy) instead of numpy, and make sure our code follows JAX’s functional programming paradigm (see JAX- the sharp bits). There is also some extra legwork to register any new classes with JAX.\n\n\n\nThe simplest way to represent a cell tiling is by its dual triangular mesh (one triangulation vertex per cell). Triangles will be denoted as faces. We thus represent a cell tiling by:\n\nA set of vertices, i.e., a \\((N_V, 2)\\) dimensional array datatype float.\nA set of faces, a \\((N_F, 3)\\) dimensional array of datatype int. Each row is a triple of vertex indices that form a face.\nA set of face positions, a \\((N_F, 2)\\) dimensional array of datatype float. An entry is the position of the tesselation vertex dual to the triangulation face.\n\nTo read and write, we use the .obj-file format. We will also make heavy use of the igl geometry processing library. We start by defining a minimal TriMesh class for our cell-tiling objects. This class is mainly a “holder” class for loading, saving, visualizing, etc meshes, and not to be used for numerical computation. We come to that below.\nFurther below, we will also add optional attributes for faces, vertices, and edges. Each attribute is a dictionary with keys (from an Enum of possibilities) and values, which are numpy vectors whose \\(n\\)th entry corresponds to vertex/face/edge \\(n\\). For this reason, vertices/faces/edges are ordered.\n\nsource\n\n\n\n\ndef TriMesh(\n    vertices:Float[Array, 'n_vertices dim'], faces:Int[Array, 'n_faces 3'], face_positions:Union=None\n)-&gt;None:\n\nSimple class for reading, holding, transforming, and saving triangular meshes.\nA TriMesh comprises vertices and faces, describing a surface in 2d or 3d. In addition, there can be a 2d/3d position for every face (think Voronoi dual of the triangulation).\nVertices and faces are jnp.arrays. Each face is a triple of vertex indices. Vertices and faces are ordered - this is essential so that we know which attribute vector entry goes to which vector/edge/face. Faces in a face are assumed to be in counter-clockwise order.\nMeshes are read and written in the .obj format (https://en.wikipedia.org/wiki/Wavefront_.obj_file). To store face_positions, we abuse the vn (vertex normal) entry of an .obj file. Face positions will be written in order corresponding to faces. When reading from an .obj file, edges are recomputed from faces and initialized in alpha-numerical ordering. An .obj file expects 3d positions; the z-position is ignored when reading and set to 0 when writing for 2d meshes.\nAttributes\ndim : int = 2\nvertices : Float[jax.Array, “n_vertices dim”]\nfaces : Int[jax.Array, “n_faces 3”]\nface_positions : Float[jax.Array, “n_faces dim”]\nProperty methods (use like attributes)\nn_vertices : int\nhas_inf_vertex : bool\nStatic methods\nread_obj : str -&gt; TriMesh\nMethods\nwrite_obj : str -&gt; None\n\n# test reading a mesh\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\n# test computing the circumcenter of each face. should be equidistant to all vertex points\n\ndists = jnp.stack([jnp.linalg.norm(mesh.vertices[mesh.faces[:,i]]-mesh.face_positions, axis=1) for i in [0,1,2]], axis=1)\n\njnp.allclose(dists[:,0], dists[:,1]) and jnp.allclose(dists[:,1], dists[:,2])\n\nArray(True, dtype=bool)\n\n\n\n# test writing face positions to vn entries\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nfilename = \"test_meshes/disk_write_test.obj\"\nmesh.write_obj(filename, save_face_positions=True)\nmesh = TriMesh.read_obj(filename, read_face_positions=True)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\n\n\nSome functions to create meshes based on the Delaunay triangulation of a point set.\n\nPoisson (vertices placed uniformly at random) in disk or box\nGinibre (vertices placed at uniform with self-repulsion)\nTriangular lattice\n\nSome functions for plotting meshes:\n\nPlot triangulation with vertex and face labels (for debugging)\nPlot cell tesselation\n\n\nsource\n\n\n\n\ndef generate_triangular_lattice(\n    nx:int, ny:int\n)-&gt;Float[Array, 'nx*ny 2']:\n\nGet points for rectangular patch of triangular lattice with nx, ny points.\n\nsource\n\n\n\n\ndef generate_poisson_points(\n    n_vertices:int, limit_x:float=1, limit_y:float=1\n)-&gt;Float[Array, 'n_vertices 2']:\n\nSample n_vertices points from the Poisson ensemble in rectangle [-limit_x/2, limit_x/2] * [-limit_y/2, limit_y/2].\n\nsource\n\n\n\n\ndef generate_ginibre_points(\n    n_vertices:int\n)-&gt;Float[Array, 'n_vertices 2']:\n\nSample n_vertices points from the Ginibre ensemble. Points are scaled to unit disk.\n\n#points = generate_triangular_lattice(10, 10)\n\npoints = generate_ginibre_points(100)\nmesh = TriMesh(vertices=points, faces=jnp.array(spatial.Delaunay(points).simplices))\n\nplt.triplot(*points.T, mesh.faces)\n\nplt.scatter(*points.T)\nplt.axis(\"equal\")\n\n(np.float64(-1.6315276371405518),\n np.float64(1.6191872290800107),\n np.float64(-1.4880190145409438),\n np.float64(1.7089872695623352))\n\n\n\n\n\n\n\n\n\n\n\n\n\nsource\n\n\n\n\ndef get_adjacent_vertex_indices(\n    faces:Int[Array, 'n_faces 3'], n_vertices:int\n)-&gt;list:\n\nFor each vertex, get the indices of the adjacent vertices in correct order. For boundary vertices, this list contains the vertex itself.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\nneighbors = get_adjacent_vertex_indices(mesh.faces, n_vertices=mesh.vertices.shape[0])\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc",
    "crumbs": [
      "JAX-compatible data structure triangulations"
    ]
  },
  {
    "objectID": "01_triangulation_datastructure.html#jax-compatible-data-structure-triangulations",
    "href": "01_triangulation_datastructure.html#jax-compatible-data-structure-triangulations",
    "title": "triangulax",
    "section": "",
    "text": "First, we need to create a suitable data structure to describe cell arrays. We will represent cell tilings by 2D Voronoi tessellations and variants thereof (like power diagrams). Cells are denoted by Latin indices \\(i,j,k, \\dots\\). Voronoi tessellations are dual to Delaunay triangulations (each Voronoi vertex is a Delaunay triangle). This means that we can represent the cell network as a 2D triangulation with vertices \\(V\\) and faces \\(F\\). Each face is an (ordered) triple of vertices \\((i,j,k)\\). Vertex positions are denoted \\(\\mathbf{v}_i\\).\nWe will first consider the case where the number of vertices does not change. Cells can, however, rearrange (T1-transitions/edge flips in the triangulation). Such flips also conserve the number of faces and edges. In addition to the vertices and faces, we will need to store various attributes for vertices, faces, and edges (for example, the edge lengths, or the Voronoi position of a face).\n\n\nThroughout, we will (attempt to) provide a type signature for all functions. To do so for array-based functions, we use jaxtyping.\n\n\n\nThe aim is to create a triangulation datastructure compatible with the JAX library for automatic differentiation and numerical computing. In practice, this means that we use jnp (=jax.numpy) instead of numpy, and make sure our code follows JAX’s functional programming paradigm (see JAX- the sharp bits). There is also some extra legwork to register any new classes with JAX.\n\n\n\nThe simplest way to represent a cell tiling is by its dual triangular mesh (one triangulation vertex per cell). Triangles will be denoted as faces. We thus represent a cell tiling by:\n\nA set of vertices, i.e., a \\((N_V, 2)\\) dimensional array datatype float.\nA set of faces, a \\((N_F, 3)\\) dimensional array of datatype int. Each row is a triple of vertex indices that form a face.\nA set of face positions, a \\((N_F, 2)\\) dimensional array of datatype float. An entry is the position of the tesselation vertex dual to the triangulation face.\n\nTo read and write, we use the .obj-file format. We will also make heavy use of the igl geometry processing library. We start by defining a minimal TriMesh class for our cell-tiling objects. This class is mainly a “holder” class for loading, saving, visualizing, etc meshes, and not to be used for numerical computation. We come to that below.\nFurther below, we will also add optional attributes for faces, vertices, and edges. Each attribute is a dictionary with keys (from an Enum of possibilities) and values, which are numpy vectors whose \\(n\\)th entry corresponds to vertex/face/edge \\(n\\). For this reason, vertices/faces/edges are ordered.\n\nsource\n\n\n\n\ndef TriMesh(\n    vertices:Float[Array, 'n_vertices dim'], faces:Int[Array, 'n_faces 3'], face_positions:Union=None\n)-&gt;None:\n\nSimple class for reading, holding, transforming, and saving triangular meshes.\nA TriMesh comprises vertices and faces, describing a surface in 2d or 3d. In addition, there can be a 2d/3d position for every face (think Voronoi dual of the triangulation).\nVertices and faces are jnp.arrays. Each face is a triple of vertex indices. Vertices and faces are ordered - this is essential so that we know which attribute vector entry goes to which vector/edge/face. Faces in a face are assumed to be in counter-clockwise order.\nMeshes are read and written in the .obj format (https://en.wikipedia.org/wiki/Wavefront_.obj_file). To store face_positions, we abuse the vn (vertex normal) entry of an .obj file. Face positions will be written in order corresponding to faces. When reading from an .obj file, edges are recomputed from faces and initialized in alpha-numerical ordering. An .obj file expects 3d positions; the z-position is ignored when reading and set to 0 when writing for 2d meshes.\nAttributes\ndim : int = 2\nvertices : Float[jax.Array, “n_vertices dim”]\nfaces : Int[jax.Array, “n_faces 3”]\nface_positions : Float[jax.Array, “n_faces dim”]\nProperty methods (use like attributes)\nn_vertices : int\nhas_inf_vertex : bool\nStatic methods\nread_obj : str -&gt; TriMesh\nMethods\nwrite_obj : str -&gt; None\n\n# test reading a mesh\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\n# test computing the circumcenter of each face. should be equidistant to all vertex points\n\ndists = jnp.stack([jnp.linalg.norm(mesh.vertices[mesh.faces[:,i]]-mesh.face_positions, axis=1) for i in [0,1,2]], axis=1)\n\njnp.allclose(dists[:,0], dists[:,1]) and jnp.allclose(dists[:,1], dists[:,2])\n\nArray(True, dtype=bool)\n\n\n\n# test writing face positions to vn entries\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nfilename = \"test_meshes/disk_write_test.obj\"\nmesh.write_obj(filename, save_face_positions=True)\nmesh = TriMesh.read_obj(filename, read_face_positions=True)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\n\n\nSome functions to create meshes based on the Delaunay triangulation of a point set.\n\nPoisson (vertices placed uniformly at random) in disk or box\nGinibre (vertices placed at uniform with self-repulsion)\nTriangular lattice\n\nSome functions for plotting meshes:\n\nPlot triangulation with vertex and face labels (for debugging)\nPlot cell tesselation\n\n\nsource\n\n\n\n\ndef generate_triangular_lattice(\n    nx:int, ny:int\n)-&gt;Float[Array, 'nx*ny 2']:\n\nGet points for rectangular patch of triangular lattice with nx, ny points.\n\nsource\n\n\n\n\ndef generate_poisson_points(\n    n_vertices:int, limit_x:float=1, limit_y:float=1\n)-&gt;Float[Array, 'n_vertices 2']:\n\nSample n_vertices points from the Poisson ensemble in rectangle [-limit_x/2, limit_x/2] * [-limit_y/2, limit_y/2].\n\nsource\n\n\n\n\ndef generate_ginibre_points(\n    n_vertices:int\n)-&gt;Float[Array, 'n_vertices 2']:\n\nSample n_vertices points from the Ginibre ensemble. Points are scaled to unit disk.\n\n#points = generate_triangular_lattice(10, 10)\n\npoints = generate_ginibre_points(100)\nmesh = TriMesh(vertices=points, faces=jnp.array(spatial.Delaunay(points).simplices))\n\nplt.triplot(*points.T, mesh.faces)\n\nplt.scatter(*points.T)\nplt.axis(\"equal\")\n\n(np.float64(-1.6315276371405518),\n np.float64(1.6191872290800107),\n np.float64(-1.4880190145409438),\n np.float64(1.7089872695623352))\n\n\n\n\n\n\n\n\n\n\n\n\n\nsource\n\n\n\n\ndef get_adjacent_vertex_indices(\n    faces:Int[Array, 'n_faces 3'], n_vertices:int\n)-&gt;list:\n\nFor each vertex, get the indices of the adjacent vertices in correct order. For boundary vertices, this list contains the vertex itself.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\nneighbors = get_adjacent_vertex_indices(mesh.faces, n_vertices=mesh.vertices.shape[0])\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc",
    "crumbs": [
      "JAX-compatible data structure triangulations"
    ]
  },
  {
    "objectID": "01_triangulation_datastructure.html#half-edge-meshes",
    "href": "01_triangulation_datastructure.html#half-edge-meshes",
    "title": "triangulax",
    "section": "Half-edge meshes",
    "text": "Half-edge meshes\nFor simulation and geometry processing, we need a different representation of the adjacency information than the list of triangle (for example, to compute the area of a cell). Typically, this is achieved by a half-edge mesh (HE) data structure. We represent the HE data structure by 3 sets of integer index arrays:\n\nVertices: 1 \\((N_V,)\\) matrix, whose entry for vertex \\(i\\) is an arbitrary HE incident on \\(i\\)\nEdges: 6 \\((2N_E,)\\) matrices, [origin, dest, nxt, prv, twin, face] for each half-edge. face can be np.nan for boundary vertices.\nFaces, 1 \\((N_F, 1)\\) matrix, whose entry for face \\(i\\) is an arbitrary HE in \\(i\\). (Not to be confused with the \\((N_F, 3)\\) matrix of vertex IDs used previously).\n\nAdditionally, there are two float arrays for vertex and face positions, as previously. However, we split combinatorial and geometric information - a HeMesh class for the combinatorics, and a couple of regular arrays for the vertex positions, face positions, and vertex/half-edge/face attributes. The latter are packaged into a GeomMesh class. Together, the pair (GeomMesh, HeMesh) describes a mesh (like vertices/faces pair). A named tuple Mesh comines the two.\nThe first task is to create a helper function to plot mesh connectivity, and to create the half-edge connectivity matrices from the more conventional list-of-triangles format. The latter is somewhat involved.\n\nsource\n\nlabel_plot\n\ndef label_plot(\n    vertices:Float[Array, 'n_vertices 2'], faces:Int[Array, 'n_faces 3'], hemesh:Union=None, vertex_labels:bool=True,\n    face_labels:bool=True, ax:Union=None, fontsize:Union=None\n)-&gt;None:\n\nFor debugging purposes. Plot triangular mesh with face/vertex labels in black/blue. If hemesh is not None, the connectivity info from it is used to plot the half-edge labels.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\n\nplt.triplot(*mesh.vertices.T, mesh.faces)\nlabel_plot(mesh.vertices, mesh.faces, fontsize=10)\nplt.axis(\"equal\")\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n(np.float64(-1.10003475),\n np.float64(1.09628575),\n np.float64(-1.09934025),\n np.float64(1.09050125))\n\n\n\n\n\n\n\n\n\n\nsource\n\n\nget_half_edge_arrays\n\ndef get_half_edge_arrays(\n    n_vertices:int, faces:Int[Array, 'n_faces 3']\n)-&gt;list:\n\nGet half-edge data structure arrays from faces.\nReturns: incident, orig, dest, twin, nxt, prv, heface, face_incident\n\n\nJAX compatibility\nWe want to be compatible with JAX. For this reason, we\n\nAlways use jnp = jax.numpy instead of np\nInstead of in-place array modifications, use JAX’s x = x.at[idx].set(y) syntax\nAvoid any in-place modifications in the HeMesh and GeomHeMesh data structures\nRegister our (data)classes with JAX, so JAX knows how to handle them during gradient-computation and just-in-time compilation. See here and here. This involves declaring which parts are mutable and which parts are permanent.\n\nLateron, for simulations, we use the equinox library, which adds a few useful tools to JAX. (A neural-network library like flax is probably overkill).\n\nPyTrees\nJAX supports not only arrays as inputs/outputs/intermediate variables, but also pytrees. Pytrees are nested structures (dicts, lists-of-lists, etc) whose leaves are “elementary” objects like arrays. Fortunately, our HeMesh class is already a lot like a pytree - it is a collection of arrays. For JAX to understand this, we need to register our HeMesh class as a custom pytree node. We register our dataclasses using jax.tree_util.register_dataclass.\nSidenote: Neural networks, in libraries like Flax or Equinox, are basically very similar. They are dataclass-like classes which hold all the arrays associated with a NN (the different weights, and maybe some parameters) with class methods like __call__ specifying the forward pass through the NN. Equinox automatically registers your NN as a pytree by inheriting from the equinox.Module class.\n\n\nControl flow\nFor just-in-time compilation, JAX distinguishes two types of variables: dynamic and static. Control flow cannot depend on the value of dynamic variables, only on their shape.\nUpshots: 1. replace if with jax.lax.cond / jnp.where (full autodiff compatible), and while with jax.lax.while_loop (forward autodiff only). 2. mark variables which are not going to change during simulation as static.\n\nsource\n\n\n\nHeMesh\n\ndef HeMesh(\n    incident:Int[Array, '*batch n_vertices'], orig:Int[Array, '*batch n_hes'], dest:Int[Array, '*batch n_hes'],\n    twin:Int[Array, '*batch n_hes'], nxt:Int[Array, '*batch n_hes'], prv:Int[Array, '*batch n_hes'],\n    heface:Int[Array, '*batch n_hes'], face_incident:Int[Array, '*batch n_faces'], inf_vertices:Union=()\n)-&gt;None:\n\nHalf-edge mesh data structure for triangular meshes.\nA half-edge mesh is described by a set of half-edges and several arrays that specify their connectivity (see markup explanation above). This class serves as a container for multiple arrays. For future compatibility with JAX, after initialization, do not modify these arrays in-place; always return a new HeMesh object. The mesh vertices may live in whatever dimension - this does not affect the connectivity bookkeeping.\nHalf-edge meshes are initialized from a list of triangles and a number of vertices, and can return the original triangles (e.g., to save as a .obj).\nAll information and methods are purely “combinatorial”. The HeMesh class does not contain the vertex or face positions. These are saved in the GeomHeMesh class that combines a HeMesh (combinatorics) with a couple of other arrays (geometry).\n—Conventions—\nFor vertices, the incident half-edge points away from the vertex.\nTo describe the mesh boundary, there are two options: 1. Initialize from a triangulation with a boundary. Half-edges without a face (boundary) are assigned heface=-1. 2. Initialize from a triangulation without boundary, where certain vertices are “at infinity”. They should have coordinates [np.inf, np.inf]. Each infinity vertex corresponds to one boundary. For a single boundary, the vertex at infinity is, by convention, the final one.\nStarting from a set of triangles, the half-edges are initialized as follows: The 1st N_edges half-edges are (origin_vertex, destination_vertex), in lexicographic order, with origin_vertex &lt; destination_vertex. The 2nd N_edges are their twins, in the same order.\nAttributes\nincident : Int[jax.Array, “n_vertices”]\norig : Int[jax.Array, “n_hes”]\ndest : Int[jax.Array, “n_hes”]\nnxt : Int[jax.Array, “n_hes”]\nprv : Int[jax.Array, “n_hes”]\ntwin : Int[jax.Array, “n_hes”]\nheface : Int[jax.Array, “n_hes”]\nface_incident : Int[jax.Array, “n_faces”]\ninf_vertices : tuple[Int]\nProperty methods (use like attributes)\nn_vertices : int\nn_hes : int\nn_faces : int\nn_items : tuple[int, int, int]\nfaces : Int[jax.Array, “n_faces 3”]\nhas_inf_vertex : bool\nis_inf_face : Bool[jax.Array, “n_faces”]\nis_unique : Bool[jax.Array, “n_hes”]\nis_inf_he : Bool[jax.Array, “n_hes”]\nis_bdry_he : Bool[jax.Array, “n_hes”]\nis_bdry_edge : Bool[jax.Array, “n_hes”]\nis_bdry : Bool[jax.Array, “n_vertices”]\nStatic methods\nfrom_triangles : tuple[int, Int[jax.Array, “n_faces 3”], Int[jax.Array, “n_boundaries”] -&gt; HeMesh\nClass methods\niterate_around_vertex : int -&gt; Int[jax.Array, “n_neighbors”]\nsave : str -&gt; None:\nStatic methods\nload : str -&gt; HeMesh\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\n# hemeshes can be compared for equali and are registered as py-trees\n\nleafs, ts = jax.tree_util.tree_flatten(hemesh)\n\nhemesh, hemesh == hemesh\n\n(HeMesh(N_V=131, N_HE=708, N_F=224), True)\n\n\n\n# test iteration around vertex\nhemesh.dest[hemesh.iterate_around_vertex(69)], hemesh.orig[hemesh.iterate_around_vertex(56)]\n\n(Array([80, 68, 56, 46], dtype=int64),\n Array([56, 56, 56, 56, 56, 56, 56], dtype=int64))\n\n\n\n# boundary in cc-wise order\n(hemesh.orig[187], hemesh.dest[187]), hemesh.heface[187], hemesh.is_bdry_he[187],\n\n((Array(58, dtype=int64), Array(70, dtype=int64)),\n Array(-1, dtype=int64),\n Array(True, dtype=bool))\n\n\n\nhemesh.is_bdry_he[187], hemesh.is_bdry_he[541], hemesh.heface[541]\n\n(Array(True, dtype=bool), Array(False, dtype=bool), Array(145, dtype=int64))\n\n\n\n# to model mesh boundaries, we can add an \"infinity\" vertex. Not done here, see below\nhemesh.has_inf_vertex, hemesh.inf_vertices\n\n(False, ())\n\n\n\nfig = plt.figure(figsize=(14,14))\n\nplt.triplot(*mesh.vertices.T, hemesh.faces)\nlabel_plot(mesh.vertices, hemesh.faces, fontsize=10, hemesh=hemesh, face_labels=False)\nplt.axis(\"equal\")\n\n(np.float64(-1.10003475),\n np.float64(1.09628575),\n np.float64(-1.09934025),\n np.float64(1.09050125))\n\n\n\n\n\n\n\n\n\n\n# here is how you would do mesh traversal with jax.lax. The issues is that the output size needs to be fixed\n# ahead of time, so \n\nself = hemesh\nmax_valence = 10\nv = 10\n\ninitial = jnp.hstack([jnp.array([self.incident[v]]), -1*jnp.ones(max_valence-1, dtype=int)])\njax.lax.fori_loop(1, max_valence, lambda i, x: x.at[i].set(self.twin[x[i-1]]), initial)\n\nArray([ 47, 401,  47, 401,  47, 401,  47, 401,  47, 401], dtype=int64)\n\n\n\n\nBoundary and the vertex at infinity\nSo far, our mesh representations TriMesh and HeMesh work for triangular meshes with and without boundary. Boundary half-edges are assigned to a fictitious -1 face. This convention has a downside. It is not possible to modify the boundary loop of the mesh by edge flips - doing so would result in an invalid state. In a simulation, this artificially limits the mesh’s ability to deform. Instead, we can add “vertices at infinity” and connect al edges in a given boundary to \\(\\infty\\). This turns the mesh into a topological sphere. Now, one can flip boundary edges without the overall number of half-edges changing (so the array shape stays the same). Multiple boundaries are also supported. Each boundary corresponds to a distinct \\(\\infty\\)-vertex (for example, 2 for a cylinder)/\nThe coordinates of the fictitious vertices are set to [np.inf, np.inf] by convention. The boundary is found by iterating around \\(\\infty\\). By convention, \\(\\infty\\)-vertices, if they exists, are the final vertices of the mesh (don’t rely on this - implementation detail).\nWe generally assume that the mesh has only a single connected component.\nThe HeMesh class can deal with both the -1-face and the \\(\\infty\\)-vertices conventions. The latter are listed in the inf_vertices attribute of a HeMesh.\n\nsource\n\n\nconnect_boundary_to_infinity\n\ndef connect_boundary_to_infinity(\n    vertices:Float[Array, 'n_vertices 2'], # Vertex positions.\n    faces:Int[Array, 'n_faces 3'], # Faces (triangles) as list of vertex indices.\n)-&gt;tuple: # Vertex positions with infinity vertices appended.\nOne infinity vertex per boundary loop.\n\nConnect boundary loop(s) to infinity.\nNew vertices are appeneded to the end of vertex array and have coordinates [np.inf, np.inf].\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\nnew_vertices, new_faces, infinity_vertices = connect_boundary_to_infinity(mesh.vertices, mesh.faces)\nmesh_infty = TriMesh(vertices=new_vertices, faces=new_faces)\nhemesh_infty = HeMesh.from_triangles(mesh_infty.vertices.shape[0], mesh_infty.faces,\n                                     inf_vertices=infinity_vertices)\n\n\nigl.is_edge_manifold(mesh_infty.faces)[0], igl.is_vertex_manifold(mesh_infty.faces)[0]\n\n(True, np.True_)\n\n\n\nhemesh_infty.dest[hemesh_infty.iterate_around_vertex(-1)], igl.boundary_loop(mesh.faces)\n\n(Array([  0,  10,  21,  34,  47,  58,  70,  86,  91, 100, 108, 113, 114,\n        110, 111, 112, 107,  99,  85,  80,  69,  46,  33,  32,  20,   9,\n        130, 121, 120, 119, 118, 117, 116, 115, 123, 122], dtype=int64),\n array([  0, 122, 123, 115, 116, 117, 118, 119, 120, 121, 130,   9,  20,\n         32,  33,  46,  69,  80,  85,  99, 107, 112, 111, 110, 114, 113,\n        108, 100,  91,  86,  70,  58,  47,  34,  21,  10], dtype=int64))\n\n\n\nhemesh_infty.dest[hemesh_infty.iterate_around_vertex(0)], hemesh.dest[hemesh.iterate_around_vertex(0)]\n\n(Array([  1,  11,  10, 131, 122], dtype=int64),\n Array([  1,  11,  10, 122], dtype=int64))\n\n\n\n(hemesh.is_bdry == (hemesh_infty.is_bdry[:-1] &gt;0)).all()\n\nArray(True, dtype=bool)\n\n\n\n# to get back the original faces/vertices, do this:\n\n_ = hemesh_infty.faces[~hemesh_infty.is_inf_face]",
    "crumbs": [
      "JAX-compatible data structure triangulations"
    ]
  },
  {
    "objectID": "01_triangulation_datastructure.html#mesh-geometry-and-per-mesh-variables",
    "href": "01_triangulation_datastructure.html#mesh-geometry-and-per-mesh-variables",
    "title": "triangulax",
    "section": "Mesh geometry and per-mesh variables",
    "text": "Mesh geometry and per-mesh variables\nMesh geometry (vertex and face positions) and per-mesh-item (per-face, per-half-edge, per-vertex) variables are combined into a second data class, the GeomMesh.\n\nVertex, half-edge, and face properties\nIn simulations, we will often want to attach extra information to a mesh’s vertices/edges/faces. In the GeomMesh class, these are saved in three dictionaries, vertex_attribs, he_attribs, face_attribs. Each key/value pair represents one property (for example, the cell target area). All values are arrays, and the first axis corresponds to the number of vertices/half-edges/faces, respectively. To keep track of the possible attributes, we use IntEnum’s as keys (this also ensures keys are hashable, as required by JAX)\n\nsource\n\n\nFaceAttribs\n\ndef FaceAttribs(\n    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD\n):\n\nEnum where members are also (and must be) ints\n\nsource\n\n\nHeAttribs\n\ndef HeAttribs(\n    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD\n):\n\nEnum where members are also (and must be) ints\n\nsource\n\n\nVertexAttribs\n\ndef VertexAttribs(\n    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD\n):\n\nEnum where members are also (and must be) ints\n\nHeAttribs.EDGE_TENSION, HeAttribs(1), HeAttribs['EDGE_TENSION'], HeAttribs.EDGE_TENSION.name\n\n(&lt;HeAttribs.EDGE_TENSION: 1&gt;,\n &lt;HeAttribs.EDGE_TENSION: 1&gt;,\n &lt;HeAttribs.EDGE_TENSION: 1&gt;,\n 'EDGE_TENSION')\n\n\n\nsource\n\n\nGeomMesh\n\ndef GeomMesh(\n    n_vertices:int, n_hes:int, n_faces:int, vertices:Float[Array, '*batch n_vertices dim'],\n    face_positions:Float[Array, '*batch n_faces 2']=&lt;factory&gt;, vertex_attribs:dict=&lt;factory&gt;,\n    he_attribs:dict=&lt;factory&gt;, face_attribs:dict=&lt;factory&gt;\n)-&gt;None:\n\nData class for holding mesh geometry and mesh-associated variables. To be combined with a HeMesh to specify the connectivity.\nOne array (for vertex positions) must always be present. A second, but optional, standard entry is a set of positions for each face. The mesh coordinates can live in 2d or 3d.\nOptionally, vertices, half-edges, and faces can have attributes (stored as dictionaries). The keys of the dictionary should be taken from a suitable ‘enum’. The values are ndarrays, whose 0th axis is (vertices/edges/faces). These attribute dicts are initialized empty and can be set afterwards.\nSee documentation on HeMesh\nAttributes\nvertices : Float[jax.Array, “n_vertices 2”]\nface_positions : Float[jax.Array, “n_faces 2”]\nvertex_attribs : dict[IntEnum, Float[jax.Array, “n_vertices *”]]\nhe_attribs : dict[IntEnum, Float[jax.Array, “n_hes *”]]\nface_attribs : dict[IntEnum, Float[jax.Array, “n_faces *”]]\nProperty methods (use like attributes)\nn_items : tuple[int, int, int]\ndim : int\nClass methods\nvalidate_dimensions : bool\nStatic methods\nload : str -&gt; GeomHeMesh\n\nsource\n\n\nset_voronoi_face_positions\n\ndef set_voronoi_face_positions(\n    geommesh:GeomMesh, hemesh:HeMesh\n)-&gt;GeomMesh:\n\nSet face positions of geommesh to the circumcenters of the faces defined by hemesh.\n\nsource\n\n\nget_voronoi_face_positions\n\ndef get_voronoi_face_positions(\n    vertices:Float[Array, 'n_vertices 2'], hemesh:HeMesh\n)-&gt;Float[Array, 'n_faces 2']:\n\nGet face positions of geommesh to the circumcenters of the faces defined by hemesh.\n\nsource\n\n\nMesh\n\ndef Mesh(\n    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD\n):\n\nCombine geometric and connectivity info into a single object.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\ncombined_mesh = Mesh(geommesh, hemesh)\ncombined_mesh\n\nMesh(geommesh=GeomMesh(D=2,N_V=131, N_HE=708, N_F=224), hemesh=HeMesh(N_V=131, N_HE=708, N_F=224))\n\n\n\nleafs, ts = jax.tree_util.tree_flatten(geommesh) # also a pytree\nts\n\nPyTreeDef(CustomNode(GeomMesh[(131, 708, 224)], [*, *, {}, {}, {}]))\n\n\n\ngeommesh, geommesh.n_vertices, geommesh.vertices.shape, geommesh.check_compatibility(hemesh), geommesh == geommesh\n\n(GeomMesh(D=2,N_V=131, N_HE=708, N_F=224), 131, (131, 2), True, True)\n\n\n\nsource\n\n\ncellplot\n\ndef cellplot(\n    hemesh:HeMesh, face_positions:Float[Array, 'n_faces 2'], cell_colors:Union=None, mpl_polygon_kwargs:Union=None\n)-&gt;PatchCollection:\n\nPlot a cell tesselation.\ncell_colors can be either a single color (for all cells) or a vector of rgba values. Only interior cells are plotted.\n\nplt.triplot(*geommesh.vertices.T, hemesh.faces)\npolygons = cellplot(hemesh, geommesh.face_positions,\n                    cell_colors=np.array([0,0,1,0.5]), mpl_polygon_kwargs={\"lw\": 1, \"ec\": \"k\"})\nax = plt.gca()\nax.add_collection(polygons)\n\nplt.axis(\"equal\")\n\n(np.float64(-1.10003475),\n np.float64(1.09628575),\n np.float64(-1.09934025),\n np.float64(1.09050125))\n\n\n\n\n\n\n\n\n\n\n\nAdding some vertex/half-edge/face properties\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommmesh = GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\n# at initialization, a HeMesh's attribute dictionaries are empty\ngeommmesh.vertex_attribs\n\n{}\n\n\n\n# set some attributes\n\nkey1 = jax.random.key(0)\n_, key2 = jax.random.split(key1)\n_, key3 = jax.random.split(key2)\n\ngeommmesh = dataclasses.replace(geommmesh, vertex_attribs={VertexAttribs.TARGET_AREA: jax.random.normal(key=key1, shape=geommmesh.n_vertices),\n                                                           VertexAttribs.TARGET_PERIMETER: jax.random.normal(key=key2, shape=geommmesh.n_vertices)})\ngeommmesh = dataclasses.replace(geommmesh, he_attribs={HeAttribs.EDGE_TENSION: jax.random.normal(key=key3, shape=geommmesh.n_hes)})\n\n\ngeommmesh.he_attribs.keys()\n\ndict_keys([&lt;HeAttribs.EDGE_TENSION: 1&gt;])",
    "crumbs": [
      "JAX-compatible data structure triangulations"
    ]
  },
  {
    "objectID": "01_triangulation_datastructure.html#batching",
    "href": "01_triangulation_datastructure.html#batching",
    "title": "triangulax",
    "section": "Batching",
    "text": "Batching\nIn our simulations, we may want to “batch” over several initial conditions/random seeds/etc (analogous to batching over training data in normal ML). In JAX, we can efficiently and concisely vectorize operations over such “batch axes” with jax.vmap.\nTo batch over our custom data structures, we need to pull a small trick - convert a list of HeMesh/GeomMeshe instances into a single mesh with a batch axis for the various arrays. Luckily, this can be done using JAX’s pytree tools.\n\nsource\n\ntree_unstack\n\ndef tree_unstack(\n    xb:PyTree, axis:int=0\n)-&gt;list:\n\nUnstack a batched pytree along axis into a list of pytrees.\n\nsource\n\n\ntree_stack\n\ndef tree_stack(\n    xs:list, axis:int=0\n)-&gt;PyTree:\n\nStack a sequence of identical-structure pytrees along a new axis.\n\n## Let us create a bunch of meshes with different initial positions and see if we can batch over them using vmap\n\nkey = jax.random.key(0)\nsigma = 0.02\n\nbatch_geom = []\nbatch_he = []\nfor i in range(3):\n    key, subkey = jax.random.split(key)\n    random_noise = jax.random.normal(subkey, shape=geommmesh.vertices.shape)\n    batch_geom.append(dataclasses.replace(geommmesh, vertices=geommmesh.vertices+sigma*random_noise))\n    batch_he.append(copy.copy(hemesh))\n\n\n# define a test function to appy over the batch\n\ndef test_function(geommesh: GeomMesh, hemesh: HeMesh) -&gt; Float[jax.Array, \" n_vertices\"]:\n    \"\"\"Dummy test function.\"\"\"\n    return jnp.ones(geommesh.n_vertices)\n\n\n# naive batching does not work. JAX needs a \"struct-of-arrays\", but a list of HeMeshes is an \"array-of-structs\"\n# see https://stackoverflow.com/questions/79123001/storing-and-jax-vmap-over-pytrees\n\ntry:\n    jax.vmap(test_function)(batch_geom, batch_he)\nexcept (ValueError, TypeError) as e:\n    print(\"Expected error:\", e)\n\nExpected error: vmap got inconsistent sizes for array axes to be mapped:\n  * most axes (21 of them) had size 708, e.g. axis 0 of argument geommesh[0].he_attribs[&lt;HeAttribs.EDGE_TENSION: 1&gt;] of type float64[708];\n  * some axes (12 of them) had size 131, e.g. axis 0 of argument geommesh[0].vertices of type float64[131,2];\n  * some axes (6 of them) had size 224, e.g. axis 0 of argument geommesh[0].face_positions of type float64[224,2]\n\n\n\n# instead, we use a jax.tree.map to \"push\" the list axis into the underlying arrays.\n\nbatch_he_array = tree_stack(batch_he)\nbatch_geom_array = tree_stack(batch_geom)\nbatch_geom_array, batch_geom_array.vertices.shape\n\n(GeomMesh(D=2,N_V=131, N_HE=708, N_F=224), (3, 131, 2))\n\n\n\n\n\nThe jaxtyping extension is not loaded.\n\n\n\n# now it works! The result is a single object with batch axis\n\nbatch_out = jax.vmap(test_function)(batch_geom_array, batch_he_array) \nbatch_out.shape\n\n(3, 131)\n\n\n\n# we can unpack things again into a list of meshes\n\nisinstance(tree_unstack(batch_out), list)\n\nTrue",
    "crumbs": [
      "JAX-compatible data structure triangulations"
    ]
  },
  {
    "objectID": "01_triangulation_datastructure.html#edge-flips-t1s",
    "href": "01_triangulation_datastructure.html#edge-flips-t1s",
    "title": "triangulax",
    "section": "Edge flips / T1s",
    "text": "Edge flips / T1s\nIn our simulations, cells will exchange neighbors (T1-event). In the triangulation, this corresponds to an edge flip. We now implement the edge flip algorithm for HeMeshes. We basically edit the various connectivity arrays (in a JAX-compatible way).\nThe algorithm (and the naming conventions in flip_edge) are from here: https://jerryyin.info/geometry-processing-algorithms/half-edge/.\nBefore\n\n\n\nimage.png\n\n\nAfter\n\n\n\nimage.png\n\n\n\nsource\n\nflip_edge\n\ndef flip_edge(\n    hemesh:HeMesh, e:Int[Array, ''], check_boundary:bool=False\n)-&gt;HeMesh:\n\nFlip half-edge e in a half-edge mesh.\nSee https://jerryyin.info/geometry-processing-algorithms/half-edge/. The algorithm is slightly modified since we keep track of the origin and destination of a half-edge, and use arrays instead of pointers. Returns a new HeMesh, does not modify in-place.\n\nsource\n\n\nget_signed_dual_he_length\n\ndef get_signed_dual_he_length(\n    vertices:Float[Array, 'n_vertices 2'], face_positions:Float[Array, 'n_hes 2'], hemesh:HeMesh\n)-&gt;Float[Array, 'n_hes']:\n\nCompute lengths of dual edges. Boundary dual edges get length jnp.nan. Negative sign = flipped edge.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\nplt.triplot(*geommesh.vertices.T, hemesh.faces)\nax = plt.gca()\np = cellplot(hemesh, geommesh.face_positions,\n             cell_colors=np.array([0,0,0,0.1]), mpl_polygon_kwargs={\"lw\": 1, \"ec\": \"k\"})\nplt.gca().add_collection(p)\n\nplt.axis(\"equal\")\n\n(np.float64(-1.10003475),\n np.float64(1.09628575),\n np.float64(-1.09934025),\n np.float64(1.09050125))\n\n\n\n\n\n\n\n\n\n\n# edges and dual edges should be orthogonal since we are using circumcenters\n\nedges = geommesh.vertices[hemesh.orig]-geommesh.vertices[hemesh.dest]\ndual_edges = (geommesh.face_positions[hemesh.heface]\n              -geommesh.face_positions[hemesh.heface[hemesh.twin]])\n\njnp.allclose(jnp.einsum('vi,vi-&gt;v', edges[~hemesh.is_bdry_edge], dual_edges[~hemesh.is_bdry_edge]), 0)\n\nArray(True, dtype=bool)\n\n\n\n# computing the signed edge length shows that there are some \"flipped\" edges.\n\nsigned_squared_length = jnp.einsum('vi,vi-&gt;v', edges, dual_edges @ trig.get_rot_mat(np.pi/2))\njnp.where((signed_squared_length &lt; -0.0) & ~hemesh.is_bdry_edge )[0]\n\nArray([  9, 185, 191, 335, 363, 539, 545, 689], dtype=int64)\n\n\n\nisinstance(335, int)\n\nTrue\n\n\n\n# flip edge and recompute face positions\n\nflipped_hemesh = flip_edge(hemesh, e=335)\nflipped_geommesh = set_voronoi_face_positions(geommesh, flipped_hemesh)\n\n\n# connectivity is still valid\n\nigl.is_edge_manifold(hemesh.faces)[0], igl.is_edge_manifold(flipped_hemesh.faces)[0], flipped_hemesh.iterate_around_vertex(100)\n\n(True, True, Array([298, 299, 630, 632], dtype=int64))\n\n\n\n# you can see the flipped edge in the plot below - it's where the blue mesh forms a \"bow-tie\"\n\nfig = plt.figure(figsize=(8,8))\n\nplt.triplot(*geommesh.vertices.T, hemesh.faces)\nplt.triplot(*flipped_geommesh.vertices.T, flipped_hemesh.faces)\n\nax = plt.gca()\np1 = cellplot(hemesh, geommesh.face_positions,\n         cell_colors=np.array([0.,0.,0.,0.]), mpl_polygon_kwargs={\"lw\": 1, \"ec\": \"k\"})\np2 = cellplot(flipped_hemesh, flipped_geommesh.face_positions,\n              cell_colors=np.array([0.,0.,0.,0.]), mpl_polygon_kwargs={\"lw\": 1, \"ec\": \"tab:orange\"})\nax.add_collection(p1)\nax.add_collection(p2)\nplt.axis(\"equal\")\n\nlabel_plot(geommesh.vertices, hemesh.faces, fontsize=10, face_labels=False)\n\n\n\n\n\n\n\n\n\nRepeated flips\nIn a simulation, we need to carry out edge flips at every timestep. The function flip_edge(hemesh: HeMesh, e: int) -&gt; HeMesh does a single edge flip by modifying the connectivity arrays. Luckily, it is already JAX-compatible (we can JIT-compile it).\nThe next goal is to carry out multiple flips. We must be careful: doing multiple flips “simultaneously” risks leaving the mesh in an inconsistent state. Instead, we do the flips in sequence. To make things JAX-compatible, we do a jax.lax.scan scan over all half-edges.\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\ndual_lengths = get_signed_dual_he_length(geommesh.vertices, geommesh.face_positions, hemesh)\nedges = jnp.where((dual_lengths &lt; -0.05) & ~hemesh.is_bdry_edge & hemesh.is_unique)[0]\n# we only want to flip unique hes!\nedges, edges.size\n\n(Array([  9, 185, 191, 335], dtype=int64), 4)\n\n\n\n# scan over indices of negative-length edges. \nflipped_hemesh, _ = jax.lax.scan(lambda h, e: (flip_edge(h, e), None) , init=hemesh, xs=edges)\n\n# this scan is over an array whose shape varies. Instead, we can scan over all hes, and flip only if the length is negative (via jax.lax.cond).\n\n\nsource\n\n\n\nflip_all\n\ndef flip_all(\n    hemesh:HeMesh, to_flip:Bool[Array, 'n_hes']\n)-&gt;HeMesh:\n\nFlip all (unique) half-edges where to_flip is True in a half-edge mesh. Wraps flip_edge.\n\nto_flip = (dual_lengths &lt; 0) & ~jnp.isnan(dual_lengths)\n\nflipped_hemesh = flip_all(hemesh, to_flip=to_flip)\n\n\nflipped_hemesh = flip_all(hemesh, to_flip=(dual_lengths&lt;0.02)) # no extra recompile\n\n\nflipped_geommesh = set_voronoi_face_positions(geommesh, flipped_hemesh)\n\n\nfig = plt.figure(figsize=(8,8))\n\nplt.triplot(*geommesh.vertices.T, hemesh.faces)\nplt.triplot(*flipped_geommesh.vertices.T, flipped_hemesh.faces)\n\nax = plt.gca()\nax = plt.gca()\np1 = cellplot(hemesh, geommesh.face_positions,\n         cell_colors=np.array([0.,0.,0.,0.]), mpl_polygon_kwargs={\"lw\": 1, \"ec\": \"k\"})\np2 = cellplot(flipped_hemesh, flipped_geommesh.face_positions,\n              cell_colors=np.array([0.,0.,0.,0.]), mpl_polygon_kwargs={\"lw\": 1, \"ec\": \"tab:orange\"})\nax.add_collection(p1)\nax.add_collection(p2)\nplt.axis(\"equal\")\n\nlabel_plot(geommesh.vertices, hemesh.faces, fontsize=10, face_labels=False)",
    "crumbs": [
      "JAX-compatible data structure triangulations"
    ]
  },
  {
    "objectID": "01_triangulation_datastructure.html#adjacency-like-operators-on-half-edge-meshes",
    "href": "01_triangulation_datastructure.html#adjacency-like-operators-on-half-edge-meshes",
    "title": "triangulax",
    "section": "Adjacency-like operators on half-edge meshes",
    "text": "Adjacency-like operators on half-edge meshes\n\nComputing cell areas, perimeters, etc via corners\nTo compute, for instance, the cell area using the shoelace formula, you need to iterate around the faces adjacent to a vertex. This is not straightforward to vectorize because the number of adjacent faces per vertex can vary (there can be 5-, 6-, 7-sided cells etc.). That is, the list of adjacent faces is a “ragged” array. However, vectorization is essential for numerical efficiency and compatibility with JAX. For example, we may want to compute an energy and its gradient, which depends on cell areas. One way to solve this is a scheme in which the lists of adjacent faces are “padded” in some manner, so that they are all the same length. This is cumbersome.\nInstead, let us split all “cell-based” quantities into contributions from “corners”, i.e., half-edges, like this:\n Source: CGAL\nTo compute the total area, we can sum over all half-edges \\((r,p)\\) opposite to a vertex \\(q\\). Numerically, this can be achieved efficiently using gather/scatter operations.\n\nsource\n\n\nsum_he_to_vertex_opposite\n\ndef sum_he_to_vertex_opposite(\n    hemesh:HeMesh, he_field:Float[Array, 'n_hes ...']\n):\n\nSum a half-edge field onto opposite vertices.\nhemesh: connectivity information he_field: (n_hes,) or (n_hes, d) array\n\nsource\n\n\nsum_he_to_vertex_incoming\n\ndef sum_he_to_vertex_incoming(\n    hemesh:HeMesh, he_field:Float[Array, 'n_hes ...']\n):\n\nSum a half-edge field onto destination vertices.\nhemesh: connectivity information he_field: (n_hes,) or (n_hes, d) array\n\n# TO DO: implement gradient (vertex -&gt; face) and cotan-Laplacian (vertex -&gt; vertex) using gather/scatter ops like above .\n# compare with igl to check correctness.\n\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\ngeommesh = GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\nsource\n\n\nget_cell_areas\n\ndef get_cell_areas(\n    geommesh:GeomMesh, hemesh:HeMesh\n)-&gt;Float[Array, 'n_vertices']:\n\nCompute areas of cells by mesh traversal (don’t use for simulation, inefficient).\nBoundary vertices get area 0.\n\n## Let's use the adjacency matrix to compute the area of all cells. First, compute all corner areas\n\na, b, c = (hemesh.dest[hemesh.nxt], hemesh.dest[hemesh.prv], hemesh.dest)\n\ncorner_areas = jax.vmap(trig.get_voronoi_corner_area)(geommesh.vertices[a], geommesh.vertices[b], geommesh.vertices[c])\ncell_areas_corner = sum_he_to_vertex_opposite(hemesh, corner_areas)\ncell_areas_corner = cell_areas_corner.at[hemesh.is_bdry].set(0)\n\n\n# for comparison, compute the areas by mesh traversal\n\ncell_areas_iterative = -1*get_cell_areas(geommesh, hemesh)\nnp.abs(cell_areas_iterative-cell_areas_corner).max() # works!\n\nnp.float64(4.85722573273506e-17)\n\n\n\n# using the gather/scatter trick, we can also compute the coordination number\nsum_he_to_vertex_incoming(hemesh, jnp.ones(hemesh.n_hes)).at[hemesh.is_bdry].set(0)\n\nArray([0., 6., 6., 7., 6., 6., 6., 6., 6., 0., 0., 6., 6., 5., 6., 6., 6.,\n       5., 5., 6., 0., 0., 6., 6., 6., 7., 5., 6., 6., 7., 7., 6., 0., 0.,\n       0., 7., 6., 6., 5., 7., 6., 6., 6., 6., 7., 5., 0., 0., 5., 6., 6.,\n       7., 7., 5., 6., 6., 7., 5., 0., 5., 7., 6., 5., 6., 5., 6., 7., 6.,\n       5., 0., 0., 5., 6., 6., 6., 6., 6., 7., 6., 6., 0., 6., 6., 5., 6.,\n       0., 0., 6., 6., 6., 7., 0., 6., 6., 6., 5., 6., 6., 6., 0., 0., 6.,\n       6., 6., 6., 7., 6., 0., 0., 5., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 6., 6., 6., 6., 6., 6., 0.], dtype=float64)",
    "crumbs": [
      "JAX-compatible data structure triangulations"
    ]
  },
  {
    "objectID": "01_triangulation_datastructure.html#saving-to-disk",
    "href": "01_triangulation_datastructure.html#saving-to-disk",
    "title": "triangulax",
    "section": "Saving to disk",
    "text": "Saving to disk\nWe save and load TriMesh meshes as standard .obj files (with the hack of using vn lines for the face positions). The HeMesh class is basically a collection of arrays, which we can save to disk using numpy.\n\nfrom tempfile import TemporaryFile\n\n\nmesh = TriMesh.read_obj(\"test_meshes/disk.obj\")\nhemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)\n\nWarning: readOBJ() ignored non-comment line 3:\n  o flat_tri_ecmc\n\n\n\n# this is how to use np.savenpz\n\noutfile = TemporaryFile()\n\nx = np.arange(10)\ny = np.sin(x)\n\nnp.savez(outfile, x=x, y=y)\n_ = outfile.seek(0) # simulates closing & reopening file\n\nnpzfile = np.load(outfile)\nsorted(npzfile.files), npzfile['x']\n\n(['x', 'y'], array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]))\n\n\n\noutfile = TemporaryFile()\n\nhemesh.save(outfile)\n_ = outfile.seek(0) # simulates closing & reopening file\nnpzfile = np.load(outfile)\nnpzfile.files\n\n['incident',\n 'orig',\n 'dest',\n 'twin',\n 'nxt',\n 'prv',\n 'heface',\n 'face_incident',\n 'inf_vertices']\n\n\n\noutfile = TemporaryFile()\n\nhemesh.save(outfile)\n_ = outfile.seek(0) # simulates closing & reopening file\nreloaded = HeMesh.load(outfile)\n\nnp.allclose(reloaded.faces, hemesh.faces)\n\nTrue\n\n\n\nNext steps\nLooks good - the JAX-compatible triangular-mesh data structures seem to work. In particular, the tricky T1/edge-flip function. Next steps: toy simulation, notebook 01.",
    "crumbs": [
      "JAX-compatible data structure triangulations"
    ]
  },
  {
    "objectID": "00_trigonometry.html",
    "href": "00_trigonometry.html",
    "title": "triangulax",
    "section": "",
    "text": "For example, the circumcenter of a triangle, which is the position of the dual Voronoi vertex.\n\n\nThroughout, we will (attempt to) provide a type signature for all functions. To do so for array-based functions, we use jaxtyping.\n\n\n\nThe aim is to create a triangulation datastructure compatible with the JAX library for automatic differentiation and numerical computing. In practice, this means that we use jnp (=jax.numpy) instead of numpy, and make sure our code follows JAX’s functional programming paradigm (see JAX- the sharp bits). There is also some extra legwork to register any new classes with JAX.\n\nsource\n\n\n\n\ndef get_rot_mat(\n    theta:float\n)-&gt;Float[Array, '2 2']:\n\nGet rotation matrix from angle in radians.\n\nsource\n\n\n\n\ndef get_angle_between_vectors(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim']\n)-&gt;Float[Array, '']:\n\nAngle between two vectors\n\nsource\n\n\n\n\ndef get_voronoi_corner_perimeter(\n    a:Float[Array, '2'], b:Float[Array, '2'], c:Float[Array, '2'], epsilon:float=1e-06\n)-&gt;Float[Array, '']:\n\nCompute contribution to Voronoi perimeter at corner a of triangle abc. Can be negative! 2d only atm.\n\nsource\n\n\n\n\ndef get_voronoi_corner_area(\n    a:Float[Array, '2'], b:Float[Array, '2'], c:Float[Array, '2'], epsilon:float=1e-06\n)-&gt;Float[Array, '']:\n\nCompute Voronoi area at corner a of triangle abc. Returns zero for a degenerate triangle. 2d only atm.\n\nsource\n\n\n\n\ndef get_polygon_area(\n    pts:Float[Array, 'n_vertices 2']\n)-&gt;Float[Array, '']:\n\nArea of 2D polygon assuming no self-intersection.\n\nsource\n\n\n\n\ndef get_triangle_area(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim'], c:Float[Array, 'dim']\n)-&gt;Float[Array, '']:\n\nArea of triangle with vertices a, b, c. Works in any dimension &gt;=2.\n\nsource\n\n\n\n\ndef get_circumcenter(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim'], c:Float[Array, 'dim']\n)-&gt;Float[Array, 'dim']:\n\nReturn circumcenter coordinates of triangle with vertices a, b, c\n\nget_voronoi_corner_perimeter(jnp.array([0., 0.]), jnp.array([1., 0.]), jnp.array([0., 1.]))\n\nArray(1., dtype=float64)\n\n\n\nget_polygon_area(jnp.array([[0.,0.], [0.,1.], [1.,0.]]) ), get_triangle_area(*jnp.array([[0.,0.], [0.,1.], [1.,0.]]) )\n\n(Array(0.5, dtype=float64), Array(0.5, dtype=float64))\n\n\n\nget_voronoi_corner_area(jnp.array([0.,0.]), jnp.array([0.,1.]),  jnp.array([1.,0.]))\n\nArray(-0.25, dtype=float64)\n\n\n\nget_circumcenter(jnp.array([0.,0.]), jnp.array([0.,1.]),  jnp.array([1.,0.]))\n\nArray([0.5, 0.5], dtype=float64)\n\n\n\nget_circumcenter(jnp.array([1.,0.]), jnp.array([1.,0.]),  jnp.array([0.,1.]))\n\nArray([nan, nan], dtype=float64)\n\n\n\njnp.cross(jnp.array([1,0]), jnp.array([0, 1]) )\n\nArray(1, dtype=int64)\n\n\n\njnp.cross(jnp.array([1,0,0]), jnp.array([0, 1, 0]) )\n\nArray([0, 0, 1], dtype=int64)",
    "crumbs": [
      "Basic trigonometry"
    ]
  },
  {
    "objectID": "00_trigonometry.html#basic-trigonometry",
    "href": "00_trigonometry.html#basic-trigonometry",
    "title": "triangulax",
    "section": "",
    "text": "For example, the circumcenter of a triangle, which is the position of the dual Voronoi vertex.\n\n\nThroughout, we will (attempt to) provide a type signature for all functions. To do so for array-based functions, we use jaxtyping.\n\n\n\nThe aim is to create a triangulation datastructure compatible with the JAX library for automatic differentiation and numerical computing. In practice, this means that we use jnp (=jax.numpy) instead of numpy, and make sure our code follows JAX’s functional programming paradigm (see JAX- the sharp bits). There is also some extra legwork to register any new classes with JAX.\n\nsource\n\n\n\n\ndef get_rot_mat(\n    theta:float\n)-&gt;Float[Array, '2 2']:\n\nGet rotation matrix from angle in radians.\n\nsource\n\n\n\n\ndef get_angle_between_vectors(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim']\n)-&gt;Float[Array, '']:\n\nAngle between two vectors\n\nsource\n\n\n\n\ndef get_voronoi_corner_perimeter(\n    a:Float[Array, '2'], b:Float[Array, '2'], c:Float[Array, '2'], epsilon:float=1e-06\n)-&gt;Float[Array, '']:\n\nCompute contribution to Voronoi perimeter at corner a of triangle abc. Can be negative! 2d only atm.\n\nsource\n\n\n\n\ndef get_voronoi_corner_area(\n    a:Float[Array, '2'], b:Float[Array, '2'], c:Float[Array, '2'], epsilon:float=1e-06\n)-&gt;Float[Array, '']:\n\nCompute Voronoi area at corner a of triangle abc. Returns zero for a degenerate triangle. 2d only atm.\n\nsource\n\n\n\n\ndef get_polygon_area(\n    pts:Float[Array, 'n_vertices 2']\n)-&gt;Float[Array, '']:\n\nArea of 2D polygon assuming no self-intersection.\n\nsource\n\n\n\n\ndef get_triangle_area(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim'], c:Float[Array, 'dim']\n)-&gt;Float[Array, '']:\n\nArea of triangle with vertices a, b, c. Works in any dimension &gt;=2.\n\nsource\n\n\n\n\ndef get_circumcenter(\n    a:Float[Array, 'dim'], b:Float[Array, 'dim'], c:Float[Array, 'dim']\n)-&gt;Float[Array, 'dim']:\n\nReturn circumcenter coordinates of triangle with vertices a, b, c\n\nget_voronoi_corner_perimeter(jnp.array([0., 0.]), jnp.array([1., 0.]), jnp.array([0., 1.]))\n\nArray(1., dtype=float64)\n\n\n\nget_polygon_area(jnp.array([[0.,0.], [0.,1.], [1.,0.]]) ), get_triangle_area(*jnp.array([[0.,0.], [0.,1.], [1.,0.]]) )\n\n(Array(0.5, dtype=float64), Array(0.5, dtype=float64))\n\n\n\nget_voronoi_corner_area(jnp.array([0.,0.]), jnp.array([0.,1.]),  jnp.array([1.,0.]))\n\nArray(-0.25, dtype=float64)\n\n\n\nget_circumcenter(jnp.array([0.,0.]), jnp.array([0.,1.]),  jnp.array([1.,0.]))\n\nArray([0.5, 0.5], dtype=float64)\n\n\n\nget_circumcenter(jnp.array([1.,0.]), jnp.array([1.,0.]),  jnp.array([0.,1.]))\n\nArray([nan, nan], dtype=float64)\n\n\n\njnp.cross(jnp.array([1,0]), jnp.array([0, 1]) )\n\nArray(1, dtype=int64)\n\n\n\njnp.cross(jnp.array([1,0,0]), jnp.array([0, 1, 0]) )\n\nArray([0, 0, 1], dtype=int64)",
    "crumbs": [
      "Basic trigonometry"
    ]
  }
]