# Area-perimeter self-propelled Voronoi model


After the toy example of notebook 02, let’s try to implement a slightly
more complicated model, the self-propelled Voronoi area-perimeter
Voronoi (VAP) model of [Bi et al.,
2016](https://journals.aps.org/prx/abstract/10.1103/PhysRevX.6.021011).
This 2D model comprises most of the ingredients we will see in more
general simulations, from a coding perspective.

In brief, in the VAP, cells are modeled as the Voronoi tesselation for a
series of centroids **v**<sub>*i*</sub> (our triangulation vertices).
Their overdamped dynamics comprises two terms: self-propulsion and
relaxation of an elastic energy:
$$\partial_t \mathbf{v}\_i = -\nabla\_{\mathbf{v}\_i} E\_{AP} + v_0 \hat{\mathbf{n}}\_i$$
For each cell *i*, $\hat{\mathbf{n}}\_i$ is a unit vector (so we will
represent it by an angle *θ*<sub>*i*</sub>) that determines the
direction of motion. Units of time are chosen so that the coefficient of
∇*E*<sub>*A**P*</sub> is 1. The energy is defined in terms of the
Voronoi area *a*<sub>*i*</sub> and Voronoi perimeter *p*<sub>*i*</sub>
of each cell:
*E*<sub>*A**P*</sub> = ∑<sub>*i*</sub>*k*<sub>*a*</sub>(*a*<sub>*i*</sub> − *a*<sub>0</sub>)<sup>2</sup> + *k*<sub>*p*</sub>(*p*<sub>*i*</sub> − *p*<sub>0</sub>)<sup>2</sup>
where *k*<sub>*a*</sub>, *k*<sub>*p*</sub> are elastic constants, and
*a*<sub>0</sub>, *p*<sub>0</sub> are the target area and perimeter. They
define the “shape index” $s_0= p_0/\sqrt{a_0}$. The key physics is that
above a critical shape index *s*<sub>0</sub><sup>\*</sup>, the model has
a degenerate set of ground states, since for a large *p*<sub>0</sub>,
there are many polygons with the given target area and perimeter (think
floppy balloon).

The orientation *θ*<sub>*i*</sub> of each cell is also dynamic. It
undergoes rotational diffusion:
*d**θ*<sub>*i*</sub> = *D*<sub>*θ*</sub>*d**W*<sub>*t*, *i*</sub>
where *d**W*<sub>*t*, *i*</sub> is Brownian motion, independent for each
cell *i*, and *D*<sub>*θ*</sub> is the diffusion constant.

#### Numerics

The cell array connectivity will be represented by a
[`HeMesh`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#hemesh)
(see notebook 01). The geometry is fully described by the triangulation
vertex positions, the Voronoi cell centroids. We also need a scalar
vertex attribute for the angle *θ*<sub>*i*</sub>.

To numerically calculate the energy *E*<sub>*A**P*</sub>, we can obtain
Voronoi area and perimeter for each mesh “corner” using the
`triangulax.trigonometry` module. Then we can use the gather/scatter
operation `triangulax.meshsum_he_to_vertex_opposite` to sum all corners
belonging to a cell (see notebook 01, “Computing cell areas, perimeters,
etc via corners”). Boundary cells can be handled by “mirroring”, i.e.,
all corners count twice when computing the area/perimeter. Given the
energy, JAX autodiff gives us the gradients.

To time-evolve the mesh geometry, we can use `diffrax`, like in notebook
02. `diffrax` can also deal with SDEs, like the Langevin equation for
cell angles. After each timestep, we need to check if the Voronoi edge
lengths are below some threshold (the edge lengths can be computed on
the fly), and, if so, we need to carry out edge flips. See notebook 01.
We need to ensure that we do not immidiately “re-flip” an edge. This
could be done, for example, via “cool down” period (an edge flipped at
step *t* cannot be flipped again for the next few steps), or by
calculating if the edge is shrinking or growing.

It would also be great to generate some visualizations of the time
evolution of the mesh using the
[`cellplot`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#cellplot)
function, maybe with a user-controlled slider to show the different time
steps.

The code should respect the coding style (JAX-compatibility, type hints,
etc) used in previous notebooks. To start, let’s define the energy and
check that relaxation of the energy leads to a state where the
*a*<sub>*i*</sub> = *a*<sub>0</sub> and
*p*<sub>*i*</sub> = *p*<sub>0</sub> constraints are fullfilled (as good
as possible).

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

### Setup

``` python
import copy
import dataclasses
from typing import Tuple

import numpy as np

import matplotlib.pyplot as plt
import ipywidgets as widgets

import jax
import jax.numpy as jnp

import functools

import diffrax
import lineax

from jaxtyping import Float, Bool, Int
from enum import IntEnum

from tqdm.notebook import tqdm
```

``` python
jax.config.update("jax_enable_x64", True)
jax.config.update("jax_debug_nans", True)
jax.config.update("jax_log_compiles", False)
```

``` python
from triangulax import mesh as msh
from triangulax.mesh import TriMesh, HeMesh, GeomMesh
from triangulax import trigonometry as trig
```

``` python
from importlib import reload

#reload(msh)
reload(trig)
```

    <module 'triangulax.trigonometry' from '/Users/nc1333/Documents/Princeton/Coding/triangulax/triangulax/trigonometry.py'>

### Read in test data

``` python
mesh = TriMesh.read_obj("test_meshes/disk.obj")
hemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)
geommesh = GeomMesh(*hemesh.n_items, vertices=mesh.vertices)
geommesh = msh.set_voronoi_face_positions(geommesh, hemesh)

hemesh, geommesh
```

    Warning: readOBJ() ignored non-comment line 3:
      o flat_tri_ecmc

    (HeMesh(N_V=131, N_HE=708, N_F=224), GeomMesh(D=2,N_V=131, N_HE=708, N_F=224))

    Warning: readOBJ() ignored non-comment line 3:
      o flat_tri_ecmc

    (HeMesh(N_V=131, N_HE=708, N_F=224), GeomMesh(D=2,N_V=131, N_HE=708, N_F=224))

``` python
fig, ax = plt.subplots(figsize=(4, 4))
ax.add_collection(msh.cellplot(hemesh, geommesh.face_positions,
                               cell_colors=np.array([0.7, 0.7, 0.9, 0.4]),
                               mpl_polygon_kwargs={"lw": 0.5, "ec": "k"}))
ax.set_aspect("equal")
ax.autoscale_view();
```

![](03_area_perimeter_model_files/figure-commonmark/cell-7-output-1.png)

## Voronoi cell geometry (area & perimeter)

We compute areas from corner contributions and perimeters from dual-edge
lengths, using gather/scatter operations on the half-edge mesh. Boundary
cells are handled by mirroring (doubling the area/perimeter).

``` python
@jax.jit
def get_triangle_area(geommesh: GeomMesh, hemesh: HeMesh) ->Float[jax.Array, " n_faces"]:
    """Compute triangle areas."""
    a = hemesh.dest[hemesh.nxt]
    b = hemesh.dest[hemesh.prv]
    c = hemesh.dest
    return jax.vmap(trig.get_triangle_area)(
        geommesh.vertices[a], geommesh.vertices[b], geommesh.vertices[c])

@jax.jit
def get_cell_area(geommesh: GeomMesh, hemesh: HeMesh) ->Float[jax.Array, " n_vertices"]:
    """Compute Voronoi area for each cell."""
    a = hemesh.dest[hemesh.nxt]
    b = hemesh.dest[hemesh.prv]
    c = hemesh.dest
    corner_areas = jax.vmap(trig.get_voronoi_corner_area)(
        geommesh.vertices[a], geommesh.vertices[b], geommesh.vertices[c])
    corner_areas = jnp.where(hemesh.is_bdry_he, 0, corner_areas)
    cell_areas = msh.sum_he_to_vertex_opposite(hemesh, corner_areas)
    cell_areas = jnp.where(hemesh.is_bdry, 2.0 * cell_areas, cell_areas)
    return cell_areas

@jax.jit
def get_cell_perimeter(geommesh: GeomMesh, hemesh: HeMesh) -> Float[jax.Array, " n_vertices"]:
    """Compute Voronoi perimeters for each cell."""
    a = hemesh.dest[hemesh.nxt]
    b = hemesh.dest[hemesh.prv]
    c = hemesh.dest
    corner_perims = jax.vmap(trig.get_voronoi_corner_perimeter)(
        geommesh.vertices[a], geommesh.vertices[b], geommesh.vertices[c])
    corner_perims = jnp.where(hemesh.is_bdry_he, 0, corner_perims)
    cell_perims = msh.sum_he_to_vertex_opposite(hemesh, corner_perims)
    cell_perims = jnp.where(hemesh.is_bdry, 2.0 * cell_perims, cell_perims)
    return cell_perims

@jax.jit
def energy_ap(geommesh: GeomMesh, hemesh: HeMesh, a0: float, p0: float,
              k_a: float = 1.0, k_p: float = 1.0, k_penalty: float=10) -> Float[jax.Array, ""]:
    """Area-perimeter energy for Voronoi cells.
    Adds small penalty for triangles with negative area.
    """
    cell_areas = get_cell_area(geommesh, hemesh)    
    cell_perimeters = get_cell_perimeter(geommesh, hemesh)
    tri_areas = get_triangle_area(geommesh, hemesh)
    a_min = 0.25*(a0/2)
    penality = k_penalty*jnp.where(tri_areas < a_min, k_a * (tri_areas-a_min)**2, 0.0).mean()

    return jnp.mean(k_a * (cell_areas-a0)**2 + k_p * (cell_perimeters-p0)**2) + penality
```

``` python
cell_areas, cell_perimeters = (get_cell_area(geommesh, hemesh), get_cell_perimeter(geommesh, hemesh))

a_mean, p_mean = (cell_areas[~hemesh.is_bdry].mean(), cell_perimeters[~hemesh.is_bdry].mean())
a_mean, p_mean, p_mean/np.sqrt(a_mean)
```

    (Array(0.02756258, dtype=float64),
     Array(0.63463959, dtype=float64),
     Array(3.82267399, dtype=float64))

``` python
get_triangle_area(geommesh, hemesh).mean()*2, a_mean
```

    (Array(0.02669562, dtype=float64), Array(0.02756258, dtype=float64))

``` python
# double check against "manual" area and "perimeter" computation using mesh traversal
```

## Energy relaxation (no self-propulsion)

We first relax the area–perimeter energy to verify that the constraints
are satisfied.

``` python
@jax.jit
def relax_energy_step(geommesh: GeomMesh, hemesh: HeMesh,
              a0: float, p0: float,
              step_size: float = 0.01,
              k_a: float = 1.0, k_p: float = 1.0) -> Tuple[GeomMesh, Float[jax.Array, ""]]:
    loss, grad = jax.value_and_grad(energy_ap)(geommesh, hemesh, a0, p0, k_a, k_p)
    updated_vertices = geommesh.vertices - step_size * grad.vertices
    geommesh_updated = dataclasses.replace(geommesh, vertices=updated_vertices)
    return geommesh_updated, loss


# energy parameters
a0 = a_mean
s0 = 3
p0 = s0*jnp.sqrt(a0)

# relaxation parameters
step_size = 0.02
n_steps = 10000

geommesh_relaxed = copy.copy(geommesh)
losses = []

for _ in range(n_steps):
    geommesh_relaxed, loss = relax_energy_step(geommesh_relaxed, hemesh, a0, p0, step_size=step_size)
    losses.append(loss)

losses = jnp.array(losses)
```

``` python
fig = plt.figure(figsize=(4, 3))
plt.plot(np.asarray(losses))
plt.xlabel("step")
plt.ylabel("energy");
```

![](03_area_perimeter_model_files/figure-commonmark/cell-13-output-1.png)

``` python
geommesh_relaxed = msh.set_voronoi_face_positions(geommesh_relaxed, hemesh)

fig, ax = plt.subplots(figsize=(4, 4))
ax.add_collection(msh.cellplot(hemesh, geommesh.face_positions,
                               cell_colors=np.array([0.7, 0.7, 0.9, 0.2]),
                               mpl_polygon_kwargs={"lw": 0.5, "ec": "tab:blue"}))
ax.add_collection(msh.cellplot(hemesh, geommesh_relaxed.face_positions,
                               cell_colors=np.array([0.9, 0.6, 0.6, 0.2]),
                               mpl_polygon_kwargs={"lw": 0.5, "ec": "tab:red"}))
ax.set_aspect("equal")
ax.autoscale_view();
```

![](03_area_perimeter_model_files/figure-commonmark/cell-14-output-1.png)

``` python
areas_relaxed, perim_relaxed = (get_cell_area(geommesh, hemesh), get_cell_perimeter(geommesh, hemesh))
jnp.abs(areas_relaxed - a0)[hemesh.is_bdry].mean(), jnp.abs(perim_relaxed - p0)[hemesh.is_bdry].mean()
```

    (Array(0.00400013, dtype=float64), Array(0.12046733, dtype=float64))

### Relaxation with T1s

Next, let’s allow T1s. To ensure we don’t flip the same edge multiple
times, let’s use a cooldown period.

``` python
cooldown_steps = 5
l_min_T1 = 0.0

n_steps = 10000
cooldown_counter = jnp.zeros(hemesh.n_hes)
sim_steps = jnp.arange(n_steps)
```

# this is the simulation as a simple for loop:

hemesh_relaxed = copy.copy(hemesh) geommesh_relaxed =
copy.copy(geommesh) losses = \[\] flip_count = \[\] for \_ in
tqdm(sim_steps): \# step energy geommesh_relaxed, loss =
relax_energy_step(geommesh_relaxed, hemesh_relaxed, a0, p0,
step_size=step_size) \# compute signed edge lengths, flip, and update
cooldown counter face_positions =
msh.get_voronoi_face_positions(geommesh_relaxed.vertices,
hemesh_relaxed) edge_lengths =
msh.get_signed_dual_he_length(geommesh_relaxed.vertices, face_positions,
hemesh_relaxed) to_flip = (edge_lengths \< l_min_T1) & (cooldown_counter
== 0) hemesh_relaxed = msh.flip_all(hemesh_relaxed, to_flip)
cooldown_counter = jnp.where(to_flip, cooldown_steps,
jnp.clip(cooldown_counter-1, 0)) losses.append(loss)
flip_count.append(to_flip.sum())

losses = jnp.array(losses) flip_count = jnp.array(flip_count)

``` python
# package simulation time step into a function for jax.lax.scan
@jax.jit
def scan_fun(carry: Tuple[GeomMesh,HeMesh, Int[jax.Array, " n_steps"]], x: Float[jax.Array, " n_steps"]):
    geommesh_relaxed, hemesh_relaxed, cooldown_counter = carry
    # step energy
    geommesh_relaxed, loss = relax_energy_step(geommesh_relaxed, hemesh_relaxed, a0, p0, step_size=step_size)
    # compute signed edge lengths, flip, and update cooldown counter
    face_positions = msh.get_voronoi_face_positions(geommesh_relaxed.vertices, hemesh_relaxed)
    edge_lengths = msh.get_signed_dual_he_length(geommesh_relaxed.vertices, face_positions, hemesh_relaxed)
    to_flip = (edge_lengths < l_min_T1) & (cooldown_counter == 0)
    hemesh_relaxed = msh.flip_all(hemesh_relaxed, to_flip)
    # update cooldown counter
    cooldown_counter = jnp.where(to_flip, cooldown_steps, jnp.clip(cooldown_counter-1, 0))
    return (geommesh_relaxed, hemesh_relaxed, cooldown_counter), jnp.array([loss, to_flip.sum()])
```

``` python
init = (geommesh, hemesh, cooldown_counter)
(geommesh_relaxed, hemesh_relaxed, _), return_arr = jax.lax.scan(scan_fun, init, sim_steps) 

losses, flip_count = return_arr.T
```

``` python
fig = plt.figure(figsize=(4, 3))
plt.plot(losses[::int(n_steps/1000)])
plt.xlabel("step")
plt.ylabel("energy")

# add a twin y axis that shows the cummulative number of flips
ax2 = plt.gca().twinx()
ax2.plot(jnp.cumsum(flip_count)[::int(n_steps/1000)], color="orange")
ax2.set_ylabel("cumulative flips", color="orange")
ax2.set_ylim([0,flip_count.sum()+1])
```

![](03_area_perimeter_model_files/figure-commonmark/cell-19-output-1.png)

``` python
geommesh_relaxed = msh.set_voronoi_face_positions(geommesh_relaxed, hemesh_relaxed)

fig, ax = plt.subplots(figsize=(4, 4))
ax.add_collection(msh.cellplot(hemesh, geommesh.face_positions,
                               cell_colors=np.array([0.7, 0.7, 0.9, 0.2]),
                               mpl_polygon_kwargs={"lw": 0.5, "ec": "tab:blue"}))
ax.add_collection(msh.cellplot(hemesh_relaxed, geommesh_relaxed.face_positions,
                               cell_colors=np.array([0.9, 0.6, 0.6, 0.2]),
                               mpl_polygon_kwargs={"lw": 0.5, "ec": "tab:red"}))
ax.set_aspect("equal")
ax.autoscale_view();
```

![](03_area_perimeter_model_files/figure-commonmark/cell-20-output-1.png)

``` python
areas_relaxed, perim_relaxed = (get_cell_area(geommesh, hemesh), get_cell_perimeter(geommesh, hemesh))
jnp.abs(areas_relaxed - a0)[~hemesh.is_bdry].mean()/a0, jnp.abs(perim_relaxed - p0)[~hemesh.is_bdry].mean()/p0
```

    (Array(0.09045905, dtype=float64), Array(0.27422466, dtype=float64))

### Simulation loops with `jax.lax.scan`

In our simulations, we generally start with an initial state (call it
`init`), do a series of timesteps (via a function `make_step(state)`),
and record some “measurement” at each timestep (via a `measure(state)`
function). As a result, we get a timeseries of measurements, and the
final simulation state. In normal python, you would do that with a `for`
loop. When working with JAX, we need to [replace control-flow operations
like `for` with their JAX
pendant](https://docs.jax.dev/en/latest/control-flow.html). For for
loops, this is `jax.lax.scan(f, init, xs)`, which is equivalent to the
python code

``` python
def scan(f, init, xs):
  carry = init
  ys = []
  for x in xs:
    carry, y = f(carry, x)
    ys.append(y)
  return carry, np.stack(ys)
```

In our pattern, `xs` is the vector of time-points `timepoints`, and the
“scanning-function” `f` is generally comprised of two parts, a time-step
and a measurement/logging step (above, we logged energy and T1 count):

``` python
def f(carry, t):
    new_state = make_step(carry, t)
    measurements = measure(new_state)
    return new_state, measurements
```

The `carry` variable contains all information about the state of the
simulation. Typically, `carry` is also composed of multiple pieces
(above, the physical state `geommesh_relaxed, hemesh_relaxed`, as well
as ancilliary variables like `cooldown_counter`, or the ODE solver
state). In order to keep things organized, it can make sense to define
dataclasses for the simulation state and the measurements, like this
(schematic) example:

``` python
@jax.tree_util.register_dataclass
@dataclass
class SimState:
    g: msh.GeomMesh
    h: msh.HeMesh
    solver_state: dict  # or another PyTree
    current_time: jax.Array

@jax.tree_util.register_dataclass
@dataclass
class Log:
    energy: float
    T1_count: int


def scan_function(carry: SimState, next_time: jax.Array) -> tuple[SimState, Log]:
    g, h, solver_state = make_step(carry.g, carry.h, carry.solver_state,
                                   carry.current_time, next_time)
    log = Log(energy=compute_energy(g, h), area=detect_T1s(h))
    return SimState(g, h, solver_state), log

timepoints = jnp.arange(t0, t1, dt)
init = ... # define initial condition
final_state, measurements = jax.lax.scan(scan_function, init, timepoints) 
```

### Using a `diffrax` solver

Note that to use, say, an adaptive time stepping algorithm, we would
need to pass the current time step via the `carry` of `jax.lax.scan` to
the next timestep. We would probably also like to return the timesteps
taken, then.

``` python
# Diffrax-based relaxation step (replaces forward Euler inside the scan)
@jax.jit
def ap_vector_field(
    t: Float[jax.Array, ""],
    y: GeomMesh,
    args: Tuple[HeMesh, float, float, float, float],
    ) -> GeomMesh:
    """RHS for overdamped relaxation of area-perimeter energy."""
    hemesh, a0, p0, k_a, k_p = args
    grad = jax.grad(energy_ap)(y, hemesh, a0, p0, k_a, k_p)
    return jax.tree_util.tree_map(lambda x: -x, grad)

term = diffrax.ODETerm(ap_vector_field)
solver = diffrax.Tsit5()

dt = 0.02
step_times = dt * jnp.arange(n_steps + 1)
```

``` python
@jax.jit
def scan_fun_diffrax(
    carry: Tuple[
        GeomMesh,
        HeMesh,
        Float[jax.Array, " n_hes"],
        Float[jax.Array, ""], # current time
        object, # solver state
    ],
    tnext: Float[jax.Array, ""],
    ) -> Tuple[
        Tuple[
            GeomMesh,
            HeMesh,
            Float[jax.Array, " n_hes"],
            Float[jax.Array, ""],
            object,
        ],
        Float[jax.Array, " 2"],
    ]:
    geommesh_relaxed, hemesh_relaxed, cooldown_counter, tprev, solver_state = carry
    args = (hemesh_relaxed, a0, p0, 1.0, 1.0)
    geommesh_relaxed, _, _, solver_state, _ = solver.step(
        term, tprev, tnext, geommesh_relaxed, args, solver_state, made_jump=False
    )
    loss = energy_ap(geommesh_relaxed, hemesh_relaxed, a0, p0)
    face_positions = msh.get_voronoi_face_positions(geommesh_relaxed.vertices, hemesh_relaxed)
    edge_lengths = msh.get_signed_dual_he_length(geommesh_relaxed.vertices, face_positions, hemesh_relaxed)
    to_flip = (edge_lengths < l_min_T1) & (cooldown_counter == 0)
    hemesh_relaxed = msh.flip_all(hemesh_relaxed, to_flip)
    cooldown_counter = jnp.where(to_flip, cooldown_steps, jnp.clip(cooldown_counter - 1, 0))
    return (geommesh_relaxed, hemesh_relaxed, cooldown_counter, tnext, solver_state), jnp.array([loss, to_flip.sum()])
```

``` python
init_solver_state = solver.init(term, step_times[0], step_times[1], geommesh, (hemesh, a0, p0, 1.0, 1.0))
init = (geommesh, hemesh, cooldown_counter, step_times[0], init_solver_state)
```

``` python
(geommesh_relaxed, hemesh_relaxed, _, _, _), return_arr = jax.lax.scan(
    scan_fun_diffrax, init, step_times[1:])
losses, flip_count = return_arr.T
```

``` python
fig = plt.figure(figsize=(4, 3))
plt.plot(losses[::int(n_steps/1000)])
plt.xlabel("step")
plt.ylabel("energy")

ax2 = plt.gca().twinx()
ax2.plot(jnp.cumsum(flip_count)[::int(n_steps/1000)], color="orange")
ax2.set_ylabel("cumulative flips", color="orange")
ax2.set_ylim([0, flip_count.sum() + 1])
```

![](03_area_perimeter_model_files/figure-commonmark/cell-26-output-1.png)

``` python
geommesh_relaxed = msh.set_voronoi_face_positions(geommesh_relaxed, hemesh_relaxed)

fig, ax = plt.subplots(figsize=(4, 4))
ax.add_collection(msh.cellplot(hemesh, geommesh.face_positions,
                               cell_colors=np.array([0.7, 0.7, 0.9, 0.2]),
                               mpl_polygon_kwargs={"lw": 0.5, "ec": "tab:blue"}))
ax.add_collection(msh.cellplot(hemesh_relaxed, geommesh_relaxed.face_positions,
                               cell_colors=np.array([0.9, 0.6, 0.6, 0.2]),
                               mpl_polygon_kwargs={"lw": 0.5, "ec": "tab:red"}))
ax.set_aspect("equal")
ax.autoscale_view();
```

![](03_area_perimeter_model_files/figure-commonmark/cell-27-output-1.png)

## Overdamped dynamics with self-propulsion (deterministic)

Next, let’s add the self-propulsion term. We initialize the angles
*θ*<sub>*i*</sub> at random. We can store the angles as an extra
`vertex_attrib` in our `geommesh`, using the functionality of the
[`GeomMesh`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#geommesh)
dataclass. We already have an `IntEnum` which we can use as keys to the
`vertex_attrib` dictionary, like described in notebook 01.

As a first step, we can keep the orientations fixed and just integrate
$\partial_t \mathbf{v}\_i = -\nabla\_{\mathbf{v}\_i} E\_{AP} + v_0\hat{\mathbf{n}}\_i$,
like in the above example. We only simulate for a couple of steps.

``` python
class VertexAttribs(IntEnum):
    SELF_PROPULSION_ORIENTATION = 1
```

``` python
jax.config.update("jax_disable_jit", False)
```

``` python
# initialize orientations and store as a vertex attribute
key = jax.random.key(0)
theta0 = jax.random.uniform(key, shape=(hemesh.n_vertices,), minval=0.0, maxval=2*jnp.pi)
#theta0 = theta0 + 0.3 * 2*jnp.pi*jnp.ones(hemesh.n_vertices)

geommesh_sp = copy.copy(geommesh)
geommesh_sp = dataclasses.replace(
    geommesh_sp,
    vertex_attribs={VertexAttribs.SELF_PROPULSION_ORIENTATION: theta0},
)

@jax.jit
def ap_selfprop_vector_field(
    t: Float[jax.Array, ""],
    y: GeomMesh,
    args: Tuple[HeMesh, float, float, float, float, float],
) -> GeomMesh:
    """RHS for overdamped area-perimeter dynamics with self-propulsion."""
    hemesh, a0, p0, v0, k_a, k_p = args
    theta = y.vertex_attribs[VertexAttribs.SELF_PROPULSION_ORIENTATION]
    grad = jax.grad(energy_ap)(y, hemesh, a0, p0, k_a, k_p)
    n_hat = jnp.stack([jnp.cos(theta), jnp.sin(theta)], axis=-1)
    velocity = -grad.vertices + jnp.where(hemesh.is_bdry[:,None], 0, v0 * n_hat)
    zero_vertex_attribs = {key: jnp.zeros_like(val) for key, val in y.vertex_attribs.items()}
    return dataclasses.replace(
        y,
        vertices=velocity,
        vertex_attribs=zero_vertex_attribs,
    )

term_sp = diffrax.ODETerm(ap_selfprop_vector_field)
solver_sp = diffrax.Euler() #Tsit5

dt_sp = 0.01
n_steps_sp = 20000 # begins to fail at some point
v0_sp = 0.001
step_times_sp = dt_sp * jnp.arange(n_steps_sp + 1)

cooldown_steps = 2
```

``` python
# check magnitude of the gradient forces vs the self-propulsion 

grad0 = jax.grad(energy_ap)(geommesh_sp, hemesh, a0, p0, 1, 1).vertices
sp0 = v0_sp*jnp.stack([jnp.cos(theta0), jnp.sin(theta0)], axis=-1)

jnp.linalg.norm(sp0, axis=-1).mean() / jnp.linalg.norm(grad0, axis=-1).mean()
```

    Array(0.31473995, dtype=float64)

``` python
@jax.jit
def scan_fun_selfprop(
    carry: Tuple[GeomMesh,
                 HeMesh,
                 Float[jax.Array, " n_hes"],
                 Float[jax.Array, ""],
                 object,],
    tnext: Float[jax.Array, ""],
) -> Tuple[
    Tuple[GeomMesh,
          HeMesh,
          Float[jax.Array, " n_hes"],
          Float[jax.Array, ""],
          object,],
    GeomMesh]:
    geommesh_curr, hemesh_curr, cooldown_counter, tprev, solver_state = carry
    args = (hemesh_curr, a0, p0, v0_sp, 1.0, 1.0)
    geommesh_next, _, _, solver_state, _ = solver_sp.step(
        term_sp, tprev, tnext, geommesh_curr, args, solver_state, made_jump=False
    )
    face_positions = msh.get_voronoi_face_positions(geommesh_next.vertices, hemesh_curr)
    edge_lengths = msh.get_signed_dual_he_length(geommesh_next.vertices, face_positions, hemesh_curr)
    to_flip = (edge_lengths < l_min_T1) & (cooldown_counter == 0)
    hemesh_next = msh.flip_all(hemesh_curr, to_flip)
    cooldown_counter = jnp.where(to_flip, cooldown_steps, jnp.clip(cooldown_counter - 1, 0))
    return (geommesh_next, hemesh_next, cooldown_counter, tnext, solver_state), geommesh_next
```

``` python
cooldown_counter_sp = jnp.zeros(hemesh.n_hes)
init_solver_state_sp = solver_sp.init(
    term_sp, step_times_sp[0], step_times_sp[1], geommesh_sp, (hemesh, a0, p0, v0_sp, 1.0, 1.0))
init = (geommesh_sp, hemesh, cooldown_counter_sp, step_times_sp[0], init_solver_state_sp)
```

``` python
(geommesh_final, hemesh_final, cooldown, _, _), traj = jax.lax.scan(scan_fun_selfprop, init, step_times_sp[1:])
```

``` python
# unpack the trajectory
traj = msh.tree_unstack(traj)
len(traj)
```

    20000

``` python
geommesh_sp = msh.set_voronoi_face_positions(geommesh_sp, hemesh)
geommesh_final = msh.set_voronoi_face_positions(geommesh_final, hemesh_final)

areas = get_cell_area(geommesh_final, hemesh_final)
edge_lengths = msh.get_signed_dual_he_length(geommesh_final.vertices, geommesh_final.face_positions, hemesh_final)
```

``` python
edge_lengths.min(), areas.min()
```

    (Array(0.01135076, dtype=float64), Array(0.01023393, dtype=float64))

``` python
fig, ax = plt.subplots(figsize=(4, 4))

# plt.triplot(*geommesh_sp.vertices.T, hemesh.faces)

plt.triplot(*geommesh_final.vertices.T, hemesh_final.faces)
#plt.scatter(*geommesh_final.vertices.T, c=areas, cmap="viridis", s=20, vmin=0)

#ax.add_collection(msh.cellplot(hemesh, geommesh_sp.face_positions,
#                               cell_colors=np.array([0.7, 0.7, 0.9, 0.2]),
#                               mpl_polygon_kwargs={"lw": 0.5, "ec": "tab:blue"}))
ax.add_collection(msh.cellplot(hemesh_final, geommesh_final.face_positions,
                               cell_colors=np.array([0.9, 0.6, 0.6, 0.2]),
                               mpl_polygon_kwargs={"lw": 0.5, "ec": "tab:red"}))



ax.set_aspect("equal")
ax.autoscale_view();
```

![](03_area_perimeter_model_files/figure-commonmark/cell-38-output-1.png)

### Stochastic orientation + T1 flips (step-by-step)

We now include rotational diffusion for *θ*<sub>*i*</sub> and perform
edge flips when Voronoi dual edges fall below a threshold. Like before,
a short cooldown avoids immediate re-flips. We can use `diffrax` to
solve the stochastic differential equation for the orientations, like in
[this
tutorial](https://docs.kidger.site/diffrax/usage/getting-started/#stochastic-differential-equations-sdes).
Let’s also implement the “pattern” for simulation loops with
`jax.lax.scan`. We need to make sure that the timestepping for the SDE
and the relaxational dynamics for the vertices is consistent.

Note that the simulation generally diverges if the self-propulsion term
is too strong, due to effects at the boundaries. A more carefull
handling of the boundaries (adding T1s on the boundaries, or using
periodic BCs) is beyond the scope of this notebook.

``` python
# minimal example for solving an SDE, from diffrax tutorial

t0, t1 = 0, 3
dt = 0.05
y0 = 1.0

args = None
drift = lambda t, y, args: -y
diffusion = lambda t, y, args: 0.1 * t


brownian_motion =  diffrax.VirtualBrownianTree(t0, t1, tol=1e-3, shape=(), key=jax.random.PRNGKey(0))
terms = diffrax.MultiTerm(diffrax.ODETerm(drift),  diffrax.ControlTerm(diffusion, brownian_motion))
solver = diffrax.Euler()
saveat = diffrax.SaveAt(dense=True)
```

``` python
sol = diffrax.diffeqsolve(terms, solver, t0, t1, dt0=dt, y0=y0, saveat=saveat)
print(sol.evaluate(1.1))  # DeviceArray(0.89436394)
```

    0.27087012958157025

``` python
# stepping thru the solve one-by-one
state = solver.init(terms, t0, t0+dt, y0, args)
@jax.jit
def sde_step():
    return solver.step(terms, t0, t0+dt, y0, args, state, made_jump=False)
_ = sde_step()
```

``` python
# handling of theta_term is not ideal yet, should be passed somehow as a argument.
# maybe we should use equinox for this, so we can still JIT-compile.

@jax.jit
def apply_t1_flips(
    geommesh: GeomMesh,
    hemesh: HeMesh,
    cooldown_counter: Int[jax.Array, " n_hes"],
    l_min_T1: float,
    cooldown_steps: int,) -> Tuple[HeMesh, Int[jax.Array, " n_hes"], Bool[jax.Array, " n_hes"],]:
    """Apply T1 flips with a per-edge cooldown."""
    face_positions = msh.get_voronoi_face_positions(geommesh.vertices, hemesh)
    edge_lengths = msh.get_signed_dual_he_length(geommesh.vertices, face_positions, hemesh)
    to_flip = (edge_lengths < l_min_T1) & (cooldown_counter == 0)
    hemesh_next = msh.flip_all(hemesh, to_flip)
    cooldown_counter = jnp.where(
        to_flip,
        cooldown_steps,
        jnp.clip(cooldown_counter - 1, 0),)
    return hemesh_next, cooldown_counter, to_flip


@jax.jit
def theta_drift(
    t: Float[jax.Array, ""],
    theta: Float[jax.Array, " n_vertices"],
    args: Float[jax.Array, ""],) -> Float[jax.Array, " n_vertices"]:
    """Drift for orientation angles (zero drift)."""
    return jnp.zeros_like(theta)


@jax.jit
def theta_diffusion(
    t: Float[jax.Array, ""],
    theta: Float[jax.Array, " n_vertices"],
    args: Float[jax.Array, ""],) -> lineax.AbstractLinearOperator:
    """Diffusion operator for orientations (diagonal noise)."""
    d_theta = args
    diagonal = d_theta * jnp.ones_like(theta)
    return lineax.DiagonalLinearOperator(diagonal)


theta_solver = diffrax.EulerHeun()
d_theta: Float[jax.Array, ""] = jnp.asarray(0.5)


def step_theta_sde(
    theta: Float[jax.Array, " n_vertices"],
    tprev: Float[jax.Array, ""],
    tnext: Float[jax.Array, ""],
    d_theta: Float[jax.Array, ""],
    theta_solver_state: object,) -> Tuple[Float[jax.Array, " n_vertices"], object,]:
    """Single SDE step for orientations using diffrax (step-based)."""
    theta_next, _, _, theta_solver_state, _ = theta_solver.step(
        theta_term,
        tprev,
        tnext,
        theta,
        d_theta,
        theta_solver_state,
        made_jump=False,)
    return theta_next, theta_solver_state


@jax.tree_util.register_dataclass
@dataclasses.dataclass
class SDEState:
    geommesh: GeomMesh
    hemesh: HeMesh
    cooldown_counter: Int[jax.Array, " n_hes"]
    tprev: Float[jax.Array, ""]
    solver_state: object
    theta: Float[jax.Array, " n_vertices"]
    theta_solver_state: object


@jax.tree_util.register_dataclass
@dataclasses.dataclass
class SDELog:
    geommesh: GeomMesh
    hemesh: HeMesh
    energy: Float[jax.Array, ""]
    t1_count: Int[jax.Array, ""]

v0_sp = 0.005

@jax.jit
def scan_fun_selfprop_sde(
    state: SDEState,
    tnext: Float[jax.Array, ""],) -> tuple[SDEState, SDELog]:
    # time-step SDE for self-propulsion orientation
    theta_next, theta_solver_state = step_theta_sde(
        state.theta,
        state.tprev,
        tnext,
        d_theta,
        state.theta_solver_state,)
    geommesh_curr = dataclasses.replace(
        state.geommesh,
        vertex_attribs={VertexAttribs.SELF_PROPULSION_ORIENTATION: theta_next,},)
    args = (state.hemesh, a0, p0, v0_sp, 1.0, 1.0,)
    # relaxational dynamics for vertices
    geommesh_next, _, _, solver_state, _ = solver_sp.step(
        term_sp,
        state.tprev,
        tnext,
        geommesh_curr,
        args,
        state.solver_state,
        made_jump=False,)
    # T1 transitions for connectivity
    hemesh_next, cooldown_counter, to_flip = apply_t1_flips(
        geommesh_next,
        state.hemesh,
        state.cooldown_counter,
        l_min_T1,
        cooldown_steps,)
    # make measurements for log
    energy = energy_ap(geommesh_next, hemesh_next, a0, p0)
    log = SDELog(
        geommesh=geommesh_next,
        hemesh=hemesh_next,
        energy=energy,
        t1_count=to_flip.sum(),)
    next_state = SDEState(
        geommesh=geommesh_next,
        hemesh=hemesh_next,
        cooldown_counter=cooldown_counter,
        tprev=tnext,
        solver_state=solver_state,
        theta=theta_next,
        theta_solver_state=theta_solver_state,)
    return next_state, log
```

``` python
brownian.t0, brownian.t1
```

    (Array(0., dtype=float64, weak_type=True),
     Array(150.01, dtype=float64, weak_type=True))

``` python
dt_sde = 0.01
n_steps_sde = 8000
step_times_sde = dt_sde * jnp.arange(n_steps_sde + 1)

cooldown_counter_sde = jnp.zeros(hemesh.n_hes, dtype=jnp.int32)
theta_init = geommesh_sp.vertex_attribs[VertexAttribs.SELF_PROPULSION_ORIENTATION]
key_sde = jax.random.key(1)

init_solver_state_sde = solver_sp.init(
    term_sp,
    step_times_sde[0],
    step_times_sde[1],
    geommesh_sp,
    (hemesh, a0, p0, v0_sp, 1.0, 1.0,),)
brownian = diffrax.VirtualBrownianTree(
    step_times_sde[0],
    step_times_sde[-1] + dt_sde,
    tol=1e-3,
    shape=theta_init.shape,
    key=key_sde,)
theta_term = diffrax.MultiTerm(
    diffrax.ODETerm(theta_drift),
    diffrax.ControlTerm(theta_diffusion, brownian),)
theta_solver_state = theta_solver.init(
    theta_term,
    step_times_sde[0],
    step_times_sde[1],
    theta_init,
    d_theta,)
init_sde = SDEState(
    geommesh=geommesh_sp,
    hemesh=hemesh,
    cooldown_counter=cooldown_counter_sde,
    tprev=step_times_sde[0],
    solver_state=init_solver_state_sde,
    theta=theta_init,
    theta_solver_state=theta_solver_state,)

# Time stepping: scan advances (tprev -> tnext) for both theta and vertex dynamics.
final_state_sde, logs_sde = jax.lax.scan(
    scan_fun_selfprop_sde,
    init_sde,
    step_times_sde[1:],)
geommesh_final_sde = final_state_sde.geommesh
hemesh_final_sde = final_state_sde.hemesh
theta_final_sde = final_state_sde.theta

# Measurements logged at each step: geometry, energy, and T1 flip counts.
geommesh_traj_sde = msh.tree_unstack(logs_sde.geommesh)
hemesh_traj_sde = msh.tree_unstack(logs_sde.hemesh)
flip_counts_sde = logs_sde.t1_count
energies_sde = logs_sde.energy

traj_sde = list(zip(geommesh_traj_sde, hemesh_traj_sde,))
```

### Visualize trajectory

Let’s add an `ipywidget`-based slider plot that allows us to visualize
the trajectory of the mesh’s time evolution.

``` python
np.linalg.norm(geommesh_traj_sde[0].vertices-geommesh_traj_sde[-1].vertices, axis=-1).mean() # avg displacement
```

    np.float64(0.10620549370268782)

``` python
plt.plot(jnp.cumsum(flip_counts_sde))
```

![](03_area_perimeter_model_files/figure-commonmark/cell-46-output-1.png)

``` python
cell_id = 50

plt.plot(logs_sde.geommesh.vertex_attribs[VertexAttribs.SELF_PROPULSION_ORIENTATION][:, cell_id])
```

![](03_area_perimeter_model_files/figure-commonmark/cell-47-output-1.png)

``` python
plt.plot(energies_sde)
```

![](03_area_perimeter_model_files/figure-commonmark/cell-48-output-1.png)

``` python
msh.set_voronoi_face_positions(geommesh_traj_sde[-1], hemesh_traj_sde[-1])
```

    GeomMesh(D=2,N_V=131, N_HE=708, N_F=224)

``` python
fig, ax = plt.subplots(figsize=(4, 4))

#plt.triplot(*geommesh_traj_sde[0].vertices.T, hemesh_traj_sde[0].faces)

#plt.triplot(*geommesh_traj_sde[-1].vertices.T, hemesh_traj_sde[-1].faces)
#plt.scatter(*geommesh_final.vertices.T, c=areas, cmap="viridis", s=20, vmin=0)


geommesh_traj_sde[-1] = msh.set_voronoi_face_positions(geommesh_traj_sde[-1], hemesh_traj_sde[-1])

ax.add_collection(msh.cellplot(hemesh_traj_sde[0], geommesh_traj_sde[0].face_positions,
                               cell_colors=np.array([0.7, 0.7, 0.9, 0.2]),
                               mpl_polygon_kwargs={"lw": 0.5, "ec": "tab:blue"}))
ax.add_collection(msh.cellplot(hemesh_traj_sde[-1], geommesh_traj_sde[-1].face_positions,
                               cell_colors=np.array([0.9, 0.6, 0.6, 0.2]),
                               mpl_polygon_kwargs={"lw": 0.5, "ec": "tab:red"}))



ax.set_aspect("equal")
ax.autoscale_view();
```

![](03_area_perimeter_model_files/figure-commonmark/cell-50-output-1.png)

``` python
def plot_traj_step(step_idx: int) -> None:
    geommesh_i, hemesh_i = traj_sde[step_idx]
    face_positions = msh.get_voronoi_face_positions(geommesh_i.vertices, hemesh_i)
    fig, ax = plt.subplots(figsize=(4, 4))
    ax.add_collection(
        msh.cellplot(
            hemesh_i,
            face_positions,
            cell_colors=np.array([0.7, 0.7, 0.9, 0.25]),
            mpl_polygon_kwargs={"lw": 0.5, "ec": "k"},
        ),
    )
    ax.set_aspect("equal")
    ax.autoscale_view();
```

``` python
widgets.interact(
    plot_traj_step,
    step_idx=widgets.IntSlider(
        value=0,
        min=0,
        max=len(traj_sde) - 1,
        step=1,
        description="step",
        continuous_update=False,
    ),
    )
```

    interactive(children=(IntSlider(value=0, continuous_update=False, description='step', max=9999), Output()), _d…

    <function __main__.plot_traj_step(step_idx: int) -> None>
