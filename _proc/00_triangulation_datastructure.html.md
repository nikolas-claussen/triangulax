<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

::: {#465aee96-fe0c-4994-97a5-d3ba628df4cf .cell execution_count=12}
``` {.python .cell-code}
jax.config.update("jax_enable_x64", True)
jax.config.update("jax_debug_nans", False)
jax.config.update('jax_log_compiles', False) # use this to log JAX JIT compilations.
```
:::



## Data-structure for 2D tissue mechanics simulation

First, we need to create a suitable data structure to describe cell arrays. We will represent cell tilings by 2D Voronoi tessellations and variants thereof (like power diagrams). Cells are denoted by Latin indices $i,j,k, \dots$. Voronoi tessellations are dual to Delaunay triangulations (each Voronoi vertex is a Delaunay triangle). This means that we can represent the cell network as a 2D triangulation with vertices $V$ and faces $F$. Each face is an (ordered) triple of vertices $(i,j,k)$. Vertex positions are denoted $\mathbf{v}_i$.

We will first consider the case where the number of vertices does not change. Cells can, however, rearrange (T1-transitions/edge flips in the triangulation). Such flips also conserve the number of faces and edges. In addition to the vertices and faces, we will need to store various _attributes_ for vertices, faces, and edges (for example, the edge lengths, or the Voronoi position of a face).

### Coding style notes

Throughout, we will (attempt to) provide a type signature for all functions. To do so for array-based functions, we use  [jaxtyping](https://docs.kidger.site/jaxtyping).

### JAX

The aim is to create a triangulation datastructure compatible with the JAX library for automatic differentiation and numerical computing. In practice, this means that we use `jnp` (=`jax.numpy`) instead of `numpy`, and make sure our code follows JAX's functional programming paradigm (see [JAX- the sharp bits](https://docs.jax.dev/en/latest/notebooks/Common_Gotchas_in_JAX.html)). There is also some extra legwork to register any new classes with JAX.

### Basic trigonometry

For example, the circumcenter of a triangle, which is the position of the dual Voronoi vertex.

---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L68){target="_blank" style="float:right; font-size:smaller"}

### get_rot_mat

```python

def get_rot_mat(
    theta:float
)->Float[Array, '2 2']:


```

*Get rotation matrix from angle in radians.*


---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L62){target="_blank" style="float:right; font-size:smaller"}

### get_angle_between_vectors

```python

def get_angle_between_vectors(
    a:Float[Array, 'dim'], b:Float[Array, 'dim']
)->Float[Array, '1']:


```

*Angle between two vectors*


---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L53){target="_blank" style="float:right; font-size:smaller"}

### get_voronoi_corner_area

```python

def get_voronoi_corner_area(
    a:Float[Array, '2'], b:Float[Array, '2'], c:Float[Array, '2'], epsilon:float=1e-06
)->Float[Array, '1']:


```

*Compute Voronoi area at corner a of triangle abc. Returns zero for a degenerate triangle.*


---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L49){target="_blank" style="float:right; font-size:smaller"}

### get_polygon_area

```python

def get_polygon_area(
    pts:Float[Array, 'n_vertices 2']
)->Float[Array, '1']:


```

*Area of 2D polygon assuming no self-intersection.*


---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L39){target="_blank" style="float:right; font-size:smaller"}

### get_circumcenter

```python

def get_circumcenter(
    a:Float[Array, '2'], b:Float[Array, '2'], c:Float[Array, '2']
)->Float[Array, '2']:


```

*Return circumcenter coordinates of triangle with vertices a, b, c*


::: {#b7fb9419-37ca-4e80-870f-bcc96536f8d1 .cell execution_count=22}
``` {.python .cell-code}
get_polygon_area(jnp.array([[0,0], [0,1], [1,0]]) )
```

::: {.cell-output .cell-output-display execution_count=22}
```
Array(0.5, dtype=float64)
```
:::
:::


::: {#b08f86bc-05ea-4843-b4d6-d7a6bfc7ca0e .cell execution_count=23}
``` {.python .cell-code}
get_voronoi_corner_area(jnp.array([0,0]), jnp.array([0,1]),  jnp.array([1,0]))
```

::: {.cell-output .cell-output-display execution_count=23}
```
Array(-0.25, dtype=float64)
```
:::
:::


::: {#73f2dc1d-072d-4c22-9785-282078793ca1 .cell execution_count=24}
``` {.python .cell-code}
get_circumcenter(np.array([0,0]), jnp.array([0,1]),  jnp.array([1,0]))
```

::: {.cell-output .cell-output-display execution_count=24}
```
Array([0.5, 0.5], dtype=float64)
```
:::
:::


::: {#16894cb9-04e7-4ed0-bef9-eddca16e61ba .cell execution_count=25}
``` {.python .cell-code}
get_circumcenter(np.array([1,0]), jnp.array([1,0]),  jnp.array([0,1]))
```

::: {.cell-output .cell-output-display execution_count=25}
```
Array([nan, nan], dtype=float64)
```
:::
:::


### Triangular mesh datastructure

The simplest way to represent a cell tiling is by its _dual_ triangular mesh (one triangulation vertex per cell). Triangles will be denoted as _faces_. We thus represent a cell tiling by:

1. A set of vertices, i.e., a $(N_V, 2)$ dimensional array datatype `float`.
2. A set of faces, a $(N_F, 3)$ dimensional array of datatype `int`. Each row is a triple of vertex indices that form a face.
3. A set of face positions, a $(N_F, 2)$ dimensional array of datatype `float`. An entry is the position of the tesselation vertex dual to the triangulation face.

To read and write, we use the `.obj`-file format. We will also make heavy use of the `igl` geometry processing library. 
We start by defining a minimal [`TriMesh`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#trimesh) class for our cell-tiling objects. This class is mainly a "holder" class for loading, saving, visualizing, etc meshes, and not to be used for numerical computation. We come to that below.

Further below, we will also add optional attributes for faces, vertices, and edges. Each attribute is a dictionary with keys (from an `Enum` of possibilities) and values, which are `numpy` vectors whose $n$th entry corresponds to vertex/face/edge $n$. For this reason, vertices/faces/edges are _ordered_.

---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L74){target="_blank" style="float:right; font-size:smaller"}

### TriMesh

```python

def TriMesh(
    vertices:Float[Array, 'n_vertices dim'], faces:Int[Array, 'n_faces 3'], face_positions:type=None
)->None:


```

*Simple class for reading, holding, transforming, and saving triangular meshes.*

A TriMesh comprises vertices and faces, describing a surface in 2d or 3d. 
In addition, there can be a 2d/3d position for every face (think Voronoi dual of the triangulation).

Vertices and faces are jnp.arrays. Each face is a triple of vertex indices.
Vertices and faces are ordered - this is essential so that we know which attribute
vector entry goes to which vector/edge/face. Faces in a face are assumed to be in counter-clockwise order.

Meshes are read and written in the .obj format (https://en.wikipedia.org/wiki/Wavefront_.obj_file).
To store _face_positions_, we abuse the `vn` (vertex normal) entry of an .obj file. Face
positions will be written in order corresponding to faces.
When reading from an .obj file, edges are recomputed from faces and initialized in alpha-numerical ordering.
An .obj file expects 3d positions; the z-position is ignored when reading and set to 0 when writing for 2d meshes.

**Attributes**

dim : int = 2

vertices : Float[jax.Array, "n_vertices dim"]

faces : Int[jax.Array, "n_faces 3"]

face_positions : Float[jax.Array, "n_faces dim"]

**Property methods (use like attributes)**

n_vertices : int

has_inf_vertex : bool

**Static methods**

read_obj : str -> TriMesh

**Methods**

write_obj : str -> None


::: {#c92469ca-bcb7-424f-ab1a-57391c5c955a .cell execution_count=27}
``` {.python .cell-code}
# test reading a mesh
mesh = TriMesh.read_obj("test_meshes/disk.obj")
```

::: {.cell-output .cell-output-stderr}
```
Warning: readOBJ() ignored non-comment line 3:
  o flat_tri_ecmc
```
:::
:::


::: {#bef6e5d3-ea7d-49de-92ac-ba58c4a08c96 .cell execution_count=28}
``` {.python .cell-code}
# test computing the circumcenter of each face. should be equidistant to all vertex points

dists = jnp.stack([jnp.linalg.norm(mesh.vertices[mesh.faces[:,i]]-mesh.face_positions, axis=1) for i in [0,1,2]], axis=1)

jnp.allclose(dists[:,0], dists[:,1]) and jnp.allclose(dists[:,1], dists[:,2])
```

::: {.cell-output .cell-output-display execution_count=28}
```
Array(True, dtype=bool)
```
:::
:::


::: {#3adefefb-2b1a-4c44-b6c0-8a5e78cdb053 .cell execution_count=29}
``` {.python .cell-code}
# test writing face positions to vn entries

mesh = TriMesh.read_obj("test_meshes/disk.obj")
filename = "test_meshes/disk_write_test.obj"
mesh.write_obj(filename, save_face_positions=True)
mesh = TriMesh.read_obj(filename, read_face_positions=True)
```

::: {.cell-output .cell-output-stderr}
```
Warning: readOBJ() ignored non-comment line 3:
  o flat_tri_ecmc
```
:::
:::


### Creating meshes and plotting

Some functions to create meshes based on the Delaunay triangulation of a point set.

1. Poisson (vertices placed uniformly at random) in disk or box
2. Ginibre (vertices placed at uniform with self-repulsion)
3. Triangular lattice

Some functions for plotting meshes:

1. Plot triangulation with vertex and face labels (for debugging)
2. Plot cell tesselation

---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L216){target="_blank" style="float:right; font-size:smaller"}

### generate_triangular_lattice

```python

def generate_triangular_lattice(
    nx:int, ny:int
)->Float[Array, 'nx*ny 2']:


```

*Get points for rectangular patch of triangular lattice with nx, ny points.*


---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L208){target="_blank" style="float:right; font-size:smaller"}

### generate_poisson_points

```python

def generate_poisson_points(
    n_vertices:int, limit_x:float=1, limit_y:float=1
)->Float[Array, 'n_vertices 2']:


```

*Sample n_vertices points from the Poisson ensemble in rectangle*
[-limit_x/2, limit_x/2] * [-limit_y/2, limit_y/2].


---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L199){target="_blank" style="float:right; font-size:smaller"}

### generate_ginibre_points

```python

def generate_ginibre_points(
    n_vertices:int
)->Float[Array, 'n_vertices 2']:


```

*Sample n_vertices points from the Ginibre ensemble. Points are scaled to unit disk.*


::: {#da57dbe6-026e-4dab-82be-0691e6037d71 .cell execution_count=31}
``` {.python .cell-code}
#points = generate_triangular_lattice(10, 10)

points = generate_ginibre_points(100)
mesh = TriMesh(vertices=points, faces=spatial.Delaunay(points).simplices)

plt.triplot(*points.T, mesh.faces)

plt.scatter(*points.T)
plt.axis("equal")
```

::: {.cell-output .cell-output-display execution_count=31}
```
(np.float64(-1.64480693026874),
 np.float64(1.7587032394949658),
 np.float64(-1.6934760386400838),
 np.float64(1.5982535031597624))
```
:::

::: {.cell-output .cell-output-display}
![](00_triangulation_datastructure_files/figure-html/cell-20-output-2.png){}
:::
:::


### Elementary book-keeping using list-of-triangles data structure

---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L230){target="_blank" style="float:right; font-size:smaller"}

### get_adjacent_vertex_indices

```python

def get_adjacent_vertex_indices(
    faces:Int[Array, 'n_faces 3'], n_vertices:int
)->List:


```

*For each vertex, get the indices of the adjacent vertices in correct order.*
For boundary vertices, this list contains the vertex itself.


::: {#7d5a6c59-59ff-4f56-b743-bc591edd70fd .cell execution_count=33}
``` {.python .cell-code}
mesh = TriMesh.read_obj("test_meshes/disk.obj")

neighbors = get_adjacent_vertex_indices(mesh.faces, n_vertices=mesh.vertices.shape[0])
```

::: {.cell-output .cell-output-stderr}
```
Warning: readOBJ() ignored non-comment line 3:
  o flat_tri_ecmc
```
:::
:::


## Half-edge meshes

For simulation and geometry processing, we need a different representation of the adjacency information than the list of triangle (for example, to compute the area of a cell). Typically, this is achieved by a [half-edge mesh](https://www.jerryyin.info/geometry-processing-algorithms/half-edge/) (HE) data structure. We represent the HE data structure by 3 sets of integer index arrays:

1. Vertices: 1 $(N_V,)$ matrix, whose entry for vertex $i$ is an arbitrary HE incident on $i$
2. Edges: 6 $(2N_E,)$ matrices, [`origin`, `dest`, `nxt`, `prv`, `twin`, `face`] for each half-edge. `face` can be `np.nan` for boundary vertices.
3. Faces, 1 $(N_F, 1)$ matrix, whose entry for face $i$ is an arbitrary HE in $i$. (Not to be confused with the $(N_F, 3)$ matrix of _vertex IDs_ used previously).

Additionally, there are two float arrays for vertex and face positions, as previously. However, we split _combinatorial_ and _geometric_ information - a [`HeMesh`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#hemesh) class for the combinatorics, and a couple of regular arrays for the vertex positions, face positions, and vertex/half-edge/face attributes. The latter are packaged into a [`GeomMesh`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#geommesh) class. Together, the pair `(GeomMesh, HeMesh)` describes a mesh (like vertices/faces). (We can even create a named tuple, something like [`Mesh`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#mesh), that comines the two).

The first task is to create a helper function to plot mesh connectivity, and to create the half-edge connectivity matrices from the more conventional list-of-triangles format. The latter is somewhat involved.

---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L240){target="_blank" style="float:right; font-size:smaller"}

### label_plot

```python

def label_plot(
    vertices:Float[Array, 'n_vertices 2'], faces:Int[Array, 'n_faces 3'], hemesh:type=None, vertex_labels:bool=True,
    face_labels:bool=True, ax:type=None, fontsize:type=None
)->None:


```

*For debugging purposes. Plot triangular mesh with face/vertex labels in black/blue.*
If hemesh is not None, the connectivity info from it is used to plot the half-edge labels.


::: {#4b8abf3e-57c3-4210-9b7a-50ded06d7118 .cell scrolled='true' execution_count=35}
``` {.python .cell-code}
mesh = TriMesh.read_obj("test_meshes/disk.obj")

plt.triplot(*mesh.vertices.T, mesh.faces)
label_plot(mesh.vertices, mesh.faces, fontsize=10)
plt.axis("equal")
```

::: {.cell-output .cell-output-stderr}
```
Warning: readOBJ() ignored non-comment line 3:
  o flat_tri_ecmc
```
:::

::: {.cell-output .cell-output-display execution_count=35}
```
(np.float64(-1.10003475),
 np.float64(1.09628575),
 np.float64(-1.09934025),
 np.float64(1.09050125))
```
:::

::: {.cell-output .cell-output-display}
![](00_triangulation_datastructure_files/figure-html/cell-24-output-3.png){}
:::
:::


---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L266){target="_blank" style="float:right; font-size:smaller"}

### get_half_edge_arrays

```python

def get_half_edge_arrays(
    n_vertices:int, faces:Int[Array, 'n_faces 3']
)->List:


```

*Get half-edge data structure arrays from faces.*

Returns: incident, orig, dest, twin, nxt, prv, heface, face_incident


### JAX compatibility

We want to be compatible with JAX. For this reason, we

1. Always use `jnp` = `jax.numpy` instead of `np`
2. Instead of in-place array modifications, use JAX's `x = x.at[idx].set(y)` syntax
3. _Avoid_ any in-place modifications in the [`HeMesh`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#hemesh) and `GeomHeMesh` data structures
4. _Register_ our (data)classes with JAX, so JAX knows how to handle them during gradient-computation and just-in-time compilation. See [here](https://docs.jax.dev/en/latest/notebooks/Common_Gotchas_in_JAX.html#using-jax-jit-with-class-methods) and [here](https://docs.jax.dev/en/latest/custom_pytrees.html). This involves declaring which parts are mutable and which parts are permanent. 

Lateron, for simulations, we use the `equinox` library, which adds a few useful tools to JAX. (A neural-network library like `flax` is probably overkill).

#### PyTrees

JAX supports not only arrays as inputs/outputs/intermediate variables, but also [pytrees](https://docs.jax.dev/en/latest/pytrees.html). Pytrees are nested structures (dicts, lists-of-lists, etc) whose leaves are "elementary" objects like arrays. Fortunately, our [`HeMesh`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#hemesh) class is already a lot like a pytree - it is a collection of arrays. For JAX to understand this, we need to register our [`HeMesh`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#hemesh) class as a [custom pytree node](https://docs.jax.dev/en/latest/custom_pytrees.html#pytrees-custom-pytree-nodes). We register our dataclasses using `jax.tree_util.register_dataclass`.

Sidenote: Neural networks, in libraries like Flax or Equinox, are basically very similar. They are dataclass-like classes which hold all the arrays associated with a NN (the different weights, and maybe some parameters) with class methods like `__call__` specifying the forward pass through the NN.
Equinox automatically registers your NN as a pytree by inheriting from the `equinox.Module` class.

#### [Control flow](https://docs.jax.dev/en/latest/control-flow.html)

For just-in-time compilation, JAX distinguishes two types of variables: dynamic and static. Control flow cannot depend on the _value_ of dynamic variables, only on their shape.

Upshots:
1. replace `if` with `jax.lax.cond` / `jnp.where` (full autodiff compatible), and `while` with `jax.lax.while_loop` (forward autodiff only).
2. mark variables which are not going to change during simulation as static.

---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L303){target="_blank" style="float:right; font-size:smaller"}

### HeMesh

```python

def HeMesh(
    incident:Int[Array, 'n_vertices'], orig:Int[Array, 'n_hes'], dest:Int[Array, 'n_hes'], twin:Int[Array, 'n_hes'],
    nxt:Int[Array, 'n_hes'], prv:Int[Array, 'n_hes'], heface:Int[Array, 'n_hes'],
    face_incident:Int[Array, 'n_faces'], inf_vertices:Tuple=()
)->None:


```

*Half-edge mesh data structure for triangular meshes.*

A half-edge mesh is described by a set of half-edges and several
arrays that specify their connectivity (see markup explanation above).
This class serves as a container for multiple arrays.
For future compatibility with JAX, after initialization, do not
modify these arrays in-place; always return a new HeMesh object.
The mesh vertices may live in whatever dimension - this
does not affect the connectivity bookkeeping.

Half-edge meshes are initialized from a list of triangles and a 
number of vertices, and can return the original triangles (e.g., to save as a .obj).

All information and methods are purely "combinatorial". The
HeMesh class does _not_ contain the vertex or face positions.
These are saved in the GeomHeMesh class that combines
a HeMesh (combinatorics) with a couple of other arrays (geometry).

---Conventions---

For vertices, the `incident` half-edge points _away_ from the vertex.

To describe the mesh boundary, there are two options:
    1. Initialize from a triangulation with a boundary. Half-edges without
    a face (boundary) are assigned heface=-1.
    2. Initialize from a triangulation without boundary, where certain vertices
     are "at infinity". They should have coordinates [np.inf, np.inf].
     Each infinity vertex corresponds to one boundary. For a single
     boundary, the vertex at infinity is, by convention, the final one.

Starting from a set of triangles, the half-edges are initialized as follows:
The 1st N_edges half-edges are (origin_vertex, destination_vertex), in lexicographic order, with 
origin_vertex < destination_vertex. The 2nd N_edges are their twins, in the same order.

**Attributes**

incident : Int[jax.Array, "n_vertices"]

orig : Int[jax.Array, "n_hes"]

dest : Int[jax.Array, "n_hes"]

nxt : Int[jax.Array, "n_hes"]

prv : Int[jax.Array, "n_hes"]

twin : Int[jax.Array, "n_hes"]

heface : Int[jax.Array, "n_hes"]

face_incident : Int[jax.Array, "n_faces"]

inf_vertices : Tuple[Int]

**Property methods (use like attributes)**

n_vertices : int

n_hes : int

n_faces : int

n_items : Tuple[int, int, int]

faces : Int[jax.Array, "n_faces 3"]

has_inf_vertex : bool

is_inf_face : Bool[jax.Array, "n_faces"]

is_unique : Bool[jax.Array, "n_hes"]

is_inf_he : Bool[jax.Array, "n_hes"]

is_bdry_he : Bool[jax.Array, "n_hes"]

is_bdry_edge : Bool[jax.Array, "n_hes"]

is_bdry : Bool[jax.Array, "n_vertices"]

**Static methods**

from_triangles : Tuple[int, Int[jax.Array, "n_faces 3"], Int[jax.Array, "n_boundaries"] -> HeMesh

**Class methods**

iterate_around_vertex : int -> Int[jax.Array, "n_neighbors"]

save : str -> None:

**Static methods**

load : str -> HeMesh


::: {#5fe4070e-5447-4716-b0da-38adca86b921 .cell execution_count=38}
``` {.python .cell-code}
mesh = TriMesh.read_obj("test_meshes/disk.obj")
hemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)
```

::: {.cell-output .cell-output-stderr}
```
Warning: readOBJ() ignored non-comment line 3:
  o flat_tri_ecmc
```
:::
:::


::: {#b05bdc43-7033-420b-bbdf-0daf113ed228 .cell execution_count=40}
``` {.python .cell-code}
# hemeshes can be compared for equali and are registered as py-trees

leafs, ts = jax.tree_util.tree_flatten(hemesh)

hemesh, hemesh == hemesh
```

::: {.cell-output .cell-output-display execution_count=40}
```
(HeMesh(N_V=131, N_HE=708, N_F=224), True)
```
:::
:::


::: {#5363c9ed .cell execution_count=44}
``` {.python .cell-code}
# test iteration around vertex
hemesh.dest[hemesh.iterate_around_vertex(69)], hemesh.orig[hemesh.iterate_around_vertex(56)]
```

::: {.cell-output .cell-output-display execution_count=44}
```
(Array([80, 68, 56, 46], dtype=int64),
 Array([56, 56, 56, 56, 56, 56, 56], dtype=int64))
```
:::
:::


::: {#e19181b5 .cell}
``` {.python .cell-code}
# boundary in cc-wise order
(hemesh.orig[187], hemesh.dest[187]), hemesh.heface[187], hemesh.is_bdry_he[187],
```

::: {.cell-output .cell-output-display}
```
((Array(58, dtype=int64), Array(70, dtype=int64)),
 Array(-1, dtype=int64),
 Array(True, dtype=bool))
```
:::
:::


::: {#6525ab64 .cell}
``` {.python .cell-code}
hemesh.is_bdry_he[187], hemesh.is_bdry_he[541], hemesh.heface[541]
```

::: {.cell-output .cell-output-display}
```
(Array(True, dtype=bool), Array(False, dtype=bool))
```
:::
:::


::: {#e6f9df51 .cell execution_count=46}
``` {.python .cell-code}
# to model mesh boundaries, we can add an "infinity" vertex. Not done here, see below
hemesh.has_inf_vertex, hemesh.inf_vertices
```

::: {.cell-output .cell-output-display execution_count=46}
```
(False, ())
```
:::
:::


::: {#e5c1c05d .cell execution_count=45}
``` {.python .cell-code}
fig = plt.figure(figsize=(14,14))

plt.triplot(*mesh.vertices.T, hemesh.faces)
label_plot(mesh.vertices, hemesh.faces, fontsize=10, hemesh=hemesh, face_labels=False)
plt.axis("equal")
```

::: {.cell-output .cell-output-display execution_count=45}
```
(np.float64(-1.10003475),
 np.float64(1.09628575),
 np.float64(-1.09934025),
 np.float64(1.09050125))
```
:::

::: {.cell-output .cell-output-display}
![](00_triangulation_datastructure_files/figure-html/cell-33-output-2.png){}
:::
:::


::: {#9ffe63d8-0da6-4c74-bef7-c35727d76ff9 .cell execution_count=47}
``` {.python .cell-code}
# here is how you would do mesh traversal with jax.lax. The issues is that the output size needs to be fixed
# ahead of time, so 

self = hemesh
max_valence = 10
v = 10

initial = jnp.hstack([jnp.array([self.incident[v]]), -1*jnp.ones(max_valence-1, dtype=int)])
jax.lax.fori_loop(1, max_valence, lambda i, x: x.at[i].set(self.twin[x[i-1]]), initial)
```

::: {.cell-output .cell-output-display execution_count=47}
```
Array([ 47, 401,  47, 401,  47, 401,  47, 401,  47, 401], dtype=int64)
```
:::
:::


### Boundary and the vertex at infinity

So far, our mesh representations [`TriMesh`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#trimesh) and [`HeMesh`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#hemesh) work for triangular meshes with and without boundary. Boundary half-edges are  assigned to a fictitious `-1` face. 

This convention has a downside. It is not possible to modify the boundary loop of the mesh by edge flips - doing so would result in an invalid state. In a simulation, this artificially limits the mesh's ability to deform. Instead, we can add a "vertex at infinity" and connect all boundary edges to $\infty$. This turns the mesh from a topological disk into a topological sphere. Now, one can flip boundary edges without the overall number of half-edges changing (so the array shape stays the same). 

The vertex coordinates of the fictitious face are set to `[np.inf, np.inf]` by convention. The boundary is found by iterating around $\infty$.
By convention, $\infty$, if it exists, is the final vertex of the mesh (don't rely on this - implementation detail). 

We generally assume that the mesh has only a single connected component.

The [`HeMesh`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#hemesh) class can deal with both the -1-face and the $\infty$-vertex conventions. Multiple boundaries are also supported. Each boundary corresponds to a distinct $\infty$-vertex (for example, 2 for a cylinder), which are listed in the `inf_vertices` attribute of a [`HeMesh`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#hemesh).

---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L527){target="_blank" style="float:right; font-size:smaller"}

### connect_boundary_to_infinity

```python

def connect_boundary_to_infinity(
    vertices:Float[Array, 'n_vertices 2'], faces:Int[Array, 'n_faces 2']
)->Tuple:


```

*Connect boundary loop to infinity. New vertex is at final position and has coordinates [np.inf, np.inf].*

This function assumes the mesh has exactly one boundary.


::: {#0f81dc06 .cell execution_count=68}
``` {.python .cell-code}
mesh = TriMesh.read_obj("test_meshes/disk.obj")
hemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)
```

::: {.cell-output .cell-output-stderr}
```
Warning: readOBJ() ignored non-comment line 3:
  o flat_tri_ecmc
```
:::
:::


::: {#8a429fcb .cell execution_count=69}
``` {.python .cell-code}
mesh_infty = TriMesh(*connect_boundary_to_infinity(mesh.vertices, mesh.faces))
hemesh_infty = HeMesh.from_triangles(mesh_infty.vertices.shape[0], mesh_infty.faces,
                                     inf_vertices=(mesh_infty.vertices.shape[0]-1,))
```
:::


::: {#7db747fb .cell execution_count=70}
``` {.python .cell-code}
igl.is_edge_manifold(mesh_infty.faces)[0], igl.is_vertex_manifold(mesh_infty.faces)[0]
```

::: {.cell-output .cell-output-display execution_count=70}
```
(True, np.True_)
```
:::
:::


::: {#7877f979 .cell execution_count=71}
``` {.python .cell-code}
hemesh_infty.dest[hemesh_infty.iterate_around_vertex(-1)], igl.boundary_loop(mesh.faces)
```

::: {.cell-output .cell-output-display execution_count=71}
```
(Array([  0,  10,  21,  34,  47,  58,  70,  86,  91, 100, 108, 113, 114,
        110, 111, 112, 107,  99,  85,  80,  69,  46,  33,  32,  20,   9,
        130, 121, 120, 119, 118, 117, 116, 115, 123, 122], dtype=int64),
 array([  0, 122, 123, 115, 116, 117, 118, 119, 120, 121, 130,   9,  20,
         32,  33,  46,  69,  80,  85,  99, 107, 112, 111, 110, 114, 113,
        108, 100,  91,  86,  70,  58,  47,  34,  21,  10], dtype=int64))
```
:::
:::


::: {#3f091294 .cell execution_count=72}
``` {.python .cell-code}
hemesh_infty.dest[hemesh_infty.iterate_around_vertex(0)], hemesh.dest[hemesh.iterate_around_vertex(0)]
```

::: {.cell-output .cell-output-display execution_count=72}
```
(Array([  1,  11,  10, 131, 122], dtype=int64),
 Array([  1,  11,  10, 122], dtype=int64))
```
:::
:::


::: {#a644a364 .cell execution_count=73}
``` {.python .cell-code}
(hemesh.is_bdry == (hemesh_infty.is_bdry[:-1] >0)).all()
```

::: {.cell-output .cell-output-display execution_count=73}
```
Array(True, dtype=bool)
```
:::
:::


::: {#e2505ce7 .cell execution_count=74}
``` {.python .cell-code}
# to get back the original faces/vertices, do this:

_ = hemesh_infty.faces[~hemesh_infty.is_inf_face]
```
:::


## Mesh geometry and per-mesh variables

Mesh geometry (vertex and face positions) and per-mesh-item (per-face, per-half-edge, per-vertex) variables are combined into a second data class, the [`GeomMesh`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#geommesh).

### Vertex, half-edge, and face properties

In simulations, we will often want to attach extra information to a mesh's vertices/edges/faces. In the [`GeomMesh`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#geommesh) class, these are saved in three dictionaries, `vertex_attribs`, `he_attribs`, `face_attribs`. Each key/value pair represents one property (for example, the cell target area). All values are arrays, and the first axis corresponds to the number of vertices/half-edges/faces, respectively.
To keep track of the possible attributes, we use `IntEnum`'s as keys (this also ensures keys are hashable, as required by JAX)

---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L553){target="_blank" style="float:right; font-size:smaller"}

### FaceAttribs

```python

def FaceAttribs(
    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD
):


```

*Enum where members are also (and must be) ints*


---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L550){target="_blank" style="float:right; font-size:smaller"}

### HeAttribs

```python

def HeAttribs(
    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD
):


```

*Enum where members are also (and must be) ints*


---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L546){target="_blank" style="float:right; font-size:smaller"}

### VertexAttribs

```python

def VertexAttribs(
    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD
):


```

*Enum where members are also (and must be) ints*


::: {#97f8169c .cell execution_count=76}
``` {.python .cell-code}
HeAttribs.EDGE_TENSION, HeAttribs(1), HeAttribs['EDGE_TENSION'], HeAttribs.EDGE_TENSION.name
```

::: {.cell-output .cell-output-display execution_count=76}
```
(<HeAttribs.EDGE_TENSION: 1>,
 <HeAttribs.EDGE_TENSION: 1>,
 <HeAttribs.EDGE_TENSION: 1>,
 'EDGE_TENSION')
```
:::
:::


---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L563){target="_blank" style="float:right; font-size:smaller"}

### GeomMesh

```python

def GeomMesh(
    n_vertices:int, n_hes:int, n_faces:int, vertices:Float[Array, 'n_vertices dim'],
    face_positions:Float[Array, 'n_faces 3']=<factory>, vertex_attribs:Dict=<factory>, he_attribs:Dict=<factory>,
    face_attribs:Dict=<factory>
)->None:


```

*Data class for holding mesh geometry and mesh-associated variables.*
To be combined with a HeMesh to specify the connectivity.

One array (for vertex positions) must always be present. A second,
but optional, standard entry is a set of positions for each face. 
The mesh coordinates can live in 2d or 3d.

Optionally, vertices, half-edges, and faces can have attributes (stored as dictionaries).
The keys of the dictionary should be taken from a suitable 'enum'. The values are 
ndarrays, whose 0th axis is (vertices/edges/faces). These attribute dicts are
initialized empty and can be set afterwards.

See documentation on HeMesh

**Attributes**

vertices : Float[jax.Array, "n_vertices 2"]

face_positions : Float[jax.Array, "n_faces 2"]

vertex_attribs : Dict[IntEnum, Float[jax.Array, "n_vertices *"]]

he_attribs : Dict[IntEnum, Float[jax.Array, "n_hes *"]]

face_attribs : Dict[IntEnum, Float[jax.Array, "n_faces *"]]

**Property methods (use like attributes)**

n_items : Tuple[int, int, int]

dim : int

**Class methods**

validate_dimensions : bool

**Static methods**

load : str -> GeomHeMesh


---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L693){target="_blank" style="float:right; font-size:smaller"}

### set_voronoi_face_positions

```python

def set_voronoi_face_positions(
    geommesh:GeomMesh, hemesh:HeMesh
)->GeomMesh:


```

*Set face positions of geommesh to the circumcenters of the faces defined by hemesh.*


---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L699){target="_blank" style="float:right; font-size:smaller"}

### Mesh

```python

def Mesh(
    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD
):


```

*Combine geometric and connectivity info into a single object.*


::: {#c78f0f4a-6bea-40e5-baf3-628f777b1d0f .cell execution_count=80}
``` {.python .cell-code}
mesh = TriMesh.read_obj("test_meshes/disk.obj")
hemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)
geommesh = GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)
```

::: {.cell-output .cell-output-stderr}
```
Warning: readOBJ() ignored non-comment line 3:
  o flat_tri_ecmc
```
:::
:::


::: {#88381eed-c22c-49cd-8606-c62500eb28a7 .cell scrolled='true' execution_count=81}
``` {.python .cell-code}
combined_mesh = Mesh(geommesh, hemesh)
combined_mesh
```

::: {.cell-output .cell-output-display execution_count=81}
```
Mesh(geommesh=GeomMesh(D=2,N_V=131, N_HE=708, N_F=224), hemesh=HeMesh(N_V=131, N_HE=708, N_F=224))
```
:::
:::


::: {#fc035cf3-bf00-42e9-a2f3-103c240e3fe0 .cell execution_count=82}
``` {.python .cell-code}
leafs, ts = jax.tree_util.tree_flatten(geommesh) # also a pytree
ts
```

::: {.cell-output .cell-output-display execution_count=82}
```
PyTreeDef(CustomNode(GeomMesh[(131, 708, 224)], [*, *, {}, {}, {}]))
```
:::
:::


::: {#c006504e-0193-4831-9ade-5c7cec6b3d47 .cell execution_count=83}
``` {.python .cell-code}
geommesh, geommesh.n_vertices, geommesh.vertices.shape, geommesh.check_compatibility(hemesh), geommesh == geommesh
```

::: {.cell-output .cell-output-display execution_count=83}
```
(GeomMesh(D=2,N_V=131, N_HE=708, N_F=224), 131, (131, 2), True, True)
```
:::
:::


---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L705){target="_blank" style="float:right; font-size:smaller"}

### cellplot

```python

def cellplot(
    hemesh:HeMesh, face_positions:Float[Array, 'n_faces 2'], cell_colors:type=None,
    mpl_polygon_kwargs:GenericAlias=type, ax:type=None
)->List:


```

*Plot a cell tesselation.*

cell_colors can be either a single color (for all cells) or a vector of rgba values.
Only interior cells are plotted.


::: {#b4496688-152b-43d0-b66f-b1b11718c849 .cell execution_count=85}
``` {.python .cell-code}
plt.triplot(*geommesh.vertices.T, hemesh.faces)
ax = plt.gca()
p = cellplot(hemesh, geommesh.face_positions,
             ax=ax, cell_colors=(0,0,1,0.5), mpl_polygon_kwargs={"lw": 1, "ec": "k"})
plt.axis("equal")
```

::: {.cell-output .cell-output-display execution_count=85}
```
(np.float64(-1.10003475),
 np.float64(1.09628575),
 np.float64(-1.09934025),
 np.float64(1.09050125))
```
:::

::: {.cell-output .cell-output-display}
![](00_triangulation_datastructure_files/figure-html/cell-55-output-2.png){}
:::
:::


### Adding some vertex/half-edge/face properties

::: {#452cebbe .cell execution_count=63}
``` {.python .cell-code}
mesh = TriMesh.read_obj("test_meshes/disk.obj")
hemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)
geommmesh = GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)
```

::: {.cell-output .cell-output-stderr}
```
Warning: readOBJ() ignored non-comment line 3:
  o flat_tri_ecmc
```
:::
:::


::: {#c78e5b0b .cell execution_count=64}
``` {.python .cell-code}
# at initialization, a HeMesh's attribute dictionaries are empty
geommmesh.vertex_attribs
```

::: {.cell-output .cell-output-display execution_count=64}
```
{}
```
:::
:::


::: {#edd75cb5 .cell execution_count=65}
``` {.python .cell-code}
# set some attributes

geommmesh = dataclasses.replace(geommmesh, vertex_attribs={VertexAttribs.TARGET_AREA: np.random.normal(size=geommmesh.n_vertices),
                                                           VertexAttribs.TARGET_PERIMETER: np.random.normal(size=geommmesh.n_vertices)})
geommmesh = dataclasses.replace(geommmesh, he_attribs={HeAttribs.EDGE_TENSION: np.random.normal(size=geommmesh.n_hes)})
```
:::


::: {#595f136b .cell execution_count=66}
``` {.python .cell-code}
geommmesh.he_attribs.keys()
```

::: {.cell-output .cell-output-display execution_count=66}
```
dict_keys([<HeAttribs.EDGE_TENSION: 1>])
```
:::
:::


## Batching

In our simulations, we may want to "batch" over several initial conditions/random seeds/etc (analogous to batching over training data in normal ML). In JAX, we can efficiently and concisely vectorize operations over such "batch axes" with `jax.vmap`. 

To batch over our custom data structures, we need to pull a small trick - convert a list of [`HeMesh`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#hemesh)/`GeomMeshe` instances into a single mesh with a batch axis for the various arrays. Luckily, this can be [done using JAX's pytree tools](https://stackoverflow.com/questions/79123001/storing-and-jax-vmap-over-pytrees).

---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L743){target="_blank" style="float:right; font-size:smaller"}

### tree_unstack

```python

def tree_unstack(
    xb:PyTree, axis:int=0
)->List:


```

*Unstack a batched pytree along axis into a list of pytrees.*


---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L739){target="_blank" style="float:right; font-size:smaller"}

### tree_stack

```python

def tree_stack(
    xs:List, axis:int=0
)->PyTree:


```

*Stack a sequence of identical-structure pytrees along a new axis.*


::: {#54eb9677 .cell execution_count=119}
``` {.python .cell-code}
## Let us create a bunch of meshes with different initial positions and see if we can batch over them using vmap

key = jax.random.key(0)
sigma = 0.02

batch_geom = []
batch_he = []
for i in range(3):
    key, subkey = jax.random.split(key)
    random_noise = jax.random.normal(subkey, shape=geommmesh.vertices.shape)
    batch_geom.append(dataclasses.replace(geommmesh, vertices=geommmesh.vertices+sigma*random_noise))
    batch_he.append(copy.copy(hemesh))
```
:::


::: {#5856c3c5 .cell}
``` {.python .cell-code}
# define a test function to appy over the batch

def test_function(geommesh: GeomMesh, hemesh: HeMesh) -> Float[jax.Array, " n_vertices"]:
    """Dummy test function."""
    return jnp.ones(geommesh.n_vertices)
```
:::


::: {#24cb28d8 .cell execution_count=130}
``` {.python .cell-code}
# naive batching does not work. JAX needs a "struct-of-arrays", but a list of HeMeshes is an "array-of-structs"
# see https://stackoverflow.com/questions/79123001/storing-and-jax-vmap-over-pytrees

try:
    jax.vmap(test_function)(batch_geom, batch_he)
except ValueError as e:
    print("Expected error:", e)
```

::: {.cell-output .cell-output-stdout}
```
Expected error: vmap got inconsistent sizes for array axes to be mapped:
  * most axes (21 of them) had size 708, e.g. axis 0 of argument geommesh[0].he_attribs[<HeAttribs.EDGE_TENSION: 1>] of type float64[708];
  * some axes (12 of them) had size 131, e.g. axis 0 of argument geommesh[0].vertices of type float64[131,2];
  * some axes (6 of them) had size 224, e.g. axis 0 of argument geommesh[0].face_positions of type float64[224,2]
```
:::
:::


::: {#cea01cba .cell execution_count=123}
``` {.python .cell-code}
# instead, we use a jax.tree.map to "push" the list axis into the underlying arrays.

batch_he_array = tree_stack(batch_he)
batch_geom_array = tree_stack(batch_geom)
batch_geom_array, batch_geom_array.vertices.shape
```

::: {.cell-output .cell-output-display execution_count=123}
```
(GeomMesh(D=2,N_V=131, N_HE=708, N_F=224), (3, 131, 2))
```
:::
:::


::: {#f976d553 .cell}
``` {.python .cell-code}
# now it works! The result is a single object with batch axis

batch_out = jax.vmap(test_function)(batch_geom_array, batch_he_array) 
batch_out.shape
```

::: {.cell-output .cell-output-display execution_count=127}
```
(3, 131)
```
:::
:::


::: {#4efdd241 .cell}
``` {.python .cell-code}
# we can unpack things again into a list of meshes

isinstance(tree_unstack(batch_out), list)
```

::: {.cell-output .cell-output-display execution_count=129}
```
True
```
:::
:::


## Edge flips / T1s

In our simulations, cells will exchange neighbors (T1-event). In the triangulation, this corresponds to an edge flip. We now implement the edge flip algorithm for [`HeMesh`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#hemesh)es. We basically edit the various connectivity arrays (in a JAX-compatible way).

The algorithm (and the naming conventions in [`flip_edge`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#flip_edge)) are from here: https://jerryyin.info/geometry-processing-algorithms/half-edge/.

**Before**

![image.png](00_triangulation_datastructure_files/figure-html/1b16caba-387e-4705-b2ea-e0adcdd61ca6-1-84d03218-dec8-4992-9150-5054fdbf5dec.png)

**After**

![image.png](00_triangulation_datastructure_files/figure-html/1b16caba-387e-4705-b2ea-e0adcdd61ca6-2-86f67a10-6db4-41e8-b111-1d355d7fb2a6.png)

---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L754){target="_blank" style="float:right; font-size:smaller"}

### flip_edge

```python

def flip_edge(
    hemesh:HeMesh, e:int, check_boundary:bool=False
)->HeMesh:


```

*Flip half-edge e in a half-edge mesh.*

See https://jerryyin.info/geometry-processing-algorithms/half-edge/. The algorithm
is slightly modified since we keep track of the origin and destination of a half-edge,
and use arrays instead of pointers. Returns a new HeMesh, does not modify in-place.


---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L791){target="_blank" style="float:right; font-size:smaller"}

### get_signed_dual_he_length

```python

def get_signed_dual_he_length(
    geommesh:GeomMesh, hemesh:HeMesh
)->Float[Array, 'n_hes']:


```

*Compute lengths of dual edges. Boundary dual edges get length np.nan. Negative sign = flipped edge.*


::: {#51a6342f-fd8c-44d4-8f68-f4bbee5c2fd2 .cell execution_count=88}
``` {.python .cell-code}
mesh = TriMesh.read_obj("test_meshes/disk.obj")
hemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)
geommesh = GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)
```

::: {.cell-output .cell-output-stderr}
```
Warning: readOBJ() ignored non-comment line 3:
  o flat_tri_ecmc
```
:::
:::


::: {#d452e19f-c44f-4dd5-96e7-7b8c1f551f39 .cell scrolled='true' execution_count=89}
``` {.python .cell-code}
plt.triplot(*geommesh.vertices.T, hemesh.faces)
ax = plt.gca()
p = cellplot(hemesh, geommesh.face_positions,
             ax=ax, cell_colors=(0,0,0,0.1), mpl_polygon_kwargs={"lw": 1, "ec": "k"})
plt.axis("equal")
```

::: {.cell-output .cell-output-display execution_count=89}
```
(np.float64(-1.10003475),
 np.float64(1.09628575),
 np.float64(-1.09934025),
 np.float64(1.09050125))
```
:::

::: {.cell-output .cell-output-display}
![](00_triangulation_datastructure_files/figure-html/cell-71-output-2.png){}
:::
:::


::: {#55e7cfc0-2d38-4a21-b0fa-a7c47b16135a .cell execution_count=90}
``` {.python .cell-code}
# edges and dual edges should be orthogonal since we are using circumcenters

edges = geommesh.vertices[hemesh.orig]-geommesh.vertices[hemesh.dest]
dual_edges = (geommesh.face_positions[hemesh.heface]
              -geommesh.face_positions[hemesh.heface[hemesh.twin]])

jnp.allclose(jnp.einsum('vi,vi->v', edges[~hemesh.is_bdry_edge], dual_edges[~hemesh.is_bdry_edge]), 0)
```

::: {.cell-output .cell-output-display execution_count=90}
```
Array(True, dtype=bool)
```
:::
:::


::: {#7d39c278-7566-4096-ab99-31f8a01c681d .cell execution_count=91}
``` {.python .cell-code}
# computing the signed edge length shows that there are some "flipped" edges.

signed_squared_length = jnp.einsum('vi,vi->v', edges, dual_edges @ get_rot_mat(np.pi/2))
jnp.where((signed_squared_length < -0.0) & ~hemesh.is_bdry_edge )[0]
```

::: {.cell-output .cell-output-display execution_count=91}
```
Array([  9, 185, 191, 335, 363, 539, 545, 689], dtype=int64)
```
:::
:::


::: {#d967f938-a498-49cc-91f7-a392ba5ad068 .cell}
``` {.python .cell-code}
# flip edge and recompute face positions

flipped_hemesh = flip_edge(hemesh, e=335)
flipped_geommesh = set_voronoi_face_positions(geommesh, flipped_hemesh)
```
:::


::: {#9b047482-87c1-4607-bb44-f13ab9beb0af .cell execution_count=93}
``` {.python .cell-code}
# connectivity is still valid

igl.is_edge_manifold(hemesh.faces)[0], igl.is_edge_manifold(flipped_hemesh.faces)[0], flipped_hemesh.iterate_around_vertex(100)
```

::: {.cell-output .cell-output-display execution_count=93}
```
(True, True, Array([298, 299, 630, 632], dtype=int64))
```
:::
:::


::: {#998a6c7e-cc30-4bcf-924f-1701ce93b1f3 .cell}
``` {.python .cell-code}
# you can see the flipped edge in the plot below - it's where the blue mesh forms a "bow-tie"

fig = plt.figure(figsize=(8,8))

plt.triplot(*geommesh.vertices.T, hemesh.faces)
plt.triplot(*flipped_geommesh.vertices.T, flipped_hemesh.faces)

ax = plt.gca()
cellplot(hemesh, geommesh.face_positions,
         ax=ax, cell_colors=(0,0,0,0), mpl_polygon_kwargs={"lw": 1, "ec": "k"})
cellplot(flipped_hemesh, flipped_geommesh.face_positions,
         ax=ax, cell_colors=(0,0,0,0), mpl_polygon_kwargs={"lw": 1, "ec": "tab:orange"})
plt.axis("equal")

label_plot(geommesh.vertices, hemesh.faces, fontsize=10, face_labels=False)
```

::: {.cell-output .cell-output-display}
![](00_triangulation_datastructure_files/figure-html/cell-76-output-1.png){}
:::
:::


#### Repeated flips

In a simulation, we need to carry out edge flips at every timestep. The function `flip_edge(hemesh: HeMesh, e: int) -> HeMesh` does a single edge flip by modifying the connectivity arrays. Luckily, it is already JAX-compatible (we can JIT-compile it).

The next goal is to carry out multiple flips. We must be careful: doing multiple flips "simultaneously" risks leaving the mesh in an inconsistent state.
Instead, we do the flips in sequence. To make things JAX-compatible, we do a `jax.lax.scan` scan over all half-edges.

::: {#69320efd-505e-44af-9b28-f50a00e7fc53 .cell execution_count=95}
``` {.python .cell-code}
mesh = TriMesh.read_obj("test_meshes/disk.obj")
hemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)
geommesh = GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)
```

::: {.cell-output .cell-output-stderr}
```
Warning: readOBJ() ignored non-comment line 3:
  o flat_tri_ecmc
```
:::
:::


::: {#94b30732-54cb-495f-baf7-0faecb9c99f3 .cell}
``` {.python .cell-code}
dual_lengths = get_signed_dual_he_length(geommesh, hemesh)
edges = jnp.where((dual_lengths < -0.05) & ~hemesh.is_bdry_edge & hemesh.is_unique)[0]
# we only want to flip unique hes!
edges, edges.size
```

::: {.cell-output .cell-output-display execution_count=96}
```
(Array([  9, 185, 191, 335], dtype=int64), 4)
```
:::
:::


::: {#b281b408-08b1-4ae2-9c79-8ffbc4db4de4 .cell scrolled='true' execution_count=97}
``` {.python .cell-code}
# scan over indices of negative-length edges. 
flipped_hemesh, _ = jax.lax.scan(lambda h, e: (flip_edge(h, e), None) , init=hemesh, xs=edges)

# this scan is over an array whose shape varies. Instead, we can scan over all hes, and flip only if the length is negative (via jax.lax.cond).
```
:::


---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L803){target="_blank" style="float:right; font-size:smaller"}

### flip_all

```python

def flip_all(
    hemesh:HeMesh, to_flip:Bool[Array, 'n_hes']
)->HeMesh:


```

*Flip all (unique) half-edges where to_flip is True in a half-edge mesh. Wraps flip_edge.*


::: {#537a9784-2300-468a-9286-276464f97b72 .cell execution_count=99}
``` {.python .cell-code}
to_flip = (dual_lengths < 0) & ~jnp.isnan(dual_lengths)

flipped_hemesh = flip_all(hemesh, to_flip=to_flip)
```
:::


::: {#0ca16bb5-4865-4f87-ad92-fe5a290f8983 .cell execution_count=102}
``` {.python .cell-code}
flipped_hemesh = flip_all(hemesh, to_flip=(dual_lengths<0.02)) # no extra recompile
```
:::


::: {#9a6c0ce3-b7af-4951-aa50-11613294b86e .cell execution_count=105}
``` {.python .cell-code}
flipped_geommesh = set_voronoi_face_positions(geommesh, flipped_hemesh)
```
:::


::: {#2c38754f-750d-4da6-834e-bf030f2ab086 .cell execution_count=106}
``` {.python .cell-code}
fig = plt.figure(figsize=(8,8))

plt.triplot(*geommesh.vertices.T, hemesh.faces)
plt.triplot(*flipped_geommesh.vertices.T, flipped_hemesh.faces)

ax = plt.gca()
cellplot(hemesh, geommesh.face_positions,
         ax=ax, cell_colors=(0,0,0,0), mpl_polygon_kwargs={"lw": 1, "ec": "k"})
cellplot(flipped_hemesh, flipped_geommesh.face_positions,
         ax=ax, cell_colors=(0,0,0,0), mpl_polygon_kwargs={"lw": 1, "ec": "tab:orange"})
plt.axis("equal")

label_plot(geommesh.vertices, hemesh.faces, fontsize=10, face_labels=False)
```

::: {.cell-output .cell-output-display}
![](00_triangulation_datastructure_files/figure-html/cell-84-output-1.png){}
:::
:::


## Adjacency-like operators on half-edge meshes

### Computing cell areas, perimeters, etc via corners

To compute, for instance, the cell area using the shoelace formula, you need to iterate around the faces adjacent to a vertex. This is not straightforward to vectorize because the number of adjacent faces per vertex can vary (there can be 5-, 6-, 7-sided cells etc.).
That is, the list of adjacent faces is a "ragged" array. However, vectorization is essential for numerical efficiency and compatibility with JAX. For example, we may want to compute an energy and its gradient, which depends on cell areas.
One way to solve this is a scheme in which the lists of adjacent faces are "padded" in some manner, so that they are all the same length. This is cumbersome.

Instead, let us split all "cell-based" quantities into contributions from "corners", i.e., half-edges, like this:

![image.png](00_triangulation_datastructure_files/figure-html/35104309-d38f-4e0f-b64a-de86a49efa0d-1-e1bd53c0-c2f2-4413-af9d-a74a1592993a.png)
Source: [CGAL](https://doc.cgal.org/latest/Weights/group__PkgWeightsRefVoronoiRegionWeights.html)

To compute the total area, we can sum over all half-edges $(r,p)$ opposite to a vertex $q$.
Numerically, this can be achieved efficiently using gather/scatter operations.

---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L826){target="_blank" style="float:right; font-size:smaller"}

### sum_he_to_vertex_opposite

```python

def sum_he_to_vertex_opposite(
    hemesh:HeMesh, he_field:Float[Array, 'n_hes ...']
):


```

*Sum a half-edge field onto opposite vertices.*

hemesh: connectivity information
he_field: (n_hes,) or (n_hes, d) array


---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L814){target="_blank" style="float:right; font-size:smaller"}

### sum_he_to_vertex_incoming

```python

def sum_he_to_vertex_incoming(
    hemesh:HeMesh, he_field:Float[Array, 'n_hes ...']
):


```

*Sum a half-edge field onto destination vertices.*

hemesh: connectivity information
he_field: (n_hes,) or (n_hes, d) array


::: {#12e6b835-4263-4314-99f4-6974e5fea082 .cell}
``` {.python .cell-code}
# TO DO: implement gradient (vertex -> face) and cotan-Laplacian (vertex -> vertex) using gather/scatter ops like above .
# compare with igl to check correctness.
```
:::


::: {#4006c7fb-56a2-445c-9647-017dc017074e .cell execution_count=107}
``` {.python .cell-code}
mesh = TriMesh.read_obj("test_meshes/disk.obj")
hemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)
geommesh = GeomMesh(*hemesh.n_items, mesh.vertices, mesh.face_positions)
```

::: {.cell-output .cell-output-stderr}
```
Warning: readOBJ() ignored non-comment line 3:
  o flat_tri_ecmc
```
:::
:::


---

[source](https://github.com/nikolas-claussen/triangulax/blob/main/triangulax/mesh.py#L839){target="_blank" style="float:right; font-size:smaller"}

### get_cell_areas

```python

def get_cell_areas(
    geommesh:GeomMesh, hemesh:HeMesh
)->Float[Array, 'n_vertices']:


```

*Compute areas of cells by mesh traversal (don't use for simulation, inefficient).*

Boundary vertices get area 0.


::: {#5618181e-7193-48af-ac45-c1b3d77c4df3 .cell execution_count=111}
``` {.python .cell-code}
## Let's use the adjacency matrix to compute the area of all cells. First, compute all corner areas

a, b, c = (hemesh.dest[hemesh.nxt], hemesh.dest[hemesh.prv], hemesh.dest)

corner_areas = jax.vmap(get_voronoi_corner_area)(geommesh.vertices[a], geommesh.vertices[b], geommesh.vertices[c])
cell_areas_corner = sum_he_to_vertex_opposite(hemesh, corner_areas)
cell_areas_corner = cell_areas_corner.at[hemesh.is_bdry].set(0)
```
:::


::: {#462432a9-100a-400c-9942-9eb1643b05bb .cell execution_count=112}
``` {.python .cell-code}
# for comparison, compute the areas by mesh traversal

cell_areas_iterative = -1*get_cell_areas(geommesh, hemesh)
np.abs(cell_areas_iterative-cell_areas_corner).max() # works!
```

::: {.cell-output .cell-output-display execution_count=112}
```
np.float64(4.85722573273506e-17)
```
:::
:::


::: {#64840cc3-641c-4076-bbef-802d67cf3e4c .cell execution_count=113}
``` {.python .cell-code}
# using the gather/scatter trick, we can also compute the coordination number
sum_he_to_vertex_incoming(hemesh, jnp.ones(hemesh.n_hes)).at[hemesh.is_bdry].set(0)
```

::: {.cell-output .cell-output-display execution_count=113}
```
Array([0., 6., 6., 7., 6., 6., 6., 6., 6., 0., 0., 6., 6., 5., 6., 6., 6.,
       5., 5., 6., 0., 0., 6., 6., 6., 7., 5., 6., 6., 7., 7., 6., 0., 0.,
       0., 7., 6., 6., 5., 7., 6., 6., 6., 6., 7., 5., 0., 0., 5., 6., 6.,
       7., 7., 5., 6., 6., 7., 5., 0., 5., 7., 6., 5., 6., 5., 6., 7., 6.,
       5., 0., 0., 5., 6., 6., 6., 6., 6., 7., 6., 6., 0., 6., 6., 5., 6.,
       0., 0., 6., 6., 6., 7., 0., 6., 6., 6., 5., 6., 6., 6., 0., 0., 6.,
       6., 6., 6., 7., 6., 0., 0., 5., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
       0., 0., 0., 0., 0., 6., 6., 6., 6., 6., 6., 0.], dtype=float64)
```
:::
:::


## Saving to disk


We save and load [`TriMesh`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#trimesh) meshes as standard `.obj` files (with the hack of using `vn` lines for the face positions). The [`HeMesh`](https://nikolas-claussen.github.io/triangulax/triangulation_datastructure.html#hemesh) class is basically a collection of arrays, which we can save to disk using `numpy`.

::: {#100dfc0a .cell}
``` {.python .cell-code}
from tempfile import TemporaryFile
```
:::


::: {#7f1a720a-df0e-4a7e-97cb-715bb3ef687b .cell execution_count=114}
``` {.python .cell-code}
mesh = TriMesh.read_obj("test_meshes/disk.obj")
hemesh = HeMesh.from_triangles(mesh.vertices.shape[0], mesh.faces)
```

::: {.cell-output .cell-output-stderr}
```
Warning: readOBJ() ignored non-comment line 3:
  o flat_tri_ecmc
```
:::
:::


::: {#900dc102-544f-43a9-ba4b-70338e6b0d71 .cell}
``` {.python .cell-code}
# this is how to use np.savenpz

outfile = TemporaryFile()

x = np.arange(10)
y = np.sin(x)

np.savez(outfile, x=x, y=y)
_ = outfile.seek(0) # simulates closing & reopening file

npzfile = np.load(outfile)
sorted(npzfile.files), npzfile['x']
```

::: {.cell-output .cell-output-display execution_count=115}
```
(['x', 'y'], array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]))
```
:::
:::


::: {#72fd2f37-fd33-4abc-9fba-2f3e67cc4b2b .cell scrolled='true' execution_count=116}
``` {.python .cell-code}
outfile = TemporaryFile()

hemesh.save(outfile)
_ = outfile.seek(0) # simulates closing & reopening file
npzfile = np.load(outfile)
npzfile.files
```

::: {.cell-output .cell-output-display execution_count=116}
```
['incident',
 'orig',
 'dest',
 'twin',
 'nxt',
 'prv',
 'heface',
 'face_incident',
 'inf_vertices']
```
:::
:::


::: {#dac3d617-05e8-4293-951c-092530c44832 .cell execution_count=117}
``` {.python .cell-code}
outfile = TemporaryFile()

hemesh.save(outfile)
_ = outfile.seek(0) # simulates closing & reopening file
reloaded = HeMesh.load(outfile)

np.allclose(reloaded.faces, hemesh.faces)
```

::: {.cell-output .cell-output-display execution_count=117}
```
True
```
:::
:::


### Next steps

Looks good - the JAX-compatible triangular-mesh data structures seem to work. In particular, the tricky T1/edge-flip function. 
Next steps: toy simulation, notebook 01. 


